// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tag.proto

#ifndef PROTOBUF_tag_2eproto__INCLUDED
#define PROTOBUF_tag_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "weizhu.pb.h"
// @@protoc_insertion_point(includes)

namespace weizhu {
namespace tag {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tag_2eproto();
void protobuf_AssignDesc_tag_2eproto();
void protobuf_ShutdownFile_tag_2eproto();

class Category;
class Tag;
class Resource;
class GetRecommendTagResponse;
class GetCategoryResponse;
class GetCategoryTagListRequest;
class GetCategoryTagListResponse;
class GetUserTagListRequest;
class GetUserTagListResponse;
class GetResourceTagListRequest;
class GetResourceTagListResponse;
class CreateSubscribeTagRequest;
class CreateSubscribeTagResponse;
class DeleteSubscribeTagRequest;
class DeleteSubscribeTagResponse;

enum CreateSubscribeTagResponse_Result {
  CreateSubscribeTagResponse_Result_SUCC = 0,
  CreateSubscribeTagResponse_Result_FAIL_UNKNOWN = 99
};
bool CreateSubscribeTagResponse_Result_IsValid(int value);
const CreateSubscribeTagResponse_Result CreateSubscribeTagResponse_Result_Result_MIN = CreateSubscribeTagResponse_Result_SUCC;
const CreateSubscribeTagResponse_Result CreateSubscribeTagResponse_Result_Result_MAX = CreateSubscribeTagResponse_Result_FAIL_UNKNOWN;
const int CreateSubscribeTagResponse_Result_Result_ARRAYSIZE = CreateSubscribeTagResponse_Result_Result_MAX + 1;

enum DeleteSubscribeTagResponse_Result {
  DeleteSubscribeTagResponse_Result_SUCC = 0,
  DeleteSubscribeTagResponse_Result_FAIL_UNKNOWN = 99
};
bool DeleteSubscribeTagResponse_Result_IsValid(int value);
const DeleteSubscribeTagResponse_Result DeleteSubscribeTagResponse_Result_Result_MIN = DeleteSubscribeTagResponse_Result_SUCC;
const DeleteSubscribeTagResponse_Result DeleteSubscribeTagResponse_Result_Result_MAX = DeleteSubscribeTagResponse_Result_FAIL_UNKNOWN;
const int DeleteSubscribeTagResponse_Result_Result_ARRAYSIZE = DeleteSubscribeTagResponse_Result_Result_MAX + 1;

enum State {
  NORMAL = 0,
  DISABLE = 1,
  DELETE = 2
};
bool State_IsValid(int value);
const State State_MIN = NORMAL;
const State State_MAX = DELETE;
const int State_ARRAYSIZE = State_MAX + 1;

// ===================================================================

class Category : public ::google::protobuf::MessageLite {
 public:
  Category();
  virtual ~Category();

  Category(const Category& from);

  inline Category& operator=(const Category& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Category& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Category* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Category* other);

  // implements Message ----------------------------------------------

  Category* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Category& from);
  void MergeFrom(const Category& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 category_id = 1;
  inline bool has_category_id() const;
  inline void clear_category_id();
  static const int kCategoryIdFieldNumber = 1;
  inline ::google::protobuf::int32 category_id() const;
  inline void set_category_id(::google::protobuf::int32 value);

  // required string category_name = 2;
  inline bool has_category_name() const;
  inline void clear_category_name();
  static const int kCategoryNameFieldNumber = 2;
  inline const ::std::string& category_name() const;
  inline void set_category_name(const ::std::string& value);
  inline void set_category_name(const char* value);
  inline void set_category_name(const char* value, size_t size);
  inline ::std::string* mutable_category_name();
  inline ::std::string* release_category_name();
  inline void set_allocated_category_name(::std::string* category_name);

  // optional .weizhu.tag.State state = 95 [default = NORMAL];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 95;
  inline ::weizhu::tag::State state() const;
  inline void set_state(::weizhu::tag::State value);

  // optional int64 create_admin_id = 96;
  inline bool has_create_admin_id() const;
  inline void clear_create_admin_id();
  static const int kCreateAdminIdFieldNumber = 96;
  inline ::google::protobuf::int64 create_admin_id() const;
  inline void set_create_admin_id(::google::protobuf::int64 value);

  // optional int32 create_time = 97;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 97;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional int64 update_admin_id = 98;
  inline bool has_update_admin_id() const;
  inline void clear_update_admin_id();
  static const int kUpdateAdminIdFieldNumber = 98;
  inline ::google::protobuf::int64 update_admin_id() const;
  inline void set_update_admin_id(::google::protobuf::int64 value);

  // optional int32 update_time = 99;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 99;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.tag.Category)
 private:
  inline void set_has_category_id();
  inline void clear_has_category_id();
  inline void set_has_category_name();
  inline void clear_has_category_name();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_create_admin_id();
  inline void clear_has_create_admin_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_update_admin_id();
  inline void clear_has_update_admin_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* category_name_;
  ::google::protobuf::int32 category_id_;
  int state_;
  ::google::protobuf::int64 create_admin_id_;
  ::google::protobuf::int64 update_admin_id_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int32 update_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static Category* default_instance_;
};
// -------------------------------------------------------------------

class Tag : public ::google::protobuf::MessageLite {
 public:
  Tag();
  virtual ~Tag();

  Tag(const Tag& from);

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Tag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Tag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Tag* other);

  // implements Message ----------------------------------------------

  Tag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Tag& from);
  void MergeFrom(const Tag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tag_id = 1;
  inline bool has_tag_id() const;
  inline void clear_tag_id();
  static const int kTagIdFieldNumber = 1;
  inline ::google::protobuf::int32 tag_id() const;
  inline void set_tag_id(::google::protobuf::int32 value);

  // required string tag_name = 2;
  inline bool has_tag_name() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 2;
  inline const ::std::string& tag_name() const;
  inline void set_tag_name(const ::std::string& value);
  inline void set_tag_name(const char* value);
  inline void set_tag_name(const char* value, size_t size);
  inline ::std::string* mutable_tag_name();
  inline ::std::string* release_tag_name();
  inline void set_allocated_tag_name(::std::string* tag_name);

  // required bool is_recommend = 3;
  inline bool has_is_recommend() const;
  inline void clear_is_recommend();
  static const int kIsRecommendFieldNumber = 3;
  inline bool is_recommend() const;
  inline void set_is_recommend(bool value);

  // repeated int32 category_id = 4;
  inline int category_id_size() const;
  inline void clear_category_id();
  static const int kCategoryIdFieldNumber = 4;
  inline ::google::protobuf::int32 category_id(int index) const;
  inline void set_category_id(int index, ::google::protobuf::int32 value);
  inline void add_category_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      category_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_category_id();

  // optional int32 user_count = 21;
  inline bool has_user_count() const;
  inline void clear_user_count();
  static const int kUserCountFieldNumber = 21;
  inline ::google::protobuf::int32 user_count() const;
  inline void set_user_count(::google::protobuf::int32 value);

  // optional bool is_subscribe = 22;
  inline bool has_is_subscribe() const;
  inline void clear_is_subscribe();
  static const int kIsSubscribeFieldNumber = 22;
  inline bool is_subscribe() const;
  inline void set_is_subscribe(bool value);

  // optional int64 create_admin_id = 96;
  inline bool has_create_admin_id() const;
  inline void clear_create_admin_id();
  static const int kCreateAdminIdFieldNumber = 96;
  inline ::google::protobuf::int64 create_admin_id() const;
  inline void set_create_admin_id(::google::protobuf::int64 value);

  // optional int32 create_time = 97;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 97;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional int64 update_admin_id = 98;
  inline bool has_update_admin_id() const;
  inline void clear_update_admin_id();
  static const int kUpdateAdminIdFieldNumber = 98;
  inline ::google::protobuf::int64 update_admin_id() const;
  inline void set_update_admin_id(::google::protobuf::int64 value);

  // optional int32 update_time = 99;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 99;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.tag.Tag)
 private:
  inline void set_has_tag_id();
  inline void clear_has_tag_id();
  inline void set_has_tag_name();
  inline void clear_has_tag_name();
  inline void set_has_is_recommend();
  inline void clear_has_is_recommend();
  inline void set_has_user_count();
  inline void clear_has_user_count();
  inline void set_has_is_subscribe();
  inline void clear_has_is_subscribe();
  inline void set_has_create_admin_id();
  inline void clear_has_create_admin_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_update_admin_id();
  inline void clear_has_update_admin_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_name_;
  ::google::protobuf::int32 tag_id_;
  bool is_recommend_;
  bool is_subscribe_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > category_id_;
  ::google::protobuf::int32 user_count_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int64 create_admin_id_;
  ::google::protobuf::int64 update_admin_id_;
  ::google::protobuf::int32 update_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static Tag* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::MessageLite {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Resource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Resource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Resource* other);

  // implements Message ----------------------------------------------

  Resource* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string resource_type = 1;
  inline bool has_resource_type() const;
  inline void clear_resource_type();
  static const int kResourceTypeFieldNumber = 1;
  inline const ::std::string& resource_type() const;
  inline void set_resource_type(const ::std::string& value);
  inline void set_resource_type(const char* value);
  inline void set_resource_type(const char* value, size_t size);
  inline ::std::string* mutable_resource_type();
  inline ::std::string* release_resource_type();
  inline void set_allocated_resource_type(::std::string* resource_type);

  // required string resource_id = 2;
  inline bool has_resource_id() const;
  inline void clear_resource_id();
  static const int kResourceIdFieldNumber = 2;
  inline const ::std::string& resource_id() const;
  inline void set_resource_id(const ::std::string& value);
  inline void set_resource_id(const char* value);
  inline void set_resource_id(const char* value, size_t size);
  inline ::std::string* mutable_resource_id();
  inline ::std::string* release_resource_id();
  inline void set_allocated_resource_id(::std::string* resource_id);

  // @@protoc_insertion_point(class_scope:weizhu.tag.Resource)
 private:
  inline void set_has_resource_type();
  inline void clear_has_resource_type();
  inline void set_has_resource_id();
  inline void clear_has_resource_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* resource_type_;
  ::std::string* resource_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class GetRecommendTagResponse : public ::google::protobuf::MessageLite {
 public:
  GetRecommendTagResponse();
  virtual ~GetRecommendTagResponse();

  GetRecommendTagResponse(const GetRecommendTagResponse& from);

  inline GetRecommendTagResponse& operator=(const GetRecommendTagResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetRecommendTagResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetRecommendTagResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetRecommendTagResponse* other);

  // implements Message ----------------------------------------------

  GetRecommendTagResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetRecommendTagResponse& from);
  void MergeFrom(const GetRecommendTagResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.tag.Tag recommend_tag = 1;
  inline int recommend_tag_size() const;
  inline void clear_recommend_tag();
  static const int kRecommendTagFieldNumber = 1;
  inline const ::weizhu::tag::Tag& recommend_tag(int index) const;
  inline ::weizhu::tag::Tag* mutable_recommend_tag(int index);
  inline ::weizhu::tag::Tag* add_recommend_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
      recommend_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
      mutable_recommend_tag();

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetRecommendTagResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag > recommend_tag_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetRecommendTagResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetCategoryResponse : public ::google::protobuf::MessageLite {
 public:
  GetCategoryResponse();
  virtual ~GetCategoryResponse();

  GetCategoryResponse(const GetCategoryResponse& from);

  inline GetCategoryResponse& operator=(const GetCategoryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCategoryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCategoryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCategoryResponse* other);

  // implements Message ----------------------------------------------

  GetCategoryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCategoryResponse& from);
  void MergeFrom(const GetCategoryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.tag.Category category = 1;
  inline int category_size() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline const ::weizhu::tag::Category& category(int index) const;
  inline ::weizhu::tag::Category* mutable_category(int index);
  inline ::weizhu::tag::Category* add_category();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Category >&
      category() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Category >*
      mutable_category();

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetCategoryResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Category > category_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetCategoryResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetCategoryTagListRequest : public ::google::protobuf::MessageLite {
 public:
  GetCategoryTagListRequest();
  virtual ~GetCategoryTagListRequest();

  GetCategoryTagListRequest(const GetCategoryTagListRequest& from);

  inline GetCategoryTagListRequest& operator=(const GetCategoryTagListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCategoryTagListRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCategoryTagListRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCategoryTagListRequest* other);

  // implements Message ----------------------------------------------

  GetCategoryTagListRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCategoryTagListRequest& from);
  void MergeFrom(const GetCategoryTagListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 category_id = 1;
  inline bool has_category_id() const;
  inline void clear_category_id();
  static const int kCategoryIdFieldNumber = 1;
  inline ::google::protobuf::int32 category_id() const;
  inline void set_category_id(::google::protobuf::int32 value);

  // required int32 tag_size = 2;
  inline bool has_tag_size() const;
  inline void clear_tag_size();
  static const int kTagSizeFieldNumber = 2;
  inline ::google::protobuf::int32 tag_size() const;
  inline void set_tag_size(::google::protobuf::int32 value);

  // optional bytes offset_index = 3;
  inline bool has_offset_index() const;
  inline void clear_offset_index();
  static const int kOffsetIndexFieldNumber = 3;
  inline const ::std::string& offset_index() const;
  inline void set_offset_index(const ::std::string& value);
  inline void set_offset_index(const char* value);
  inline void set_offset_index(const void* value, size_t size);
  inline ::std::string* mutable_offset_index();
  inline ::std::string* release_offset_index();
  inline void set_allocated_offset_index(::std::string* offset_index);

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetCategoryTagListRequest)
 private:
  inline void set_has_category_id();
  inline void clear_has_category_id();
  inline void set_has_tag_size();
  inline void clear_has_tag_size();
  inline void set_has_offset_index();
  inline void clear_has_offset_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 category_id_;
  ::google::protobuf::int32 tag_size_;
  ::std::string* offset_index_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetCategoryTagListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetCategoryTagListResponse : public ::google::protobuf::MessageLite {
 public:
  GetCategoryTagListResponse();
  virtual ~GetCategoryTagListResponse();

  GetCategoryTagListResponse(const GetCategoryTagListResponse& from);

  inline GetCategoryTagListResponse& operator=(const GetCategoryTagListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCategoryTagListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCategoryTagListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCategoryTagListResponse* other);

  // implements Message ----------------------------------------------

  GetCategoryTagListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCategoryTagListResponse& from);
  void MergeFrom(const GetCategoryTagListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.tag.Tag tag = 1;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::weizhu::tag::Tag& tag(int index) const;
  inline ::weizhu::tag::Tag* mutable_tag(int index);
  inline ::weizhu::tag::Tag* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
      mutable_tag();

  // required bool has_more = 2;
  inline bool has_has_more() const;
  inline void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  inline bool has_more() const;
  inline void set_has_more(bool value);

  // required bytes offset_index = 3;
  inline bool has_offset_index() const;
  inline void clear_offset_index();
  static const int kOffsetIndexFieldNumber = 3;
  inline const ::std::string& offset_index() const;
  inline void set_offset_index(const ::std::string& value);
  inline void set_offset_index(const char* value);
  inline void set_offset_index(const void* value, size_t size);
  inline ::std::string* mutable_offset_index();
  inline ::std::string* release_offset_index();
  inline void set_allocated_offset_index(::std::string* offset_index);

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetCategoryTagListResponse)
 private:
  inline void set_has_has_more();
  inline void clear_has_has_more();
  inline void set_has_offset_index();
  inline void clear_has_offset_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag > tag_;
  ::std::string* offset_index_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetCategoryTagListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetUserTagListRequest : public ::google::protobuf::MessageLite {
 public:
  GetUserTagListRequest();
  virtual ~GetUserTagListRequest();

  GetUserTagListRequest(const GetUserTagListRequest& from);

  inline GetUserTagListRequest& operator=(const GetUserTagListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserTagListRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserTagListRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserTagListRequest* other);

  // implements Message ----------------------------------------------

  GetUserTagListRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserTagListRequest& from);
  void MergeFrom(const GetUserTagListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required int32 tag_size = 2;
  inline bool has_tag_size() const;
  inline void clear_tag_size();
  static const int kTagSizeFieldNumber = 2;
  inline ::google::protobuf::int32 tag_size() const;
  inline void set_tag_size(::google::protobuf::int32 value);

  // optional bytes offset_index = 3;
  inline bool has_offset_index() const;
  inline void clear_offset_index();
  static const int kOffsetIndexFieldNumber = 3;
  inline const ::std::string& offset_index() const;
  inline void set_offset_index(const ::std::string& value);
  inline void set_offset_index(const char* value);
  inline void set_offset_index(const void* value, size_t size);
  inline ::std::string* mutable_offset_index();
  inline ::std::string* release_offset_index();
  inline void set_allocated_offset_index(::std::string* offset_index);

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetUserTagListRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_tag_size();
  inline void clear_has_tag_size();
  inline void set_has_offset_index();
  inline void clear_has_offset_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* offset_index_;
  ::google::protobuf::int32 tag_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetUserTagListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetUserTagListResponse : public ::google::protobuf::MessageLite {
 public:
  GetUserTagListResponse();
  virtual ~GetUserTagListResponse();

  GetUserTagListResponse(const GetUserTagListResponse& from);

  inline GetUserTagListResponse& operator=(const GetUserTagListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserTagListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserTagListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserTagListResponse* other);

  // implements Message ----------------------------------------------

  GetUserTagListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserTagListResponse& from);
  void MergeFrom(const GetUserTagListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.tag.Tag tag = 1;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::weizhu::tag::Tag& tag(int index) const;
  inline ::weizhu::tag::Tag* mutable_tag(int index);
  inline ::weizhu::tag::Tag* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
      mutable_tag();

  // required bool has_more = 2;
  inline bool has_has_more() const;
  inline void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  inline bool has_more() const;
  inline void set_has_more(bool value);

  // required bytes offset_index = 3;
  inline bool has_offset_index() const;
  inline void clear_offset_index();
  static const int kOffsetIndexFieldNumber = 3;
  inline const ::std::string& offset_index() const;
  inline void set_offset_index(const ::std::string& value);
  inline void set_offset_index(const char* value);
  inline void set_offset_index(const void* value, size_t size);
  inline ::std::string* mutable_offset_index();
  inline ::std::string* release_offset_index();
  inline void set_allocated_offset_index(::std::string* offset_index);

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetUserTagListResponse)
 private:
  inline void set_has_has_more();
  inline void clear_has_has_more();
  inline void set_has_offset_index();
  inline void clear_has_offset_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag > tag_;
  ::std::string* offset_index_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetUserTagListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetResourceTagListRequest : public ::google::protobuf::MessageLite {
 public:
  GetResourceTagListRequest();
  virtual ~GetResourceTagListRequest();

  GetResourceTagListRequest(const GetResourceTagListRequest& from);

  inline GetResourceTagListRequest& operator=(const GetResourceTagListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetResourceTagListRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetResourceTagListRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetResourceTagListRequest* other);

  // implements Message ----------------------------------------------

  GetResourceTagListRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetResourceTagListRequest& from);
  void MergeFrom(const GetResourceTagListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.tag.Resource resource = 1;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 1;
  inline const ::weizhu::tag::Resource& resource() const;
  inline ::weizhu::tag::Resource* mutable_resource();
  inline ::weizhu::tag::Resource* release_resource();
  inline void set_allocated_resource(::weizhu::tag::Resource* resource);

  // required int32 tag_size = 2;
  inline bool has_tag_size() const;
  inline void clear_tag_size();
  static const int kTagSizeFieldNumber = 2;
  inline ::google::protobuf::int32 tag_size() const;
  inline void set_tag_size(::google::protobuf::int32 value);

  // optional bytes offset_index = 3;
  inline bool has_offset_index() const;
  inline void clear_offset_index();
  static const int kOffsetIndexFieldNumber = 3;
  inline const ::std::string& offset_index() const;
  inline void set_offset_index(const ::std::string& value);
  inline void set_offset_index(const char* value);
  inline void set_offset_index(const void* value, size_t size);
  inline ::std::string* mutable_offset_index();
  inline ::std::string* release_offset_index();
  inline void set_allocated_offset_index(::std::string* offset_index);

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetResourceTagListRequest)
 private:
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_tag_size();
  inline void clear_has_tag_size();
  inline void set_has_offset_index();
  inline void clear_has_offset_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::tag::Resource* resource_;
  ::std::string* offset_index_;
  ::google::protobuf::int32 tag_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetResourceTagListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResourceTagListResponse : public ::google::protobuf::MessageLite {
 public:
  GetResourceTagListResponse();
  virtual ~GetResourceTagListResponse();

  GetResourceTagListResponse(const GetResourceTagListResponse& from);

  inline GetResourceTagListResponse& operator=(const GetResourceTagListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetResourceTagListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetResourceTagListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetResourceTagListResponse* other);

  // implements Message ----------------------------------------------

  GetResourceTagListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetResourceTagListResponse& from);
  void MergeFrom(const GetResourceTagListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.tag.Tag tag = 1;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::weizhu::tag::Tag& tag(int index) const;
  inline ::weizhu::tag::Tag* mutable_tag(int index);
  inline ::weizhu::tag::Tag* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
      mutable_tag();

  // required bool has_more = 2;
  inline bool has_has_more() const;
  inline void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  inline bool has_more() const;
  inline void set_has_more(bool value);

  // required bytes offset_index = 3;
  inline bool has_offset_index() const;
  inline void clear_offset_index();
  static const int kOffsetIndexFieldNumber = 3;
  inline const ::std::string& offset_index() const;
  inline void set_offset_index(const ::std::string& value);
  inline void set_offset_index(const char* value);
  inline void set_offset_index(const void* value, size_t size);
  inline ::std::string* mutable_offset_index();
  inline ::std::string* release_offset_index();
  inline void set_allocated_offset_index(::std::string* offset_index);

  // @@protoc_insertion_point(class_scope:weizhu.tag.GetResourceTagListResponse)
 private:
  inline void set_has_has_more();
  inline void clear_has_has_more();
  inline void set_has_offset_index();
  inline void clear_has_offset_index();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag > tag_;
  ::std::string* offset_index_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static GetResourceTagListResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateSubscribeTagRequest : public ::google::protobuf::MessageLite {
 public:
  CreateSubscribeTagRequest();
  virtual ~CreateSubscribeTagRequest();

  CreateSubscribeTagRequest(const CreateSubscribeTagRequest& from);

  inline CreateSubscribeTagRequest& operator=(const CreateSubscribeTagRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateSubscribeTagRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateSubscribeTagRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateSubscribeTagRequest* other);

  // implements Message ----------------------------------------------

  CreateSubscribeTagRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateSubscribeTagRequest& from);
  void MergeFrom(const CreateSubscribeTagRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 tag_id = 1;
  inline int tag_id_size() const;
  inline void clear_tag_id();
  static const int kTagIdFieldNumber = 1;
  inline ::google::protobuf::int32 tag_id(int index) const;
  inline void set_tag_id(int index, ::google::protobuf::int32 value);
  inline void add_tag_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tag_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tag_id();

  // @@protoc_insertion_point(class_scope:weizhu.tag.CreateSubscribeTagRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tag_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static CreateSubscribeTagRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateSubscribeTagResponse : public ::google::protobuf::MessageLite {
 public:
  CreateSubscribeTagResponse();
  virtual ~CreateSubscribeTagResponse();

  CreateSubscribeTagResponse(const CreateSubscribeTagResponse& from);

  inline CreateSubscribeTagResponse& operator=(const CreateSubscribeTagResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateSubscribeTagResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateSubscribeTagResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateSubscribeTagResponse* other);

  // implements Message ----------------------------------------------

  CreateSubscribeTagResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateSubscribeTagResponse& from);
  void MergeFrom(const CreateSubscribeTagResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CreateSubscribeTagResponse_Result Result;
  static const Result SUCC = CreateSubscribeTagResponse_Result_SUCC;
  static const Result FAIL_UNKNOWN = CreateSubscribeTagResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return CreateSubscribeTagResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CreateSubscribeTagResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CreateSubscribeTagResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CreateSubscribeTagResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.tag.CreateSubscribeTagResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::tag::CreateSubscribeTagResponse_Result result() const;
  inline void set_result(::weizhu::tag::CreateSubscribeTagResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.tag.CreateSubscribeTagResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static CreateSubscribeTagResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteSubscribeTagRequest : public ::google::protobuf::MessageLite {
 public:
  DeleteSubscribeTagRequest();
  virtual ~DeleteSubscribeTagRequest();

  DeleteSubscribeTagRequest(const DeleteSubscribeTagRequest& from);

  inline DeleteSubscribeTagRequest& operator=(const DeleteSubscribeTagRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteSubscribeTagRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteSubscribeTagRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteSubscribeTagRequest* other);

  // implements Message ----------------------------------------------

  DeleteSubscribeTagRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteSubscribeTagRequest& from);
  void MergeFrom(const DeleteSubscribeTagRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 tag_id = 2;
  inline int tag_id_size() const;
  inline void clear_tag_id();
  static const int kTagIdFieldNumber = 2;
  inline ::google::protobuf::int32 tag_id(int index) const;
  inline void set_tag_id(int index, ::google::protobuf::int32 value);
  inline void add_tag_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tag_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tag_id();

  // @@protoc_insertion_point(class_scope:weizhu.tag.DeleteSubscribeTagRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tag_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static DeleteSubscribeTagRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteSubscribeTagResponse : public ::google::protobuf::MessageLite {
 public:
  DeleteSubscribeTagResponse();
  virtual ~DeleteSubscribeTagResponse();

  DeleteSubscribeTagResponse(const DeleteSubscribeTagResponse& from);

  inline DeleteSubscribeTagResponse& operator=(const DeleteSubscribeTagResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteSubscribeTagResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteSubscribeTagResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteSubscribeTagResponse* other);

  // implements Message ----------------------------------------------

  DeleteSubscribeTagResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteSubscribeTagResponse& from);
  void MergeFrom(const DeleteSubscribeTagResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DeleteSubscribeTagResponse_Result Result;
  static const Result SUCC = DeleteSubscribeTagResponse_Result_SUCC;
  static const Result FAIL_UNKNOWN = DeleteSubscribeTagResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return DeleteSubscribeTagResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    DeleteSubscribeTagResponse_Result_Result_MIN;
  static const Result Result_MAX =
    DeleteSubscribeTagResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    DeleteSubscribeTagResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.tag.DeleteSubscribeTagResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::tag::DeleteSubscribeTagResponse_Result result() const;
  inline void set_result(::weizhu::tag::DeleteSubscribeTagResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.tag.DeleteSubscribeTagResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tag_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tag_2eproto();
  #endif
  friend void protobuf_AssignDesc_tag_2eproto();
  friend void protobuf_ShutdownFile_tag_2eproto();

  void InitAsDefaultInstance();
  static DeleteSubscribeTagResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Category

// required int32 category_id = 1;
inline bool Category::has_category_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Category::set_has_category_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Category::clear_has_category_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Category::clear_category_id() {
  category_id_ = 0;
  clear_has_category_id();
}
inline ::google::protobuf::int32 Category::category_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Category.category_id)
  return category_id_;
}
inline void Category::set_category_id(::google::protobuf::int32 value) {
  set_has_category_id();
  category_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Category.category_id)
}

// required string category_name = 2;
inline bool Category::has_category_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Category::set_has_category_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Category::clear_has_category_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Category::clear_category_name() {
  if (category_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_name_->clear();
  }
  clear_has_category_name();
}
inline const ::std::string& Category::category_name() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Category.category_name)
  return *category_name_;
}
inline void Category::set_category_name(const ::std::string& value) {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_name_ = new ::std::string;
  }
  category_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.Category.category_name)
}
inline void Category::set_category_name(const char* value) {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_name_ = new ::std::string;
  }
  category_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.Category.category_name)
}
inline void Category::set_category_name(const char* value, size_t size) {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_name_ = new ::std::string;
  }
  category_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.Category.category_name)
}
inline ::std::string* Category::mutable_category_name() {
  set_has_category_name();
  if (category_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    category_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.Category.category_name)
  return category_name_;
}
inline ::std::string* Category::release_category_name() {
  clear_has_category_name();
  if (category_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = category_name_;
    category_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Category::set_allocated_category_name(::std::string* category_name) {
  if (category_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete category_name_;
  }
  if (category_name) {
    set_has_category_name();
    category_name_ = category_name;
  } else {
    clear_has_category_name();
    category_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.Category.category_name)
}

// optional .weizhu.tag.State state = 95 [default = NORMAL];
inline bool Category::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Category::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Category::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Category::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::weizhu::tag::State Category::state() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Category.state)
  return static_cast< ::weizhu::tag::State >(state_);
}
inline void Category::set_state(::weizhu::tag::State value) {
  assert(::weizhu::tag::State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Category.state)
}

// optional int64 create_admin_id = 96;
inline bool Category::has_create_admin_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Category::set_has_create_admin_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Category::clear_has_create_admin_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Category::clear_create_admin_id() {
  create_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_create_admin_id();
}
inline ::google::protobuf::int64 Category::create_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Category.create_admin_id)
  return create_admin_id_;
}
inline void Category::set_create_admin_id(::google::protobuf::int64 value) {
  set_has_create_admin_id();
  create_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Category.create_admin_id)
}

// optional int32 create_time = 97;
inline bool Category::has_create_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Category::set_has_create_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Category::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Category::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 Category::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Category.create_time)
  return create_time_;
}
inline void Category::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Category.create_time)
}

// optional int64 update_admin_id = 98;
inline bool Category::has_update_admin_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Category::set_has_update_admin_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Category::clear_has_update_admin_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Category::clear_update_admin_id() {
  update_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_update_admin_id();
}
inline ::google::protobuf::int64 Category::update_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Category.update_admin_id)
  return update_admin_id_;
}
inline void Category::set_update_admin_id(::google::protobuf::int64 value) {
  set_has_update_admin_id();
  update_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Category.update_admin_id)
}

// optional int32 update_time = 99;
inline bool Category::has_update_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Category::set_has_update_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Category::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Category::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 Category::update_time() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Category.update_time)
  return update_time_;
}
inline void Category::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Category.update_time)
}

// -------------------------------------------------------------------

// Tag

// required int32 tag_id = 1;
inline bool Tag::has_tag_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tag::set_has_tag_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tag::clear_has_tag_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tag::clear_tag_id() {
  tag_id_ = 0;
  clear_has_tag_id();
}
inline ::google::protobuf::int32 Tag::tag_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.tag_id)
  return tag_id_;
}
inline void Tag::set_tag_id(::google::protobuf::int32 value) {
  set_has_tag_id();
  tag_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.tag_id)
}

// required string tag_name = 2;
inline bool Tag::has_tag_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tag::set_has_tag_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tag::clear_has_tag_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tag::clear_tag_name() {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_->clear();
  }
  clear_has_tag_name();
}
inline const ::std::string& Tag::tag_name() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.tag_name)
  return *tag_name_;
}
inline void Tag::set_tag_name(const ::std::string& value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.tag_name)
}
inline void Tag::set_tag_name(const char* value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.Tag.tag_name)
}
inline void Tag::set_tag_name(const char* value, size_t size) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.Tag.tag_name)
}
inline ::std::string* Tag::mutable_tag_name() {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.Tag.tag_name)
  return tag_name_;
}
inline ::std::string* Tag::release_tag_name() {
  clear_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_name_;
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Tag::set_allocated_tag_name(::std::string* tag_name) {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_name_;
  }
  if (tag_name) {
    set_has_tag_name();
    tag_name_ = tag_name;
  } else {
    clear_has_tag_name();
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.Tag.tag_name)
}

// required bool is_recommend = 3;
inline bool Tag::has_is_recommend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tag::set_has_is_recommend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tag::clear_has_is_recommend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tag::clear_is_recommend() {
  is_recommend_ = false;
  clear_has_is_recommend();
}
inline bool Tag::is_recommend() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.is_recommend)
  return is_recommend_;
}
inline void Tag::set_is_recommend(bool value) {
  set_has_is_recommend();
  is_recommend_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.is_recommend)
}

// repeated int32 category_id = 4;
inline int Tag::category_id_size() const {
  return category_id_.size();
}
inline void Tag::clear_category_id() {
  category_id_.Clear();
}
inline ::google::protobuf::int32 Tag::category_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.category_id)
  return category_id_.Get(index);
}
inline void Tag::set_category_id(int index, ::google::protobuf::int32 value) {
  category_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.category_id)
}
inline void Tag::add_category_id(::google::protobuf::int32 value) {
  category_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.tag.Tag.category_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Tag::category_id() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.Tag.category_id)
  return category_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Tag::mutable_category_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.Tag.category_id)
  return &category_id_;
}

// optional int32 user_count = 21;
inline bool Tag::has_user_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Tag::set_has_user_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Tag::clear_has_user_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Tag::clear_user_count() {
  user_count_ = 0;
  clear_has_user_count();
}
inline ::google::protobuf::int32 Tag::user_count() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.user_count)
  return user_count_;
}
inline void Tag::set_user_count(::google::protobuf::int32 value) {
  set_has_user_count();
  user_count_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.user_count)
}

// optional bool is_subscribe = 22;
inline bool Tag::has_is_subscribe() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Tag::set_has_is_subscribe() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Tag::clear_has_is_subscribe() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Tag::clear_is_subscribe() {
  is_subscribe_ = false;
  clear_has_is_subscribe();
}
inline bool Tag::is_subscribe() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.is_subscribe)
  return is_subscribe_;
}
inline void Tag::set_is_subscribe(bool value) {
  set_has_is_subscribe();
  is_subscribe_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.is_subscribe)
}

// optional int64 create_admin_id = 96;
inline bool Tag::has_create_admin_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Tag::set_has_create_admin_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Tag::clear_has_create_admin_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Tag::clear_create_admin_id() {
  create_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_create_admin_id();
}
inline ::google::protobuf::int64 Tag::create_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.create_admin_id)
  return create_admin_id_;
}
inline void Tag::set_create_admin_id(::google::protobuf::int64 value) {
  set_has_create_admin_id();
  create_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.create_admin_id)
}

// optional int32 create_time = 97;
inline bool Tag::has_create_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Tag::set_has_create_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Tag::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Tag::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 Tag::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.create_time)
  return create_time_;
}
inline void Tag::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.create_time)
}

// optional int64 update_admin_id = 98;
inline bool Tag::has_update_admin_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Tag::set_has_update_admin_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Tag::clear_has_update_admin_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Tag::clear_update_admin_id() {
  update_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_update_admin_id();
}
inline ::google::protobuf::int64 Tag::update_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.update_admin_id)
  return update_admin_id_;
}
inline void Tag::set_update_admin_id(::google::protobuf::int64 value) {
  set_has_update_admin_id();
  update_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.update_admin_id)
}

// optional int32 update_time = 99;
inline bool Tag::has_update_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Tag::set_has_update_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Tag::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Tag::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 Tag::update_time() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Tag.update_time)
  return update_time_;
}
inline void Tag::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.Tag.update_time)
}

// -------------------------------------------------------------------

// Resource

// required string resource_type = 1;
inline bool Resource::has_resource_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_resource_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_resource_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_resource_type() {
  if (resource_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_type_->clear();
  }
  clear_has_resource_type();
}
inline const ::std::string& Resource::resource_type() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Resource.resource_type)
  return *resource_type_;
}
inline void Resource::set_resource_type(const ::std::string& value) {
  set_has_resource_type();
  if (resource_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_type_ = new ::std::string;
  }
  resource_type_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.Resource.resource_type)
}
inline void Resource::set_resource_type(const char* value) {
  set_has_resource_type();
  if (resource_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_type_ = new ::std::string;
  }
  resource_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.Resource.resource_type)
}
inline void Resource::set_resource_type(const char* value, size_t size) {
  set_has_resource_type();
  if (resource_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_type_ = new ::std::string;
  }
  resource_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.Resource.resource_type)
}
inline ::std::string* Resource::mutable_resource_type() {
  set_has_resource_type();
  if (resource_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.Resource.resource_type)
  return resource_type_;
}
inline ::std::string* Resource::release_resource_type() {
  clear_has_resource_type();
  if (resource_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resource_type_;
    resource_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource::set_allocated_resource_type(::std::string* resource_type) {
  if (resource_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resource_type_;
  }
  if (resource_type) {
    set_has_resource_type();
    resource_type_ = resource_type;
  } else {
    clear_has_resource_type();
    resource_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.Resource.resource_type)
}

// required string resource_id = 2;
inline bool Resource::has_resource_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_resource_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_resource_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_resource_id() {
  if (resource_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_id_->clear();
  }
  clear_has_resource_id();
}
inline const ::std::string& Resource::resource_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.Resource.resource_id)
  return *resource_id_;
}
inline void Resource::set_resource_id(const ::std::string& value) {
  set_has_resource_id();
  if (resource_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_id_ = new ::std::string;
  }
  resource_id_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.Resource.resource_id)
}
inline void Resource::set_resource_id(const char* value) {
  set_has_resource_id();
  if (resource_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_id_ = new ::std::string;
  }
  resource_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.Resource.resource_id)
}
inline void Resource::set_resource_id(const char* value, size_t size) {
  set_has_resource_id();
  if (resource_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_id_ = new ::std::string;
  }
  resource_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.Resource.resource_id)
}
inline ::std::string* Resource::mutable_resource_id() {
  set_has_resource_id();
  if (resource_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resource_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.Resource.resource_id)
  return resource_id_;
}
inline ::std::string* Resource::release_resource_id() {
  clear_has_resource_id();
  if (resource_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resource_id_;
    resource_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Resource::set_allocated_resource_id(::std::string* resource_id) {
  if (resource_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resource_id_;
  }
  if (resource_id) {
    set_has_resource_id();
    resource_id_ = resource_id;
  } else {
    clear_has_resource_id();
    resource_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.Resource.resource_id)
}

// -------------------------------------------------------------------

// GetRecommendTagResponse

// repeated .weizhu.tag.Tag recommend_tag = 1;
inline int GetRecommendTagResponse::recommend_tag_size() const {
  return recommend_tag_.size();
}
inline void GetRecommendTagResponse::clear_recommend_tag() {
  recommend_tag_.Clear();
}
inline const ::weizhu::tag::Tag& GetRecommendTagResponse::recommend_tag(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetRecommendTagResponse.recommend_tag)
  return recommend_tag_.Get(index);
}
inline ::weizhu::tag::Tag* GetRecommendTagResponse::mutable_recommend_tag(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetRecommendTagResponse.recommend_tag)
  return recommend_tag_.Mutable(index);
}
inline ::weizhu::tag::Tag* GetRecommendTagResponse::add_recommend_tag() {
  // @@protoc_insertion_point(field_add:weizhu.tag.GetRecommendTagResponse.recommend_tag)
  return recommend_tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
GetRecommendTagResponse::recommend_tag() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.GetRecommendTagResponse.recommend_tag)
  return recommend_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
GetRecommendTagResponse::mutable_recommend_tag() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.GetRecommendTagResponse.recommend_tag)
  return &recommend_tag_;
}

// -------------------------------------------------------------------

// GetCategoryResponse

// repeated .weizhu.tag.Category category = 1;
inline int GetCategoryResponse::category_size() const {
  return category_.size();
}
inline void GetCategoryResponse::clear_category() {
  category_.Clear();
}
inline const ::weizhu::tag::Category& GetCategoryResponse::category(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetCategoryResponse.category)
  return category_.Get(index);
}
inline ::weizhu::tag::Category* GetCategoryResponse::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetCategoryResponse.category)
  return category_.Mutable(index);
}
inline ::weizhu::tag::Category* GetCategoryResponse::add_category() {
  // @@protoc_insertion_point(field_add:weizhu.tag.GetCategoryResponse.category)
  return category_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Category >&
GetCategoryResponse::category() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.GetCategoryResponse.category)
  return category_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Category >*
GetCategoryResponse::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.GetCategoryResponse.category)
  return &category_;
}

// -------------------------------------------------------------------

// GetCategoryTagListRequest

// required int32 category_id = 1;
inline bool GetCategoryTagListRequest::has_category_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCategoryTagListRequest::set_has_category_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCategoryTagListRequest::clear_has_category_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCategoryTagListRequest::clear_category_id() {
  category_id_ = 0;
  clear_has_category_id();
}
inline ::google::protobuf::int32 GetCategoryTagListRequest::category_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetCategoryTagListRequest.category_id)
  return category_id_;
}
inline void GetCategoryTagListRequest::set_category_id(::google::protobuf::int32 value) {
  set_has_category_id();
  category_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetCategoryTagListRequest.category_id)
}

// required int32 tag_size = 2;
inline bool GetCategoryTagListRequest::has_tag_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCategoryTagListRequest::set_has_tag_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCategoryTagListRequest::clear_has_tag_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCategoryTagListRequest::clear_tag_size() {
  tag_size_ = 0;
  clear_has_tag_size();
}
inline ::google::protobuf::int32 GetCategoryTagListRequest::tag_size() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetCategoryTagListRequest.tag_size)
  return tag_size_;
}
inline void GetCategoryTagListRequest::set_tag_size(::google::protobuf::int32 value) {
  set_has_tag_size();
  tag_size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetCategoryTagListRequest.tag_size)
}

// optional bytes offset_index = 3;
inline bool GetCategoryTagListRequest::has_offset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCategoryTagListRequest::set_has_offset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCategoryTagListRequest::clear_has_offset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCategoryTagListRequest::clear_offset_index() {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_->clear();
  }
  clear_has_offset_index();
}
inline const ::std::string& GetCategoryTagListRequest::offset_index() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetCategoryTagListRequest.offset_index)
  return *offset_index_;
}
inline void GetCategoryTagListRequest::set_offset_index(const ::std::string& value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.GetCategoryTagListRequest.offset_index)
}
inline void GetCategoryTagListRequest::set_offset_index(const char* value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.GetCategoryTagListRequest.offset_index)
}
inline void GetCategoryTagListRequest::set_offset_index(const void* value, size_t size) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.GetCategoryTagListRequest.offset_index)
}
inline ::std::string* GetCategoryTagListRequest::mutable_offset_index() {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetCategoryTagListRequest.offset_index)
  return offset_index_;
}
inline ::std::string* GetCategoryTagListRequest::release_offset_index() {
  clear_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = offset_index_;
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCategoryTagListRequest::set_allocated_offset_index(::std::string* offset_index) {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete offset_index_;
  }
  if (offset_index) {
    set_has_offset_index();
    offset_index_ = offset_index;
  } else {
    clear_has_offset_index();
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.GetCategoryTagListRequest.offset_index)
}

// -------------------------------------------------------------------

// GetCategoryTagListResponse

// repeated .weizhu.tag.Tag tag = 1;
inline int GetCategoryTagListResponse::tag_size() const {
  return tag_.size();
}
inline void GetCategoryTagListResponse::clear_tag() {
  tag_.Clear();
}
inline const ::weizhu::tag::Tag& GetCategoryTagListResponse::tag(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetCategoryTagListResponse.tag)
  return tag_.Get(index);
}
inline ::weizhu::tag::Tag* GetCategoryTagListResponse::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetCategoryTagListResponse.tag)
  return tag_.Mutable(index);
}
inline ::weizhu::tag::Tag* GetCategoryTagListResponse::add_tag() {
  // @@protoc_insertion_point(field_add:weizhu.tag.GetCategoryTagListResponse.tag)
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
GetCategoryTagListResponse::tag() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.GetCategoryTagListResponse.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
GetCategoryTagListResponse::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.GetCategoryTagListResponse.tag)
  return &tag_;
}

// required bool has_more = 2;
inline bool GetCategoryTagListResponse::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCategoryTagListResponse::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCategoryTagListResponse::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCategoryTagListResponse::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool GetCategoryTagListResponse::has_more() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetCategoryTagListResponse.has_more)
  return has_more_;
}
inline void GetCategoryTagListResponse::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetCategoryTagListResponse.has_more)
}

// required bytes offset_index = 3;
inline bool GetCategoryTagListResponse::has_offset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCategoryTagListResponse::set_has_offset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCategoryTagListResponse::clear_has_offset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCategoryTagListResponse::clear_offset_index() {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_->clear();
  }
  clear_has_offset_index();
}
inline const ::std::string& GetCategoryTagListResponse::offset_index() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetCategoryTagListResponse.offset_index)
  return *offset_index_;
}
inline void GetCategoryTagListResponse::set_offset_index(const ::std::string& value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.GetCategoryTagListResponse.offset_index)
}
inline void GetCategoryTagListResponse::set_offset_index(const char* value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.GetCategoryTagListResponse.offset_index)
}
inline void GetCategoryTagListResponse::set_offset_index(const void* value, size_t size) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.GetCategoryTagListResponse.offset_index)
}
inline ::std::string* GetCategoryTagListResponse::mutable_offset_index() {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetCategoryTagListResponse.offset_index)
  return offset_index_;
}
inline ::std::string* GetCategoryTagListResponse::release_offset_index() {
  clear_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = offset_index_;
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCategoryTagListResponse::set_allocated_offset_index(::std::string* offset_index) {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete offset_index_;
  }
  if (offset_index) {
    set_has_offset_index();
    offset_index_ = offset_index;
  } else {
    clear_has_offset_index();
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.GetCategoryTagListResponse.offset_index)
}

// -------------------------------------------------------------------

// GetUserTagListRequest

// required int64 user_id = 1;
inline bool GetUserTagListRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserTagListRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserTagListRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserTagListRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 GetUserTagListRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetUserTagListRequest.user_id)
  return user_id_;
}
inline void GetUserTagListRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetUserTagListRequest.user_id)
}

// required int32 tag_size = 2;
inline bool GetUserTagListRequest::has_tag_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserTagListRequest::set_has_tag_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserTagListRequest::clear_has_tag_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserTagListRequest::clear_tag_size() {
  tag_size_ = 0;
  clear_has_tag_size();
}
inline ::google::protobuf::int32 GetUserTagListRequest::tag_size() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetUserTagListRequest.tag_size)
  return tag_size_;
}
inline void GetUserTagListRequest::set_tag_size(::google::protobuf::int32 value) {
  set_has_tag_size();
  tag_size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetUserTagListRequest.tag_size)
}

// optional bytes offset_index = 3;
inline bool GetUserTagListRequest::has_offset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserTagListRequest::set_has_offset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserTagListRequest::clear_has_offset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserTagListRequest::clear_offset_index() {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_->clear();
  }
  clear_has_offset_index();
}
inline const ::std::string& GetUserTagListRequest::offset_index() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetUserTagListRequest.offset_index)
  return *offset_index_;
}
inline void GetUserTagListRequest::set_offset_index(const ::std::string& value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.GetUserTagListRequest.offset_index)
}
inline void GetUserTagListRequest::set_offset_index(const char* value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.GetUserTagListRequest.offset_index)
}
inline void GetUserTagListRequest::set_offset_index(const void* value, size_t size) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.GetUserTagListRequest.offset_index)
}
inline ::std::string* GetUserTagListRequest::mutable_offset_index() {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetUserTagListRequest.offset_index)
  return offset_index_;
}
inline ::std::string* GetUserTagListRequest::release_offset_index() {
  clear_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = offset_index_;
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetUserTagListRequest::set_allocated_offset_index(::std::string* offset_index) {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete offset_index_;
  }
  if (offset_index) {
    set_has_offset_index();
    offset_index_ = offset_index;
  } else {
    clear_has_offset_index();
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.GetUserTagListRequest.offset_index)
}

// -------------------------------------------------------------------

// GetUserTagListResponse

// repeated .weizhu.tag.Tag tag = 1;
inline int GetUserTagListResponse::tag_size() const {
  return tag_.size();
}
inline void GetUserTagListResponse::clear_tag() {
  tag_.Clear();
}
inline const ::weizhu::tag::Tag& GetUserTagListResponse::tag(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetUserTagListResponse.tag)
  return tag_.Get(index);
}
inline ::weizhu::tag::Tag* GetUserTagListResponse::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetUserTagListResponse.tag)
  return tag_.Mutable(index);
}
inline ::weizhu::tag::Tag* GetUserTagListResponse::add_tag() {
  // @@protoc_insertion_point(field_add:weizhu.tag.GetUserTagListResponse.tag)
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
GetUserTagListResponse::tag() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.GetUserTagListResponse.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
GetUserTagListResponse::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.GetUserTagListResponse.tag)
  return &tag_;
}

// required bool has_more = 2;
inline bool GetUserTagListResponse::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserTagListResponse::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserTagListResponse::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserTagListResponse::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool GetUserTagListResponse::has_more() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetUserTagListResponse.has_more)
  return has_more_;
}
inline void GetUserTagListResponse::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetUserTagListResponse.has_more)
}

// required bytes offset_index = 3;
inline bool GetUserTagListResponse::has_offset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserTagListResponse::set_has_offset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserTagListResponse::clear_has_offset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserTagListResponse::clear_offset_index() {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_->clear();
  }
  clear_has_offset_index();
}
inline const ::std::string& GetUserTagListResponse::offset_index() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetUserTagListResponse.offset_index)
  return *offset_index_;
}
inline void GetUserTagListResponse::set_offset_index(const ::std::string& value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.GetUserTagListResponse.offset_index)
}
inline void GetUserTagListResponse::set_offset_index(const char* value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.GetUserTagListResponse.offset_index)
}
inline void GetUserTagListResponse::set_offset_index(const void* value, size_t size) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.GetUserTagListResponse.offset_index)
}
inline ::std::string* GetUserTagListResponse::mutable_offset_index() {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetUserTagListResponse.offset_index)
  return offset_index_;
}
inline ::std::string* GetUserTagListResponse::release_offset_index() {
  clear_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = offset_index_;
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetUserTagListResponse::set_allocated_offset_index(::std::string* offset_index) {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete offset_index_;
  }
  if (offset_index) {
    set_has_offset_index();
    offset_index_ = offset_index;
  } else {
    clear_has_offset_index();
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.GetUserTagListResponse.offset_index)
}

// -------------------------------------------------------------------

// GetResourceTagListRequest

// required .weizhu.tag.Resource resource = 1;
inline bool GetResourceTagListRequest::has_resource() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResourceTagListRequest::set_has_resource() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetResourceTagListRequest::clear_has_resource() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetResourceTagListRequest::clear_resource() {
  if (resource_ != NULL) resource_->::weizhu::tag::Resource::Clear();
  clear_has_resource();
}
inline const ::weizhu::tag::Resource& GetResourceTagListRequest::resource() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetResourceTagListRequest.resource)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resource_ != NULL ? *resource_ : *default_instance().resource_;
#else
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
#endif
}
inline ::weizhu::tag::Resource* GetResourceTagListRequest::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::weizhu::tag::Resource;
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetResourceTagListRequest.resource)
  return resource_;
}
inline ::weizhu::tag::Resource* GetResourceTagListRequest::release_resource() {
  clear_has_resource();
  ::weizhu::tag::Resource* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline void GetResourceTagListRequest::set_allocated_resource(::weizhu::tag::Resource* resource) {
  delete resource_;
  resource_ = resource;
  if (resource) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.GetResourceTagListRequest.resource)
}

// required int32 tag_size = 2;
inline bool GetResourceTagListRequest::has_tag_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetResourceTagListRequest::set_has_tag_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetResourceTagListRequest::clear_has_tag_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetResourceTagListRequest::clear_tag_size() {
  tag_size_ = 0;
  clear_has_tag_size();
}
inline ::google::protobuf::int32 GetResourceTagListRequest::tag_size() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetResourceTagListRequest.tag_size)
  return tag_size_;
}
inline void GetResourceTagListRequest::set_tag_size(::google::protobuf::int32 value) {
  set_has_tag_size();
  tag_size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetResourceTagListRequest.tag_size)
}

// optional bytes offset_index = 3;
inline bool GetResourceTagListRequest::has_offset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetResourceTagListRequest::set_has_offset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetResourceTagListRequest::clear_has_offset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetResourceTagListRequest::clear_offset_index() {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_->clear();
  }
  clear_has_offset_index();
}
inline const ::std::string& GetResourceTagListRequest::offset_index() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetResourceTagListRequest.offset_index)
  return *offset_index_;
}
inline void GetResourceTagListRequest::set_offset_index(const ::std::string& value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.GetResourceTagListRequest.offset_index)
}
inline void GetResourceTagListRequest::set_offset_index(const char* value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.GetResourceTagListRequest.offset_index)
}
inline void GetResourceTagListRequest::set_offset_index(const void* value, size_t size) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.GetResourceTagListRequest.offset_index)
}
inline ::std::string* GetResourceTagListRequest::mutable_offset_index() {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetResourceTagListRequest.offset_index)
  return offset_index_;
}
inline ::std::string* GetResourceTagListRequest::release_offset_index() {
  clear_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = offset_index_;
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetResourceTagListRequest::set_allocated_offset_index(::std::string* offset_index) {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete offset_index_;
  }
  if (offset_index) {
    set_has_offset_index();
    offset_index_ = offset_index;
  } else {
    clear_has_offset_index();
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.GetResourceTagListRequest.offset_index)
}

// -------------------------------------------------------------------

// GetResourceTagListResponse

// repeated .weizhu.tag.Tag tag = 1;
inline int GetResourceTagListResponse::tag_size() const {
  return tag_.size();
}
inline void GetResourceTagListResponse::clear_tag() {
  tag_.Clear();
}
inline const ::weizhu::tag::Tag& GetResourceTagListResponse::tag(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetResourceTagListResponse.tag)
  return tag_.Get(index);
}
inline ::weizhu::tag::Tag* GetResourceTagListResponse::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetResourceTagListResponse.tag)
  return tag_.Mutable(index);
}
inline ::weizhu::tag::Tag* GetResourceTagListResponse::add_tag() {
  // @@protoc_insertion_point(field_add:weizhu.tag.GetResourceTagListResponse.tag)
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >&
GetResourceTagListResponse::tag() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.GetResourceTagListResponse.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::tag::Tag >*
GetResourceTagListResponse::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.GetResourceTagListResponse.tag)
  return &tag_;
}

// required bool has_more = 2;
inline bool GetResourceTagListResponse::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetResourceTagListResponse::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetResourceTagListResponse::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetResourceTagListResponse::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool GetResourceTagListResponse::has_more() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetResourceTagListResponse.has_more)
  return has_more_;
}
inline void GetResourceTagListResponse::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.GetResourceTagListResponse.has_more)
}

// required bytes offset_index = 3;
inline bool GetResourceTagListResponse::has_offset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetResourceTagListResponse::set_has_offset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetResourceTagListResponse::clear_has_offset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetResourceTagListResponse::clear_offset_index() {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_->clear();
  }
  clear_has_offset_index();
}
inline const ::std::string& GetResourceTagListResponse::offset_index() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.GetResourceTagListResponse.offset_index)
  return *offset_index_;
}
inline void GetResourceTagListResponse::set_offset_index(const ::std::string& value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.GetResourceTagListResponse.offset_index)
}
inline void GetResourceTagListResponse::set_offset_index(const char* value) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.GetResourceTagListResponse.offset_index)
}
inline void GetResourceTagListResponse::set_offset_index(const void* value, size_t size) {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  offset_index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.GetResourceTagListResponse.offset_index)
}
inline ::std::string* GetResourceTagListResponse::mutable_offset_index() {
  set_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    offset_index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.GetResourceTagListResponse.offset_index)
  return offset_index_;
}
inline ::std::string* GetResourceTagListResponse::release_offset_index() {
  clear_has_offset_index();
  if (offset_index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = offset_index_;
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetResourceTagListResponse::set_allocated_offset_index(::std::string* offset_index) {
  if (offset_index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete offset_index_;
  }
  if (offset_index) {
    set_has_offset_index();
    offset_index_ = offset_index;
  } else {
    clear_has_offset_index();
    offset_index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.GetResourceTagListResponse.offset_index)
}

// -------------------------------------------------------------------

// CreateSubscribeTagRequest

// repeated int32 tag_id = 1;
inline int CreateSubscribeTagRequest::tag_id_size() const {
  return tag_id_.size();
}
inline void CreateSubscribeTagRequest::clear_tag_id() {
  tag_id_.Clear();
}
inline ::google::protobuf::int32 CreateSubscribeTagRequest::tag_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.CreateSubscribeTagRequest.tag_id)
  return tag_id_.Get(index);
}
inline void CreateSubscribeTagRequest::set_tag_id(int index, ::google::protobuf::int32 value) {
  tag_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.tag.CreateSubscribeTagRequest.tag_id)
}
inline void CreateSubscribeTagRequest::add_tag_id(::google::protobuf::int32 value) {
  tag_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.tag.CreateSubscribeTagRequest.tag_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CreateSubscribeTagRequest::tag_id() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.CreateSubscribeTagRequest.tag_id)
  return tag_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CreateSubscribeTagRequest::mutable_tag_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.CreateSubscribeTagRequest.tag_id)
  return &tag_id_;
}

// -------------------------------------------------------------------

// CreateSubscribeTagResponse

// optional .weizhu.tag.CreateSubscribeTagResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool CreateSubscribeTagResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSubscribeTagResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSubscribeTagResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSubscribeTagResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::tag::CreateSubscribeTagResponse_Result CreateSubscribeTagResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.CreateSubscribeTagResponse.result)
  return static_cast< ::weizhu::tag::CreateSubscribeTagResponse_Result >(result_);
}
inline void CreateSubscribeTagResponse::set_result(::weizhu::tag::CreateSubscribeTagResponse_Result value) {
  assert(::weizhu::tag::CreateSubscribeTagResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.CreateSubscribeTagResponse.result)
}

// optional string fail_text = 2;
inline bool CreateSubscribeTagResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSubscribeTagResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSubscribeTagResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSubscribeTagResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& CreateSubscribeTagResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.CreateSubscribeTagResponse.fail_text)
  return *fail_text_;
}
inline void CreateSubscribeTagResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.CreateSubscribeTagResponse.fail_text)
}
inline void CreateSubscribeTagResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.CreateSubscribeTagResponse.fail_text)
}
inline void CreateSubscribeTagResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.CreateSubscribeTagResponse.fail_text)
}
inline ::std::string* CreateSubscribeTagResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.CreateSubscribeTagResponse.fail_text)
  return fail_text_;
}
inline ::std::string* CreateSubscribeTagResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateSubscribeTagResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.CreateSubscribeTagResponse.fail_text)
}

// -------------------------------------------------------------------

// DeleteSubscribeTagRequest

// repeated int32 tag_id = 2;
inline int DeleteSubscribeTagRequest::tag_id_size() const {
  return tag_id_.size();
}
inline void DeleteSubscribeTagRequest::clear_tag_id() {
  tag_id_.Clear();
}
inline ::google::protobuf::int32 DeleteSubscribeTagRequest::tag_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.tag.DeleteSubscribeTagRequest.tag_id)
  return tag_id_.Get(index);
}
inline void DeleteSubscribeTagRequest::set_tag_id(int index, ::google::protobuf::int32 value) {
  tag_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.tag.DeleteSubscribeTagRequest.tag_id)
}
inline void DeleteSubscribeTagRequest::add_tag_id(::google::protobuf::int32 value) {
  tag_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.tag.DeleteSubscribeTagRequest.tag_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DeleteSubscribeTagRequest::tag_id() const {
  // @@protoc_insertion_point(field_list:weizhu.tag.DeleteSubscribeTagRequest.tag_id)
  return tag_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DeleteSubscribeTagRequest::mutable_tag_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.tag.DeleteSubscribeTagRequest.tag_id)
  return &tag_id_;
}

// -------------------------------------------------------------------

// DeleteSubscribeTagResponse

// optional .weizhu.tag.DeleteSubscribeTagResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool DeleteSubscribeTagResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteSubscribeTagResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteSubscribeTagResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteSubscribeTagResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::tag::DeleteSubscribeTagResponse_Result DeleteSubscribeTagResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.DeleteSubscribeTagResponse.result)
  return static_cast< ::weizhu::tag::DeleteSubscribeTagResponse_Result >(result_);
}
inline void DeleteSubscribeTagResponse::set_result(::weizhu::tag::DeleteSubscribeTagResponse_Result value) {
  assert(::weizhu::tag::DeleteSubscribeTagResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.tag.DeleteSubscribeTagResponse.result)
}

// optional string fail_text = 2;
inline bool DeleteSubscribeTagResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteSubscribeTagResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteSubscribeTagResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteSubscribeTagResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& DeleteSubscribeTagResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.tag.DeleteSubscribeTagResponse.fail_text)
  return *fail_text_;
}
inline void DeleteSubscribeTagResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.tag.DeleteSubscribeTagResponse.fail_text)
}
inline void DeleteSubscribeTagResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.tag.DeleteSubscribeTagResponse.fail_text)
}
inline void DeleteSubscribeTagResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.tag.DeleteSubscribeTagResponse.fail_text)
}
inline ::std::string* DeleteSubscribeTagResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.tag.DeleteSubscribeTagResponse.fail_text)
  return fail_text_;
}
inline ::std::string* DeleteSubscribeTagResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteSubscribeTagResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.tag.DeleteSubscribeTagResponse.fail_text)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tag
}  // namespace weizhu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tag_2eproto__INCLUDED
