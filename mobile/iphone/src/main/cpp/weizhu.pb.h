// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: weizhu.proto

#ifndef PROTOBUF_weizhu_2eproto__INCLUDED
#define PROTOBUF_weizhu_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace weizhu {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_weizhu_2eproto();
void protobuf_AssignDesc_weizhu_2eproto();
void protobuf_ShutdownFile_weizhu_2eproto();

class Invoke;
class Session;
class Network;
class Weizhu;
class Android;
class Iphone;
class WebMobile;
class HttpApiRequest;
class HttpApiResponse;
class SocketEstablishRequest;
class SocketEstablishResponse;
class SocketApiRequest;
class SocketApiResponse;
class PushMessage;
class SocketPushMsg;
class SocketPushAck;
class SocketPing;
class SocketPong;
class SocketUpPacket;
class SocketDownPacket;
class SystemHead;
class RequestHead;
class AnonymousHead;
class EmptyRequest;
class EmptyResponse;
class TestPush;

enum Network_Type {
  Network_Type_UNKNOWN = 0,
  Network_Type_WIFI = 1
};
bool Network_Type_IsValid(int value);
const Network_Type Network_Type_Type_MIN = Network_Type_UNKNOWN;
const Network_Type Network_Type_Type_MAX = Network_Type_WIFI;
const int Network_Type_Type_ARRAYSIZE = Network_Type_Type_MAX + 1;

enum Network_Protocol {
  Network_Protocol_HTTP_PB = 0,
  Network_Protocol_SOCKET_PB = 1,
  Network_Protocol_WEB_MOBILE = 2
};
bool Network_Protocol_IsValid(int value);
const Network_Protocol Network_Protocol_Protocol_MIN = Network_Protocol_HTTP_PB;
const Network_Protocol Network_Protocol_Protocol_MAX = Network_Protocol_WEB_MOBILE;
const int Network_Protocol_Protocol_ARRAYSIZE = Network_Protocol_Protocol_MAX + 1;

enum Weizhu_Platform {
  Weizhu_Platform_ANDROID = 0,
  Weizhu_Platform_IPHONE = 1
};
bool Weizhu_Platform_IsValid(int value);
const Weizhu_Platform Weizhu_Platform_Platform_MIN = Weizhu_Platform_ANDROID;
const Weizhu_Platform Weizhu_Platform_Platform_MAX = Weizhu_Platform_IPHONE;
const int Weizhu_Platform_Platform_ARRAYSIZE = Weizhu_Platform_Platform_MAX + 1;

enum Weizhu_Stage {
  Weizhu_Stage_RELEASE = 0,
  Weizhu_Stage_BETA = 1,
  Weizhu_Stage_ALPHA = 2
};
bool Weizhu_Stage_IsValid(int value);
const Weizhu_Stage Weizhu_Stage_Stage_MIN = Weizhu_Stage_RELEASE;
const Weizhu_Stage Weizhu_Stage_Stage_MAX = Weizhu_Stage_ALPHA;
const int Weizhu_Stage_Stage_ARRAYSIZE = Weizhu_Stage_Stage_MAX + 1;

enum HttpApiResponse_Result {
  HttpApiResponse_Result_SUCC = 0,
  HttpApiResponse_Result_FAIL_SESSION_DECRYPTION = 1,
  HttpApiResponse_Result_FAIL_SESSION_EXPIRED = 2,
  HttpApiResponse_Result_FAIL_INVOKE_UNKNOWN = 3,
  HttpApiResponse_Result_FAIL_BODY_DECRYPTION = 4,
  HttpApiResponse_Result_FAIL_BODY_PARSE_FAIL = 5,
  HttpApiResponse_Result_FAIL_USER_DISABLE = 6,
  HttpApiResponse_Result_FAIL_SERVER_EXCEPTION = 99
};
bool HttpApiResponse_Result_IsValid(int value);
const HttpApiResponse_Result HttpApiResponse_Result_Result_MIN = HttpApiResponse_Result_SUCC;
const HttpApiResponse_Result HttpApiResponse_Result_Result_MAX = HttpApiResponse_Result_FAIL_SERVER_EXCEPTION;
const int HttpApiResponse_Result_Result_ARRAYSIZE = HttpApiResponse_Result_Result_MAX + 1;

enum SocketEstablishResponse_Result {
  SocketEstablishResponse_Result_SUCC = 0,
  SocketEstablishResponse_Result_FAIL_SESSION_DECRYPTION = 1,
  SocketEstablishResponse_Result_FAIL_SESSION_EXPIRED = 2,
  SocketEstablishResponse_Result_FAIL_USER_DISABLE = 3,
  SocketEstablishResponse_Result_FAIL_SERVER_EXCEPTION = 99
};
bool SocketEstablishResponse_Result_IsValid(int value);
const SocketEstablishResponse_Result SocketEstablishResponse_Result_Result_MIN = SocketEstablishResponse_Result_SUCC;
const SocketEstablishResponse_Result SocketEstablishResponse_Result_Result_MAX = SocketEstablishResponse_Result_FAIL_SERVER_EXCEPTION;
const int SocketEstablishResponse_Result_Result_ARRAYSIZE = SocketEstablishResponse_Result_Result_MAX + 1;

enum SocketApiResponse_Result {
  SocketApiResponse_Result_SUCC = 0,
  SocketApiResponse_Result_FAIL_ESTABLISH_INVALID = 1,
  SocketApiResponse_Result_FAIL_INVOKE_UNKNOWN = 2,
  SocketApiResponse_Result_FAIL_BODY_DECRYPTION = 3,
  SocketApiResponse_Result_FAIL_BODY_PARSE_FAIL = 4,
  SocketApiResponse_Result_FAIL_SERVER_EXCEPTION = 99
};
bool SocketApiResponse_Result_IsValid(int value);
const SocketApiResponse_Result SocketApiResponse_Result_Result_MIN = SocketApiResponse_Result_SUCC;
const SocketApiResponse_Result SocketApiResponse_Result_Result_MAX = SocketApiResponse_Result_FAIL_SERVER_EXCEPTION;
const int SocketApiResponse_Result_Result_ARRAYSIZE = SocketApiResponse_Result_Result_MAX + 1;

// ===================================================================

class Invoke : public ::google::protobuf::MessageLite {
 public:
  Invoke();
  virtual ~Invoke();

  Invoke(const Invoke& from);

  inline Invoke& operator=(const Invoke& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Invoke& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Invoke* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Invoke* other);

  // implements Message ----------------------------------------------

  Invoke* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Invoke& from);
  void MergeFrom(const Invoke& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 invoke_id = 1;
  inline bool has_invoke_id() const;
  inline void clear_invoke_id();
  static const int kInvokeIdFieldNumber = 1;
  inline ::google::protobuf::int32 invoke_id() const;
  inline void set_invoke_id(::google::protobuf::int32 value);

  // required string service_name = 2;
  inline bool has_service_name() const;
  inline void clear_service_name();
  static const int kServiceNameFieldNumber = 2;
  inline const ::std::string& service_name() const;
  inline void set_service_name(const ::std::string& value);
  inline void set_service_name(const char* value);
  inline void set_service_name(const char* value, size_t size);
  inline ::std::string* mutable_service_name();
  inline ::std::string* release_service_name();
  inline void set_allocated_service_name(::std::string* service_name);

  // required string function_name = 3;
  inline bool has_function_name() const;
  inline void clear_function_name();
  static const int kFunctionNameFieldNumber = 3;
  inline const ::std::string& function_name() const;
  inline void set_function_name(const ::std::string& value);
  inline void set_function_name(const char* value);
  inline void set_function_name(const char* value, size_t size);
  inline ::std::string* mutable_function_name();
  inline ::std::string* release_function_name();
  inline void set_allocated_function_name(::std::string* function_name);

  // @@protoc_insertion_point(class_scope:weizhu.Invoke)
 private:
  inline void set_has_invoke_id();
  inline void clear_has_invoke_id();
  inline void set_has_service_name();
  inline void clear_has_service_name();
  inline void set_has_function_name();
  inline void clear_has_function_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_name_;
  ::std::string* function_name_;
  ::google::protobuf::int32 invoke_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static Invoke* default_instance_;
};
// -------------------------------------------------------------------

class Session : public ::google::protobuf::MessageLite {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Session& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Session* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Session* other);

  // implements Message ----------------------------------------------

  Session* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // required int64 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required int64 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::int64 session_id() const;
  inline void set_session_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.Session)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 company_id_;
  ::google::protobuf::int64 user_id_;
  ::google::protobuf::int64 session_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static Session* default_instance_;
};
// -------------------------------------------------------------------

class Network : public ::google::protobuf::MessageLite {
 public:
  Network();
  virtual ~Network();

  Network(const Network& from);

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Network& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Network* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Network* other);

  // implements Message ----------------------------------------------

  Network* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Network_Type Type;
  static const Type UNKNOWN = Network_Type_UNKNOWN;
  static const Type WIFI = Network_Type_WIFI;
  static inline bool Type_IsValid(int value) {
    return Network_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Network_Type_Type_MIN;
  static const Type Type_MAX =
    Network_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Network_Type_Type_ARRAYSIZE;

  typedef Network_Protocol Protocol;
  static const Protocol HTTP_PB = Network_Protocol_HTTP_PB;
  static const Protocol SOCKET_PB = Network_Protocol_SOCKET_PB;
  static const Protocol WEB_MOBILE = Network_Protocol_WEB_MOBILE;
  static inline bool Protocol_IsValid(int value) {
    return Network_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    Network_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    Network_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    Network_Protocol_Protocol_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .weizhu.Network.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::weizhu::Network_Type type() const;
  inline void set_type(::weizhu::Network_Type value);

  // required .weizhu.Network.Protocol protocol = 2;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  inline ::weizhu::Network_Protocol protocol() const;
  inline void set_protocol(::weizhu::Network_Protocol value);

  // required string remote_host = 3;
  inline bool has_remote_host() const;
  inline void clear_remote_host();
  static const int kRemoteHostFieldNumber = 3;
  inline const ::std::string& remote_host() const;
  inline void set_remote_host(const ::std::string& value);
  inline void set_remote_host(const char* value);
  inline void set_remote_host(const char* value, size_t size);
  inline ::std::string* mutable_remote_host();
  inline ::std::string* release_remote_host();
  inline void set_allocated_remote_host(::std::string* remote_host);

  // required int32 remote_port = 4;
  inline bool has_remote_port() const;
  inline void clear_remote_port();
  static const int kRemotePortFieldNumber = 4;
  inline ::google::protobuf::int32 remote_port() const;
  inline void set_remote_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.Network)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_remote_host();
  inline void clear_has_remote_host();
  inline void set_has_remote_port();
  inline void clear_has_remote_port();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int protocol_;
  ::std::string* remote_host_;
  ::google::protobuf::int32 remote_port_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static Network* default_instance_;
};
// -------------------------------------------------------------------

class Weizhu : public ::google::protobuf::MessageLite {
 public:
  Weizhu();
  virtual ~Weizhu();

  Weizhu(const Weizhu& from);

  inline Weizhu& operator=(const Weizhu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Weizhu& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Weizhu* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Weizhu* other);

  // implements Message ----------------------------------------------

  Weizhu* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Weizhu& from);
  void MergeFrom(const Weizhu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Weizhu_Platform Platform;
  static const Platform ANDROID = Weizhu_Platform_ANDROID;
  static const Platform IPHONE = Weizhu_Platform_IPHONE;
  static inline bool Platform_IsValid(int value) {
    return Weizhu_Platform_IsValid(value);
  }
  static const Platform Platform_MIN =
    Weizhu_Platform_Platform_MIN;
  static const Platform Platform_MAX =
    Weizhu_Platform_Platform_MAX;
  static const int Platform_ARRAYSIZE =
    Weizhu_Platform_Platform_ARRAYSIZE;

  typedef Weizhu_Stage Stage;
  static const Stage RELEASE = Weizhu_Stage_RELEASE;
  static const Stage BETA = Weizhu_Stage_BETA;
  static const Stage ALPHA = Weizhu_Stage_ALPHA;
  static inline bool Stage_IsValid(int value) {
    return Weizhu_Stage_IsValid(value);
  }
  static const Stage Stage_MIN =
    Weizhu_Stage_Stage_MIN;
  static const Stage Stage_MAX =
    Weizhu_Stage_Stage_MAX;
  static const int Stage_ARRAYSIZE =
    Weizhu_Stage_Stage_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .weizhu.Weizhu.Platform platform = 1;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 1;
  inline ::weizhu::Weizhu_Platform platform() const;
  inline void set_platform(::weizhu::Weizhu_Platform value);

  // required string version_name = 2;
  inline bool has_version_name() const;
  inline void clear_version_name();
  static const int kVersionNameFieldNumber = 2;
  inline const ::std::string& version_name() const;
  inline void set_version_name(const ::std::string& value);
  inline void set_version_name(const char* value);
  inline void set_version_name(const char* value, size_t size);
  inline ::std::string* mutable_version_name();
  inline ::std::string* release_version_name();
  inline void set_allocated_version_name(::std::string* version_name);

  // required int32 version_code = 3;
  inline bool has_version_code() const;
  inline void clear_version_code();
  static const int kVersionCodeFieldNumber = 3;
  inline ::google::protobuf::int32 version_code() const;
  inline void set_version_code(::google::protobuf::int32 value);

  // required .weizhu.Weizhu.Stage stage = 4;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 4;
  inline ::weizhu::Weizhu_Stage stage() const;
  inline void set_stage(::weizhu::Weizhu_Stage value);

  // required int32 build_time = 5;
  inline bool has_build_time() const;
  inline void clear_build_time();
  static const int kBuildTimeFieldNumber = 5;
  inline ::google::protobuf::int32 build_time() const;
  inline void set_build_time(::google::protobuf::int32 value);

  // optional string build_hash = 6;
  inline bool has_build_hash() const;
  inline void clear_build_hash();
  static const int kBuildHashFieldNumber = 6;
  inline const ::std::string& build_hash() const;
  inline void set_build_hash(const ::std::string& value);
  inline void set_build_hash(const char* value);
  inline void set_build_hash(const char* value, size_t size);
  inline ::std::string* mutable_build_hash();
  inline ::std::string* release_build_hash();
  inline void set_allocated_build_hash(::std::string* build_hash);

  // @@protoc_insertion_point(class_scope:weizhu.Weizhu)
 private:
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_version_name();
  inline void clear_has_version_name();
  inline void set_has_version_code();
  inline void clear_has_version_code();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_build_time();
  inline void clear_has_build_time();
  inline void set_has_build_hash();
  inline void clear_has_build_hash();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_name_;
  int platform_;
  ::google::protobuf::int32 version_code_;
  int stage_;
  ::google::protobuf::int32 build_time_;
  ::std::string* build_hash_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static Weizhu* default_instance_;
};
// -------------------------------------------------------------------

class Android : public ::google::protobuf::MessageLite {
 public:
  Android();
  virtual ~Android();

  Android(const Android& from);

  inline Android& operator=(const Android& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Android& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Android* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Android* other);

  // implements Message ----------------------------------------------

  Android* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Android& from);
  void MergeFrom(const Android& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string device = 1;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 1;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // required string manufacturer = 2;
  inline bool has_manufacturer() const;
  inline void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  inline const ::std::string& manufacturer() const;
  inline void set_manufacturer(const ::std::string& value);
  inline void set_manufacturer(const char* value);
  inline void set_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_manufacturer();
  inline ::std::string* release_manufacturer();
  inline void set_allocated_manufacturer(::std::string* manufacturer);

  // required string brand = 3;
  inline bool has_brand() const;
  inline void clear_brand();
  static const int kBrandFieldNumber = 3;
  inline const ::std::string& brand() const;
  inline void set_brand(const ::std::string& value);
  inline void set_brand(const char* value);
  inline void set_brand(const char* value, size_t size);
  inline ::std::string* mutable_brand();
  inline ::std::string* release_brand();
  inline void set_allocated_brand(::std::string* brand);

  // required string model = 4;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 4;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // required string serial = 5;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 5;
  inline const ::std::string& serial() const;
  inline void set_serial(const ::std::string& value);
  inline void set_serial(const char* value);
  inline void set_serial(const char* value, size_t size);
  inline ::std::string* mutable_serial();
  inline ::std::string* release_serial();
  inline void set_allocated_serial(::std::string* serial);

  // required string release = 6;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 6;
  inline const ::std::string& release() const;
  inline void set_release(const ::std::string& value);
  inline void set_release(const char* value);
  inline void set_release(const char* value, size_t size);
  inline ::std::string* mutable_release();
  inline ::std::string* release_release();
  inline void set_allocated_release(::std::string* release);

  // required int32 sdk_int = 7;
  inline bool has_sdk_int() const;
  inline void clear_sdk_int();
  static const int kSdkIntFieldNumber = 7;
  inline ::google::protobuf::int32 sdk_int() const;
  inline void set_sdk_int(::google::protobuf::int32 value);

  // required string codename = 8;
  inline bool has_codename() const;
  inline void clear_codename();
  static const int kCodenameFieldNumber = 8;
  inline const ::std::string& codename() const;
  inline void set_codename(const ::std::string& value);
  inline void set_codename(const char* value);
  inline void set_codename(const char* value, size_t size);
  inline ::std::string* mutable_codename();
  inline ::std::string* release_codename();
  inline void set_allocated_codename(::std::string* codename);

  // @@protoc_insertion_point(class_scope:weizhu.Android)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_manufacturer();
  inline void clear_has_manufacturer();
  inline void set_has_brand();
  inline void clear_has_brand();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_sdk_int();
  inline void clear_has_sdk_int();
  inline void set_has_codename();
  inline void clear_has_codename();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* device_;
  ::std::string* manufacturer_;
  ::std::string* brand_;
  ::std::string* model_;
  ::std::string* serial_;
  ::std::string* release_;
  ::std::string* codename_;
  ::google::protobuf::int32 sdk_int_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static Android* default_instance_;
};
// -------------------------------------------------------------------

class Iphone : public ::google::protobuf::MessageLite {
 public:
  Iphone();
  virtual ~Iphone();

  Iphone(const Iphone& from);

  inline Iphone& operator=(const Iphone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Iphone& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Iphone* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Iphone* other);

  // implements Message ----------------------------------------------

  Iphone* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Iphone& from);
  void MergeFrom(const Iphone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string system_name = 2;
  inline bool has_system_name() const;
  inline void clear_system_name();
  static const int kSystemNameFieldNumber = 2;
  inline const ::std::string& system_name() const;
  inline void set_system_name(const ::std::string& value);
  inline void set_system_name(const char* value);
  inline void set_system_name(const char* value, size_t size);
  inline ::std::string* mutable_system_name();
  inline ::std::string* release_system_name();
  inline void set_allocated_system_name(::std::string* system_name);

  // required string system_version = 3;
  inline bool has_system_version() const;
  inline void clear_system_version();
  static const int kSystemVersionFieldNumber = 3;
  inline const ::std::string& system_version() const;
  inline void set_system_version(const ::std::string& value);
  inline void set_system_version(const char* value);
  inline void set_system_version(const char* value, size_t size);
  inline ::std::string* mutable_system_version();
  inline ::std::string* release_system_version();
  inline void set_allocated_system_version(::std::string* system_version);

  // required string model = 4;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 4;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // required string localized_model = 5;
  inline bool has_localized_model() const;
  inline void clear_localized_model();
  static const int kLocalizedModelFieldNumber = 5;
  inline const ::std::string& localized_model() const;
  inline void set_localized_model(const ::std::string& value);
  inline void set_localized_model(const char* value);
  inline void set_localized_model(const char* value, size_t size);
  inline ::std::string* mutable_localized_model();
  inline ::std::string* release_localized_model();
  inline void set_allocated_localized_model(::std::string* localized_model);

  // required string device_token = 6;
  inline bool has_device_token() const;
  inline void clear_device_token();
  static const int kDeviceTokenFieldNumber = 6;
  inline const ::std::string& device_token() const;
  inline void set_device_token(const ::std::string& value);
  inline void set_device_token(const char* value);
  inline void set_device_token(const char* value, size_t size);
  inline ::std::string* mutable_device_token();
  inline ::std::string* release_device_token();
  inline void set_allocated_device_token(::std::string* device_token);

  // required string mac = 7;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 7;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional string app_id = 8 [default = "com.21tb.weizhu"];
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 8;
  inline const ::std::string& app_id() const;
  inline void set_app_id(const ::std::string& value);
  inline void set_app_id(const char* value);
  inline void set_app_id(const char* value, size_t size);
  inline ::std::string* mutable_app_id();
  inline ::std::string* release_app_id();
  inline void set_allocated_app_id(::std::string* app_id);

  // @@protoc_insertion_point(class_scope:weizhu.Iphone)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_system_name();
  inline void clear_has_system_name();
  inline void set_has_system_version();
  inline void clear_has_system_version();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_localized_model();
  inline void clear_has_localized_model();
  inline void set_has_device_token();
  inline void clear_has_device_token();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* system_name_;
  ::std::string* system_version_;
  ::std::string* model_;
  ::std::string* localized_model_;
  ::std::string* device_token_;
  ::std::string* mac_;
  static ::std::string* _default_app_id_;
  ::std::string* app_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static Iphone* default_instance_;
};
// -------------------------------------------------------------------

class WebMobile : public ::google::protobuf::MessageLite {
 public:
  WebMobile();
  virtual ~WebMobile();

  WebMobile(const WebMobile& from);

  inline WebMobile& operator=(const WebMobile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const WebMobile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WebMobile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WebMobile* other);

  // implements Message ----------------------------------------------

  WebMobile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WebMobile& from);
  void MergeFrom(const WebMobile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_agent = 1;
  inline bool has_user_agent() const;
  inline void clear_user_agent();
  static const int kUserAgentFieldNumber = 1;
  inline const ::std::string& user_agent() const;
  inline void set_user_agent(const ::std::string& value);
  inline void set_user_agent(const char* value);
  inline void set_user_agent(const char* value, size_t size);
  inline ::std::string* mutable_user_agent();
  inline ::std::string* release_user_agent();
  inline void set_allocated_user_agent(::std::string* user_agent);

  // @@protoc_insertion_point(class_scope:weizhu.WebMobile)
 private:
  inline void set_has_user_agent();
  inline void clear_has_user_agent();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_agent_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static WebMobile* default_instance_;
};
// -------------------------------------------------------------------

class HttpApiRequest : public ::google::protobuf::MessageLite {
 public:
  HttpApiRequest();
  virtual ~HttpApiRequest();

  HttpApiRequest(const HttpApiRequest& from);

  inline HttpApiRequest& operator=(const HttpApiRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HttpApiRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HttpApiRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HttpApiRequest* other);

  // implements Message ----------------------------------------------

  HttpApiRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HttpApiRequest& from);
  void MergeFrom(const HttpApiRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes session_key = 1;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 1;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const void* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // required .weizhu.Invoke invoke = 2;
  inline bool has_invoke() const;
  inline void clear_invoke();
  static const int kInvokeFieldNumber = 2;
  inline const ::weizhu::Invoke& invoke() const;
  inline ::weizhu::Invoke* mutable_invoke();
  inline ::weizhu::Invoke* release_invoke();
  inline void set_allocated_invoke(::weizhu::Invoke* invoke);

  // required .weizhu.Network.Type network_type = 3;
  inline bool has_network_type() const;
  inline void clear_network_type();
  static const int kNetworkTypeFieldNumber = 3;
  inline ::weizhu::Network_Type network_type() const;
  inline void set_network_type(::weizhu::Network_Type value);

  // required .weizhu.Weizhu weizhu = 4;
  inline bool has_weizhu() const;
  inline void clear_weizhu();
  static const int kWeizhuFieldNumber = 4;
  inline const ::weizhu::Weizhu& weizhu() const;
  inline ::weizhu::Weizhu* mutable_weizhu();
  inline ::weizhu::Weizhu* release_weizhu();
  inline void set_allocated_weizhu(::weizhu::Weizhu* weizhu);

  // optional .weizhu.Android android = 5;
  inline bool has_android() const;
  inline void clear_android();
  static const int kAndroidFieldNumber = 5;
  inline const ::weizhu::Android& android() const;
  inline ::weizhu::Android* mutable_android();
  inline ::weizhu::Android* release_android();
  inline void set_allocated_android(::weizhu::Android* android);

  // optional .weizhu.Iphone iphone = 6;
  inline bool has_iphone() const;
  inline void clear_iphone();
  static const int kIphoneFieldNumber = 6;
  inline const ::weizhu::Iphone& iphone() const;
  inline ::weizhu::Iphone* mutable_iphone();
  inline ::weizhu::Iphone* release_iphone();
  inline void set_allocated_iphone(::weizhu::Iphone* iphone);

  // required bytes request_body = 99;
  inline bool has_request_body() const;
  inline void clear_request_body();
  static const int kRequestBodyFieldNumber = 99;
  inline const ::std::string& request_body() const;
  inline void set_request_body(const ::std::string& value);
  inline void set_request_body(const char* value);
  inline void set_request_body(const void* value, size_t size);
  inline ::std::string* mutable_request_body();
  inline ::std::string* release_request_body();
  inline void set_allocated_request_body(::std::string* request_body);

  // @@protoc_insertion_point(class_scope:weizhu.HttpApiRequest)
 private:
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_invoke();
  inline void clear_has_invoke();
  inline void set_has_network_type();
  inline void clear_has_network_type();
  inline void set_has_weizhu();
  inline void clear_has_weizhu();
  inline void set_has_android();
  inline void clear_has_android();
  inline void set_has_iphone();
  inline void clear_has_iphone();
  inline void set_has_request_body();
  inline void clear_has_request_body();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* session_key_;
  ::weizhu::Invoke* invoke_;
  ::weizhu::Weizhu* weizhu_;
  ::weizhu::Android* android_;
  ::weizhu::Iphone* iphone_;
  ::std::string* request_body_;
  int network_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static HttpApiRequest* default_instance_;
};
// -------------------------------------------------------------------

class HttpApiResponse : public ::google::protobuf::MessageLite {
 public:
  HttpApiResponse();
  virtual ~HttpApiResponse();

  HttpApiResponse(const HttpApiResponse& from);

  inline HttpApiResponse& operator=(const HttpApiResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HttpApiResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HttpApiResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HttpApiResponse* other);

  // implements Message ----------------------------------------------

  HttpApiResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HttpApiResponse& from);
  void MergeFrom(const HttpApiResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HttpApiResponse_Result Result;
  static const Result SUCC = HttpApiResponse_Result_SUCC;
  static const Result FAIL_SESSION_DECRYPTION = HttpApiResponse_Result_FAIL_SESSION_DECRYPTION;
  static const Result FAIL_SESSION_EXPIRED = HttpApiResponse_Result_FAIL_SESSION_EXPIRED;
  static const Result FAIL_INVOKE_UNKNOWN = HttpApiResponse_Result_FAIL_INVOKE_UNKNOWN;
  static const Result FAIL_BODY_DECRYPTION = HttpApiResponse_Result_FAIL_BODY_DECRYPTION;
  static const Result FAIL_BODY_PARSE_FAIL = HttpApiResponse_Result_FAIL_BODY_PARSE_FAIL;
  static const Result FAIL_USER_DISABLE = HttpApiResponse_Result_FAIL_USER_DISABLE;
  static const Result FAIL_SERVER_EXCEPTION = HttpApiResponse_Result_FAIL_SERVER_EXCEPTION;
  static inline bool Result_IsValid(int value) {
    return HttpApiResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    HttpApiResponse_Result_Result_MIN;
  static const Result Result_MAX =
    HttpApiResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    HttpApiResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .weizhu.Invoke invoke = 1;
  inline bool has_invoke() const;
  inline void clear_invoke();
  static const int kInvokeFieldNumber = 1;
  inline const ::weizhu::Invoke& invoke() const;
  inline ::weizhu::Invoke* mutable_invoke();
  inline ::weizhu::Invoke* release_invoke();
  inline void set_allocated_invoke(::weizhu::Invoke* invoke);

  // optional .weizhu.HttpApiResponse.Result result = 2 [default = FAIL_SERVER_EXCEPTION];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::weizhu::HttpApiResponse_Result result() const;
  inline void set_result(::weizhu::HttpApiResponse_Result value);

  // optional string fail_text = 3;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 3;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional bytes response_body = 4;
  inline bool has_response_body() const;
  inline void clear_response_body();
  static const int kResponseBodyFieldNumber = 4;
  inline const ::std::string& response_body() const;
  inline void set_response_body(const ::std::string& value);
  inline void set_response_body(const char* value);
  inline void set_response_body(const void* value, size_t size);
  inline ::std::string* mutable_response_body();
  inline ::std::string* release_response_body();
  inline void set_allocated_response_body(::std::string* response_body);

  // @@protoc_insertion_point(class_scope:weizhu.HttpApiResponse)
 private:
  inline void set_has_invoke();
  inline void clear_has_invoke();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_response_body();
  inline void clear_has_response_body();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::Invoke* invoke_;
  ::std::string* fail_text_;
  ::std::string* response_body_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static HttpApiResponse* default_instance_;
};
// -------------------------------------------------------------------

class SocketEstablishRequest : public ::google::protobuf::MessageLite {
 public:
  SocketEstablishRequest();
  virtual ~SocketEstablishRequest();

  SocketEstablishRequest(const SocketEstablishRequest& from);

  inline SocketEstablishRequest& operator=(const SocketEstablishRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketEstablishRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketEstablishRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketEstablishRequest* other);

  // implements Message ----------------------------------------------

  SocketEstablishRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketEstablishRequest& from);
  void MergeFrom(const SocketEstablishRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes session_key = 1;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 1;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const void* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // required .weizhu.Network.Type network_type = 2;
  inline bool has_network_type() const;
  inline void clear_network_type();
  static const int kNetworkTypeFieldNumber = 2;
  inline ::weizhu::Network_Type network_type() const;
  inline void set_network_type(::weizhu::Network_Type value);

  // required .weizhu.Weizhu weizhu = 3;
  inline bool has_weizhu() const;
  inline void clear_weizhu();
  static const int kWeizhuFieldNumber = 3;
  inline const ::weizhu::Weizhu& weizhu() const;
  inline ::weizhu::Weizhu* mutable_weizhu();
  inline ::weizhu::Weizhu* release_weizhu();
  inline void set_allocated_weizhu(::weizhu::Weizhu* weizhu);

  // optional .weizhu.Android android = 4;
  inline bool has_android() const;
  inline void clear_android();
  static const int kAndroidFieldNumber = 4;
  inline const ::weizhu::Android& android() const;
  inline ::weizhu::Android* mutable_android();
  inline ::weizhu::Android* release_android();
  inline void set_allocated_android(::weizhu::Android* android);

  // optional .weizhu.Iphone iphone = 5;
  inline bool has_iphone() const;
  inline void clear_iphone();
  static const int kIphoneFieldNumber = 5;
  inline const ::weizhu::Iphone& iphone() const;
  inline ::weizhu::Iphone* mutable_iphone();
  inline ::weizhu::Iphone* release_iphone();
  inline void set_allocated_iphone(::weizhu::Iphone* iphone);

  // required int64 push_seq = 6;
  inline bool has_push_seq() const;
  inline void clear_push_seq();
  static const int kPushSeqFieldNumber = 6;
  inline ::google::protobuf::int64 push_seq() const;
  inline void set_push_seq(::google::protobuf::int64 value);

  // repeated string push_name = 7;
  inline int push_name_size() const;
  inline void clear_push_name();
  static const int kPushNameFieldNumber = 7;
  inline const ::std::string& push_name(int index) const;
  inline ::std::string* mutable_push_name(int index);
  inline void set_push_name(int index, const ::std::string& value);
  inline void set_push_name(int index, const char* value);
  inline void set_push_name(int index, const char* value, size_t size);
  inline ::std::string* add_push_name();
  inline void add_push_name(const ::std::string& value);
  inline void add_push_name(const char* value);
  inline void add_push_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& push_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_push_name();

  // @@protoc_insertion_point(class_scope:weizhu.SocketEstablishRequest)
 private:
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_network_type();
  inline void clear_has_network_type();
  inline void set_has_weizhu();
  inline void clear_has_weizhu();
  inline void set_has_android();
  inline void clear_has_android();
  inline void set_has_iphone();
  inline void clear_has_iphone();
  inline void set_has_push_seq();
  inline void clear_has_push_seq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* session_key_;
  ::weizhu::Weizhu* weizhu_;
  ::weizhu::Android* android_;
  ::weizhu::Iphone* iphone_;
  ::google::protobuf::int64 push_seq_;
  ::google::protobuf::RepeatedPtrField< ::std::string> push_name_;
  int network_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketEstablishRequest* default_instance_;
};
// -------------------------------------------------------------------

class SocketEstablishResponse : public ::google::protobuf::MessageLite {
 public:
  SocketEstablishResponse();
  virtual ~SocketEstablishResponse();

  SocketEstablishResponse(const SocketEstablishResponse& from);

  inline SocketEstablishResponse& operator=(const SocketEstablishResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketEstablishResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketEstablishResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketEstablishResponse* other);

  // implements Message ----------------------------------------------

  SocketEstablishResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketEstablishResponse& from);
  void MergeFrom(const SocketEstablishResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SocketEstablishResponse_Result Result;
  static const Result SUCC = SocketEstablishResponse_Result_SUCC;
  static const Result FAIL_SESSION_DECRYPTION = SocketEstablishResponse_Result_FAIL_SESSION_DECRYPTION;
  static const Result FAIL_SESSION_EXPIRED = SocketEstablishResponse_Result_FAIL_SESSION_EXPIRED;
  static const Result FAIL_USER_DISABLE = SocketEstablishResponse_Result_FAIL_USER_DISABLE;
  static const Result FAIL_SERVER_EXCEPTION = SocketEstablishResponse_Result_FAIL_SERVER_EXCEPTION;
  static inline bool Result_IsValid(int value) {
    return SocketEstablishResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    SocketEstablishResponse_Result_Result_MIN;
  static const Result Result_MAX =
    SocketEstablishResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    SocketEstablishResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.SocketEstablishResponse.Result result = 1 [default = FAIL_SERVER_EXCEPTION];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::SocketEstablishResponse_Result result() const;
  inline void set_result(::weizhu::SocketEstablishResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional int64 reset_push_seq = 3;
  inline bool has_reset_push_seq() const;
  inline void clear_reset_push_seq();
  static const int kResetPushSeqFieldNumber = 3;
  inline ::google::protobuf::int64 reset_push_seq() const;
  inline void set_reset_push_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.SocketEstablishResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_reset_push_seq();
  inline void clear_has_reset_push_seq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::google::protobuf::int64 reset_push_seq_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketEstablishResponse* default_instance_;
};
// -------------------------------------------------------------------

class SocketApiRequest : public ::google::protobuf::MessageLite {
 public:
  SocketApiRequest();
  virtual ~SocketApiRequest();

  SocketApiRequest(const SocketApiRequest& from);

  inline SocketApiRequest& operator=(const SocketApiRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketApiRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketApiRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketApiRequest* other);

  // implements Message ----------------------------------------------

  SocketApiRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketApiRequest& from);
  void MergeFrom(const SocketApiRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.Invoke invoke = 1;
  inline bool has_invoke() const;
  inline void clear_invoke();
  static const int kInvokeFieldNumber = 1;
  inline const ::weizhu::Invoke& invoke() const;
  inline ::weizhu::Invoke* mutable_invoke();
  inline ::weizhu::Invoke* release_invoke();
  inline void set_allocated_invoke(::weizhu::Invoke* invoke);

  // required bytes request_body = 99;
  inline bool has_request_body() const;
  inline void clear_request_body();
  static const int kRequestBodyFieldNumber = 99;
  inline const ::std::string& request_body() const;
  inline void set_request_body(const ::std::string& value);
  inline void set_request_body(const char* value);
  inline void set_request_body(const void* value, size_t size);
  inline ::std::string* mutable_request_body();
  inline ::std::string* release_request_body();
  inline void set_allocated_request_body(::std::string* request_body);

  // @@protoc_insertion_point(class_scope:weizhu.SocketApiRequest)
 private:
  inline void set_has_invoke();
  inline void clear_has_invoke();
  inline void set_has_request_body();
  inline void clear_has_request_body();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::Invoke* invoke_;
  ::std::string* request_body_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketApiRequest* default_instance_;
};
// -------------------------------------------------------------------

class SocketApiResponse : public ::google::protobuf::MessageLite {
 public:
  SocketApiResponse();
  virtual ~SocketApiResponse();

  SocketApiResponse(const SocketApiResponse& from);

  inline SocketApiResponse& operator=(const SocketApiResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketApiResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketApiResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketApiResponse* other);

  // implements Message ----------------------------------------------

  SocketApiResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketApiResponse& from);
  void MergeFrom(const SocketApiResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SocketApiResponse_Result Result;
  static const Result SUCC = SocketApiResponse_Result_SUCC;
  static const Result FAIL_ESTABLISH_INVALID = SocketApiResponse_Result_FAIL_ESTABLISH_INVALID;
  static const Result FAIL_INVOKE_UNKNOWN = SocketApiResponse_Result_FAIL_INVOKE_UNKNOWN;
  static const Result FAIL_BODY_DECRYPTION = SocketApiResponse_Result_FAIL_BODY_DECRYPTION;
  static const Result FAIL_BODY_PARSE_FAIL = SocketApiResponse_Result_FAIL_BODY_PARSE_FAIL;
  static const Result FAIL_SERVER_EXCEPTION = SocketApiResponse_Result_FAIL_SERVER_EXCEPTION;
  static inline bool Result_IsValid(int value) {
    return SocketApiResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    SocketApiResponse_Result_Result_MIN;
  static const Result Result_MAX =
    SocketApiResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    SocketApiResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .weizhu.Invoke invoke = 1;
  inline bool has_invoke() const;
  inline void clear_invoke();
  static const int kInvokeFieldNumber = 1;
  inline const ::weizhu::Invoke& invoke() const;
  inline ::weizhu::Invoke* mutable_invoke();
  inline ::weizhu::Invoke* release_invoke();
  inline void set_allocated_invoke(::weizhu::Invoke* invoke);

  // optional .weizhu.SocketApiResponse.Result result = 2 [default = FAIL_SERVER_EXCEPTION];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::weizhu::SocketApiResponse_Result result() const;
  inline void set_result(::weizhu::SocketApiResponse_Result value);

  // optional string fail_text = 3;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 3;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional bytes response_body = 4;
  inline bool has_response_body() const;
  inline void clear_response_body();
  static const int kResponseBodyFieldNumber = 4;
  inline const ::std::string& response_body() const;
  inline void set_response_body(const ::std::string& value);
  inline void set_response_body(const char* value);
  inline void set_response_body(const void* value, size_t size);
  inline ::std::string* mutable_response_body();
  inline ::std::string* release_response_body();
  inline void set_allocated_response_body(::std::string* response_body);

  // @@protoc_insertion_point(class_scope:weizhu.SocketApiResponse)
 private:
  inline void set_has_invoke();
  inline void clear_has_invoke();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_response_body();
  inline void clear_has_response_body();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::Invoke* invoke_;
  ::std::string* fail_text_;
  ::std::string* response_body_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketApiResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushMessage : public ::google::protobuf::MessageLite {
 public:
  PushMessage();
  virtual ~PushMessage();

  PushMessage(const PushMessage& from);

  inline PushMessage& operator=(const PushMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushMessage* other);

  // implements Message ----------------------------------------------

  PushMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushMessage& from);
  void MergeFrom(const PushMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 push_seq = 1;
  inline bool has_push_seq() const;
  inline void clear_push_seq();
  static const int kPushSeqFieldNumber = 1;
  inline ::google::protobuf::int64 push_seq() const;
  inline void set_push_seq(::google::protobuf::int64 value);

  // required string push_name = 2;
  inline bool has_push_name() const;
  inline void clear_push_name();
  static const int kPushNameFieldNumber = 2;
  inline const ::std::string& push_name() const;
  inline void set_push_name(const ::std::string& value);
  inline void set_push_name(const char* value);
  inline void set_push_name(const char* value, size_t size);
  inline ::std::string* mutable_push_name();
  inline ::std::string* release_push_name();
  inline void set_allocated_push_name(::std::string* push_name);

  // required bytes push_body = 3;
  inline bool has_push_body() const;
  inline void clear_push_body();
  static const int kPushBodyFieldNumber = 3;
  inline const ::std::string& push_body() const;
  inline void set_push_body(const ::std::string& value);
  inline void set_push_body(const char* value);
  inline void set_push_body(const void* value, size_t size);
  inline ::std::string* mutable_push_body();
  inline ::std::string* release_push_body();
  inline void set_allocated_push_body(::std::string* push_body);

  // @@protoc_insertion_point(class_scope:weizhu.PushMessage)
 private:
  inline void set_has_push_seq();
  inline void clear_has_push_seq();
  inline void set_has_push_name();
  inline void clear_has_push_name();
  inline void set_has_push_body();
  inline void clear_has_push_body();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 push_seq_;
  ::std::string* push_name_;
  ::std::string* push_body_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static PushMessage* default_instance_;
};
// -------------------------------------------------------------------

class SocketPushMsg : public ::google::protobuf::MessageLite {
 public:
  SocketPushMsg();
  virtual ~SocketPushMsg();

  SocketPushMsg(const SocketPushMsg& from);

  inline SocketPushMsg& operator=(const SocketPushMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketPushMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketPushMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketPushMsg* other);

  // implements Message ----------------------------------------------

  SocketPushMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketPushMsg& from);
  void MergeFrom(const SocketPushMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.PushMessage push_msg = 1;
  inline bool has_push_msg() const;
  inline void clear_push_msg();
  static const int kPushMsgFieldNumber = 1;
  inline const ::weizhu::PushMessage& push_msg() const;
  inline ::weizhu::PushMessage* mutable_push_msg();
  inline ::weizhu::PushMessage* release_push_msg();
  inline void set_allocated_push_msg(::weizhu::PushMessage* push_msg);

  // required bool has_more = 2;
  inline bool has_has_more() const;
  inline void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  inline bool has_more() const;
  inline void set_has_more(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.SocketPushMsg)
 private:
  inline void set_has_push_msg();
  inline void clear_has_push_msg();
  inline void set_has_has_more();
  inline void clear_has_has_more();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::PushMessage* push_msg_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketPushMsg* default_instance_;
};
// -------------------------------------------------------------------

class SocketPushAck : public ::google::protobuf::MessageLite {
 public:
  SocketPushAck();
  virtual ~SocketPushAck();

  SocketPushAck(const SocketPushAck& from);

  inline SocketPushAck& operator=(const SocketPushAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketPushAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketPushAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketPushAck* other);

  // implements Message ----------------------------------------------

  SocketPushAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketPushAck& from);
  void MergeFrom(const SocketPushAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 push_seq = 1;
  inline bool has_push_seq() const;
  inline void clear_push_seq();
  static const int kPushSeqFieldNumber = 1;
  inline ::google::protobuf::int64 push_seq() const;
  inline void set_push_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.SocketPushAck)
 private:
  inline void set_has_push_seq();
  inline void clear_has_push_seq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 push_seq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketPushAck* default_instance_;
};
// -------------------------------------------------------------------

class SocketPing : public ::google::protobuf::MessageLite {
 public:
  SocketPing();
  virtual ~SocketPing();

  SocketPing(const SocketPing& from);

  inline SocketPing& operator=(const SocketPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketPing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketPing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketPing* other);

  // implements Message ----------------------------------------------

  SocketPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketPing& from);
  void MergeFrom(const SocketPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.SocketPing)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketPing* default_instance_;
};
// -------------------------------------------------------------------

class SocketPong : public ::google::protobuf::MessageLite {
 public:
  SocketPong();
  virtual ~SocketPong();

  SocketPong(const SocketPong& from);

  inline SocketPong& operator=(const SocketPong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketPong& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketPong* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketPong* other);

  // implements Message ----------------------------------------------

  SocketPong* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketPong& from);
  void MergeFrom(const SocketPong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.SocketPong)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketPong* default_instance_;
};
// -------------------------------------------------------------------

class SocketUpPacket : public ::google::protobuf::MessageLite {
 public:
  SocketUpPacket();
  virtual ~SocketUpPacket();

  SocketUpPacket(const SocketUpPacket& from);

  inline SocketUpPacket& operator=(const SocketUpPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketUpPacket& default_instance();

  enum PacketCase {
    kEstablishRequest = 1,
    kApiRequest = 2,
    kPushAck = 3,
    kPing = 4,
    kPong = 5,
    PACKET_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketUpPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketUpPacket* other);

  // implements Message ----------------------------------------------

  SocketUpPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketUpPacket& from);
  void MergeFrom(const SocketUpPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .weizhu.SocketEstablishRequest establish_request = 1;
  inline bool has_establish_request() const;
  inline void clear_establish_request();
  static const int kEstablishRequestFieldNumber = 1;
  inline const ::weizhu::SocketEstablishRequest& establish_request() const;
  inline ::weizhu::SocketEstablishRequest* mutable_establish_request();
  inline ::weizhu::SocketEstablishRequest* release_establish_request();
  inline void set_allocated_establish_request(::weizhu::SocketEstablishRequest* establish_request);

  // optional .weizhu.SocketApiRequest api_request = 2;
  inline bool has_api_request() const;
  inline void clear_api_request();
  static const int kApiRequestFieldNumber = 2;
  inline const ::weizhu::SocketApiRequest& api_request() const;
  inline ::weizhu::SocketApiRequest* mutable_api_request();
  inline ::weizhu::SocketApiRequest* release_api_request();
  inline void set_allocated_api_request(::weizhu::SocketApiRequest* api_request);

  // optional .weizhu.SocketPushAck push_ack = 3;
  inline bool has_push_ack() const;
  inline void clear_push_ack();
  static const int kPushAckFieldNumber = 3;
  inline const ::weizhu::SocketPushAck& push_ack() const;
  inline ::weizhu::SocketPushAck* mutable_push_ack();
  inline ::weizhu::SocketPushAck* release_push_ack();
  inline void set_allocated_push_ack(::weizhu::SocketPushAck* push_ack);

  // optional .weizhu.SocketPing ping = 4;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 4;
  inline const ::weizhu::SocketPing& ping() const;
  inline ::weizhu::SocketPing* mutable_ping();
  inline ::weizhu::SocketPing* release_ping();
  inline void set_allocated_ping(::weizhu::SocketPing* ping);

  // optional .weizhu.SocketPong pong = 5;
  inline bool has_pong() const;
  inline void clear_pong();
  static const int kPongFieldNumber = 5;
  inline const ::weizhu::SocketPong& pong() const;
  inline ::weizhu::SocketPong* mutable_pong();
  inline ::weizhu::SocketPong* release_pong();
  inline void set_allocated_pong(::weizhu::SocketPong* pong);

  inline PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:weizhu.SocketUpPacket)
 private:
  inline void set_has_establish_request();
  inline void set_has_api_request();
  inline void set_has_push_ack();
  inline void set_has_ping();
  inline void set_has_pong();

  inline bool has_packet();
  void clear_packet();
  inline void clear_has_packet();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union PacketUnion {
    ::weizhu::SocketEstablishRequest* establish_request_;
    ::weizhu::SocketApiRequest* api_request_;
    ::weizhu::SocketPushAck* push_ack_;
    ::weizhu::SocketPing* ping_;
    ::weizhu::SocketPong* pong_;
  } packet_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketUpPacket* default_instance_;
};
// -------------------------------------------------------------------

class SocketDownPacket : public ::google::protobuf::MessageLite {
 public:
  SocketDownPacket();
  virtual ~SocketDownPacket();

  SocketDownPacket(const SocketDownPacket& from);

  inline SocketDownPacket& operator=(const SocketDownPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SocketDownPacket& default_instance();

  enum PacketCase {
    kEstablishResponse = 1,
    kApiResponse = 2,
    kPushMsg = 3,
    kPing = 4,
    kPong = 5,
    PACKET_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketDownPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketDownPacket* other);

  // implements Message ----------------------------------------------

  SocketDownPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketDownPacket& from);
  void MergeFrom(const SocketDownPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .weizhu.SocketEstablishResponse establish_response = 1;
  inline bool has_establish_response() const;
  inline void clear_establish_response();
  static const int kEstablishResponseFieldNumber = 1;
  inline const ::weizhu::SocketEstablishResponse& establish_response() const;
  inline ::weizhu::SocketEstablishResponse* mutable_establish_response();
  inline ::weizhu::SocketEstablishResponse* release_establish_response();
  inline void set_allocated_establish_response(::weizhu::SocketEstablishResponse* establish_response);

  // optional .weizhu.SocketApiResponse api_response = 2;
  inline bool has_api_response() const;
  inline void clear_api_response();
  static const int kApiResponseFieldNumber = 2;
  inline const ::weizhu::SocketApiResponse& api_response() const;
  inline ::weizhu::SocketApiResponse* mutable_api_response();
  inline ::weizhu::SocketApiResponse* release_api_response();
  inline void set_allocated_api_response(::weizhu::SocketApiResponse* api_response);

  // optional .weizhu.SocketPushMsg push_msg = 3;
  inline bool has_push_msg() const;
  inline void clear_push_msg();
  static const int kPushMsgFieldNumber = 3;
  inline const ::weizhu::SocketPushMsg& push_msg() const;
  inline ::weizhu::SocketPushMsg* mutable_push_msg();
  inline ::weizhu::SocketPushMsg* release_push_msg();
  inline void set_allocated_push_msg(::weizhu::SocketPushMsg* push_msg);

  // optional .weizhu.SocketPing ping = 4;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 4;
  inline const ::weizhu::SocketPing& ping() const;
  inline ::weizhu::SocketPing* mutable_ping();
  inline ::weizhu::SocketPing* release_ping();
  inline void set_allocated_ping(::weizhu::SocketPing* ping);

  // optional .weizhu.SocketPong pong = 5;
  inline bool has_pong() const;
  inline void clear_pong();
  static const int kPongFieldNumber = 5;
  inline const ::weizhu::SocketPong& pong() const;
  inline ::weizhu::SocketPong* mutable_pong();
  inline ::weizhu::SocketPong* release_pong();
  inline void set_allocated_pong(::weizhu::SocketPong* pong);

  inline PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:weizhu.SocketDownPacket)
 private:
  inline void set_has_establish_response();
  inline void set_has_api_response();
  inline void set_has_push_msg();
  inline void set_has_ping();
  inline void set_has_pong();

  inline bool has_packet();
  void clear_packet();
  inline void clear_has_packet();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union PacketUnion {
    ::weizhu::SocketEstablishResponse* establish_response_;
    ::weizhu::SocketApiResponse* api_response_;
    ::weizhu::SocketPushMsg* push_msg_;
    ::weizhu::SocketPing* ping_;
    ::weizhu::SocketPong* pong_;
  } packet_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SocketDownPacket* default_instance_;
};
// -------------------------------------------------------------------

class SystemHead : public ::google::protobuf::MessageLite {
 public:
  SystemHead();
  virtual ~SystemHead();

  SystemHead(const SystemHead& from);

  inline SystemHead& operator=(const SystemHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SystemHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemHead* other);

  // implements Message ----------------------------------------------

  SystemHead* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemHead& from);
  void MergeFrom(const SystemHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.SystemHead)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 company_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static SystemHead* default_instance_;
};
// -------------------------------------------------------------------

class RequestHead : public ::google::protobuf::MessageLite {
 public:
  RequestHead();
  virtual ~RequestHead();

  RequestHead(const RequestHead& from);

  inline RequestHead& operator=(const RequestHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RequestHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestHead* other);

  // implements Message ----------------------------------------------

  RequestHead* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestHead& from);
  void MergeFrom(const RequestHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.Session session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline const ::weizhu::Session& session() const;
  inline ::weizhu::Session* mutable_session();
  inline ::weizhu::Session* release_session();
  inline void set_allocated_session(::weizhu::Session* session);

  // required .weizhu.Invoke invoke = 2;
  inline bool has_invoke() const;
  inline void clear_invoke();
  static const int kInvokeFieldNumber = 2;
  inline const ::weizhu::Invoke& invoke() const;
  inline ::weizhu::Invoke* mutable_invoke();
  inline ::weizhu::Invoke* release_invoke();
  inline void set_allocated_invoke(::weizhu::Invoke* invoke);

  // required .weizhu.Network network = 3;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 3;
  inline const ::weizhu::Network& network() const;
  inline ::weizhu::Network* mutable_network();
  inline ::weizhu::Network* release_network();
  inline void set_allocated_network(::weizhu::Network* network);

  // optional .weizhu.Weizhu weizhu = 4;
  inline bool has_weizhu() const;
  inline void clear_weizhu();
  static const int kWeizhuFieldNumber = 4;
  inline const ::weizhu::Weizhu& weizhu() const;
  inline ::weizhu::Weizhu* mutable_weizhu();
  inline ::weizhu::Weizhu* release_weizhu();
  inline void set_allocated_weizhu(::weizhu::Weizhu* weizhu);

  // optional .weizhu.Android android = 5;
  inline bool has_android() const;
  inline void clear_android();
  static const int kAndroidFieldNumber = 5;
  inline const ::weizhu::Android& android() const;
  inline ::weizhu::Android* mutable_android();
  inline ::weizhu::Android* release_android();
  inline void set_allocated_android(::weizhu::Android* android);

  // optional .weizhu.Iphone iphone = 6;
  inline bool has_iphone() const;
  inline void clear_iphone();
  static const int kIphoneFieldNumber = 6;
  inline const ::weizhu::Iphone& iphone() const;
  inline ::weizhu::Iphone* mutable_iphone();
  inline ::weizhu::Iphone* release_iphone();
  inline void set_allocated_iphone(::weizhu::Iphone* iphone);

  // optional .weizhu.WebMobile web_mobile = 7;
  inline bool has_web_mobile() const;
  inline void clear_web_mobile();
  static const int kWebMobileFieldNumber = 7;
  inline const ::weizhu::WebMobile& web_mobile() const;
  inline ::weizhu::WebMobile* mutable_web_mobile();
  inline ::weizhu::WebMobile* release_web_mobile();
  inline void set_allocated_web_mobile(::weizhu::WebMobile* web_mobile);

  // @@protoc_insertion_point(class_scope:weizhu.RequestHead)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_invoke();
  inline void clear_has_invoke();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_weizhu();
  inline void clear_has_weizhu();
  inline void set_has_android();
  inline void clear_has_android();
  inline void set_has_iphone();
  inline void clear_has_iphone();
  inline void set_has_web_mobile();
  inline void clear_has_web_mobile();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::Session* session_;
  ::weizhu::Invoke* invoke_;
  ::weizhu::Network* network_;
  ::weizhu::Weizhu* weizhu_;
  ::weizhu::Android* android_;
  ::weizhu::Iphone* iphone_;
  ::weizhu::WebMobile* web_mobile_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static RequestHead* default_instance_;
};
// -------------------------------------------------------------------

class AnonymousHead : public ::google::protobuf::MessageLite {
 public:
  AnonymousHead();
  virtual ~AnonymousHead();

  AnonymousHead(const AnonymousHead& from);

  inline AnonymousHead& operator=(const AnonymousHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AnonymousHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AnonymousHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AnonymousHead* other);

  // implements Message ----------------------------------------------

  AnonymousHead* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AnonymousHead& from);
  void MergeFrom(const AnonymousHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // required .weizhu.Invoke invoke = 2;
  inline bool has_invoke() const;
  inline void clear_invoke();
  static const int kInvokeFieldNumber = 2;
  inline const ::weizhu::Invoke& invoke() const;
  inline ::weizhu::Invoke* mutable_invoke();
  inline ::weizhu::Invoke* release_invoke();
  inline void set_allocated_invoke(::weizhu::Invoke* invoke);

  // required .weizhu.Network network = 3;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 3;
  inline const ::weizhu::Network& network() const;
  inline ::weizhu::Network* mutable_network();
  inline ::weizhu::Network* release_network();
  inline void set_allocated_network(::weizhu::Network* network);

  // optional .weizhu.Weizhu weizhu = 4;
  inline bool has_weizhu() const;
  inline void clear_weizhu();
  static const int kWeizhuFieldNumber = 4;
  inline const ::weizhu::Weizhu& weizhu() const;
  inline ::weizhu::Weizhu* mutable_weizhu();
  inline ::weizhu::Weizhu* release_weizhu();
  inline void set_allocated_weizhu(::weizhu::Weizhu* weizhu);

  // optional .weizhu.Android android = 5;
  inline bool has_android() const;
  inline void clear_android();
  static const int kAndroidFieldNumber = 5;
  inline const ::weizhu::Android& android() const;
  inline ::weizhu::Android* mutable_android();
  inline ::weizhu::Android* release_android();
  inline void set_allocated_android(::weizhu::Android* android);

  // optional .weizhu.Iphone iphone = 6;
  inline bool has_iphone() const;
  inline void clear_iphone();
  static const int kIphoneFieldNumber = 6;
  inline const ::weizhu::Iphone& iphone() const;
  inline ::weizhu::Iphone* mutable_iphone();
  inline ::weizhu::Iphone* release_iphone();
  inline void set_allocated_iphone(::weizhu::Iphone* iphone);

  // optional .weizhu.WebMobile web_mobile = 7;
  inline bool has_web_mobile() const;
  inline void clear_web_mobile();
  static const int kWebMobileFieldNumber = 7;
  inline const ::weizhu::WebMobile& web_mobile() const;
  inline ::weizhu::WebMobile* mutable_web_mobile();
  inline ::weizhu::WebMobile* release_web_mobile();
  inline void set_allocated_web_mobile(::weizhu::WebMobile* web_mobile);

  // @@protoc_insertion_point(class_scope:weizhu.AnonymousHead)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_invoke();
  inline void clear_has_invoke();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_weizhu();
  inline void clear_has_weizhu();
  inline void set_has_android();
  inline void clear_has_android();
  inline void set_has_iphone();
  inline void clear_has_iphone();
  inline void set_has_web_mobile();
  inline void clear_has_web_mobile();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 company_id_;
  ::weizhu::Invoke* invoke_;
  ::weizhu::Network* network_;
  ::weizhu::Weizhu* weizhu_;
  ::weizhu::Android* android_;
  ::weizhu::Iphone* iphone_;
  ::weizhu::WebMobile* web_mobile_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static AnonymousHead* default_instance_;
};
// -------------------------------------------------------------------

class EmptyRequest : public ::google::protobuf::MessageLite {
 public:
  EmptyRequest();
  virtual ~EmptyRequest();

  EmptyRequest(const EmptyRequest& from);

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EmptyRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EmptyRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EmptyRequest* other);

  // implements Message ----------------------------------------------

  EmptyRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EmptyRequest& from);
  void MergeFrom(const EmptyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:weizhu.EmptyRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static EmptyRequest* default_instance_;
};
// -------------------------------------------------------------------

class EmptyResponse : public ::google::protobuf::MessageLite {
 public:
  EmptyResponse();
  virtual ~EmptyResponse();

  EmptyResponse(const EmptyResponse& from);

  inline EmptyResponse& operator=(const EmptyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EmptyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EmptyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EmptyResponse* other);

  // implements Message ----------------------------------------------

  EmptyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EmptyResponse& from);
  void MergeFrom(const EmptyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:weizhu.EmptyResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static EmptyResponse* default_instance_;
};
// -------------------------------------------------------------------

class TestPush : public ::google::protobuf::MessageLite {
 public:
  TestPush();
  virtual ~TestPush();

  TestPush(const TestPush& from);

  inline TestPush& operator=(const TestPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TestPush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestPush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestPush* other);

  // implements Message ----------------------------------------------

  TestPush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestPush& from);
  void MergeFrom(const TestPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:weizhu.TestPush)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_weizhu_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_weizhu_2eproto();
  #endif
  friend void protobuf_AssignDesc_weizhu_2eproto();
  friend void protobuf_ShutdownFile_weizhu_2eproto();

  void InitAsDefaultInstance();
  static TestPush* default_instance_;
};
// ===================================================================


// ===================================================================

// Invoke

// required int32 invoke_id = 1;
inline bool Invoke::has_invoke_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Invoke::set_has_invoke_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Invoke::clear_has_invoke_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Invoke::clear_invoke_id() {
  invoke_id_ = 0;
  clear_has_invoke_id();
}
inline ::google::protobuf::int32 Invoke::invoke_id() const {
  // @@protoc_insertion_point(field_get:weizhu.Invoke.invoke_id)
  return invoke_id_;
}
inline void Invoke::set_invoke_id(::google::protobuf::int32 value) {
  set_has_invoke_id();
  invoke_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Invoke.invoke_id)
}

// required string service_name = 2;
inline bool Invoke::has_service_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Invoke::set_has_service_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Invoke::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Invoke::clear_service_name() {
  if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_->clear();
  }
  clear_has_service_name();
}
inline const ::std::string& Invoke::service_name() const {
  // @@protoc_insertion_point(field_get:weizhu.Invoke.service_name)
  return *service_name_;
}
inline void Invoke::set_service_name(const ::std::string& value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Invoke.service_name)
}
inline void Invoke::set_service_name(const char* value) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Invoke.service_name)
}
inline void Invoke::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  service_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Invoke.service_name)
}
inline ::std::string* Invoke::mutable_service_name() {
  set_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Invoke.service_name)
  return service_name_;
}
inline ::std::string* Invoke::release_service_name() {
  clear_has_service_name();
  if (service_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_name_;
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoke::set_allocated_service_name(::std::string* service_name) {
  if (service_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_name_;
  }
  if (service_name) {
    set_has_service_name();
    service_name_ = service_name;
  } else {
    clear_has_service_name();
    service_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Invoke.service_name)
}

// required string function_name = 3;
inline bool Invoke::has_function_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Invoke::set_has_function_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Invoke::clear_has_function_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Invoke::clear_function_name() {
  if (function_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_->clear();
  }
  clear_has_function_name();
}
inline const ::std::string& Invoke::function_name() const {
  // @@protoc_insertion_point(field_get:weizhu.Invoke.function_name)
  return *function_name_;
}
inline void Invoke::set_function_name(const ::std::string& value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Invoke.function_name)
}
inline void Invoke::set_function_name(const char* value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Invoke.function_name)
}
inline void Invoke::set_function_name(const char* value, size_t size) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Invoke.function_name)
}
inline ::std::string* Invoke::mutable_function_name() {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Invoke.function_name)
  return function_name_;
}
inline ::std::string* Invoke::release_function_name() {
  clear_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_name_;
    function_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Invoke::set_allocated_function_name(::std::string* function_name) {
  if (function_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_name_;
  }
  if (function_name) {
    set_has_function_name();
    function_name_ = function_name;
  } else {
    clear_has_function_name();
    function_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Invoke.function_name)
}

// -------------------------------------------------------------------

// Session

// required int64 company_id = 1;
inline bool Session::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Session::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Session::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Session::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 Session::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.Session.company_id)
  return company_id_;
}
inline void Session::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Session.company_id)
}

// required int64 user_id = 2;
inline bool Session::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Session::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Session::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Session::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 Session::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.Session.user_id)
  return user_id_;
}
inline void Session::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Session.user_id)
}

// required int64 session_id = 3;
inline bool Session::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Session::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Session::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Session::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
  clear_has_session_id();
}
inline ::google::protobuf::int64 Session::session_id() const {
  // @@protoc_insertion_point(field_get:weizhu.Session.session_id)
  return session_id_;
}
inline void Session::set_session_id(::google::protobuf::int64 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Session.session_id)
}

// -------------------------------------------------------------------

// Network

// required .weizhu.Network.Type type = 1;
inline bool Network::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Network::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Network::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Network::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::weizhu::Network_Type Network::type() const {
  // @@protoc_insertion_point(field_get:weizhu.Network.type)
  return static_cast< ::weizhu::Network_Type >(type_);
}
inline void Network::set_type(::weizhu::Network_Type value) {
  assert(::weizhu::Network_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Network.type)
}

// required .weizhu.Network.Protocol protocol = 2;
inline bool Network::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Network::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Network::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Network::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline ::weizhu::Network_Protocol Network::protocol() const {
  // @@protoc_insertion_point(field_get:weizhu.Network.protocol)
  return static_cast< ::weizhu::Network_Protocol >(protocol_);
}
inline void Network::set_protocol(::weizhu::Network_Protocol value) {
  assert(::weizhu::Network_Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Network.protocol)
}

// required string remote_host = 3;
inline bool Network::has_remote_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Network::set_has_remote_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Network::clear_has_remote_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Network::clear_remote_host() {
  if (remote_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_->clear();
  }
  clear_has_remote_host();
}
inline const ::std::string& Network::remote_host() const {
  // @@protoc_insertion_point(field_get:weizhu.Network.remote_host)
  return *remote_host_;
}
inline void Network::set_remote_host(const ::std::string& value) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Network.remote_host)
}
inline void Network::set_remote_host(const char* value) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Network.remote_host)
}
inline void Network::set_remote_host(const char* value, size_t size) {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  remote_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Network.remote_host)
}
inline ::std::string* Network::mutable_remote_host() {
  set_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Network.remote_host)
  return remote_host_;
}
inline ::std::string* Network::release_remote_host() {
  clear_has_remote_host();
  if (remote_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remote_host_;
    remote_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Network::set_allocated_remote_host(::std::string* remote_host) {
  if (remote_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_host_;
  }
  if (remote_host) {
    set_has_remote_host();
    remote_host_ = remote_host;
  } else {
    clear_has_remote_host();
    remote_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Network.remote_host)
}

// required int32 remote_port = 4;
inline bool Network::has_remote_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Network::set_has_remote_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Network::clear_has_remote_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Network::clear_remote_port() {
  remote_port_ = 0;
  clear_has_remote_port();
}
inline ::google::protobuf::int32 Network::remote_port() const {
  // @@protoc_insertion_point(field_get:weizhu.Network.remote_port)
  return remote_port_;
}
inline void Network::set_remote_port(::google::protobuf::int32 value) {
  set_has_remote_port();
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Network.remote_port)
}

// -------------------------------------------------------------------

// Weizhu

// required .weizhu.Weizhu.Platform platform = 1;
inline bool Weizhu::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Weizhu::set_has_platform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Weizhu::clear_has_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Weizhu::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::weizhu::Weizhu_Platform Weizhu::platform() const {
  // @@protoc_insertion_point(field_get:weizhu.Weizhu.platform)
  return static_cast< ::weizhu::Weizhu_Platform >(platform_);
}
inline void Weizhu::set_platform(::weizhu::Weizhu_Platform value) {
  assert(::weizhu::Weizhu_Platform_IsValid(value));
  set_has_platform();
  platform_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Weizhu.platform)
}

// required string version_name = 2;
inline bool Weizhu::has_version_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Weizhu::set_has_version_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Weizhu::clear_has_version_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Weizhu::clear_version_name() {
  if (version_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_name_->clear();
  }
  clear_has_version_name();
}
inline const ::std::string& Weizhu::version_name() const {
  // @@protoc_insertion_point(field_get:weizhu.Weizhu.version_name)
  return *version_name_;
}
inline void Weizhu::set_version_name(const ::std::string& value) {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_name_ = new ::std::string;
  }
  version_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Weizhu.version_name)
}
inline void Weizhu::set_version_name(const char* value) {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_name_ = new ::std::string;
  }
  version_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Weizhu.version_name)
}
inline void Weizhu::set_version_name(const char* value, size_t size) {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_name_ = new ::std::string;
  }
  version_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Weizhu.version_name)
}
inline ::std::string* Weizhu::mutable_version_name() {
  set_has_version_name();
  if (version_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Weizhu.version_name)
  return version_name_;
}
inline ::std::string* Weizhu::release_version_name() {
  clear_has_version_name();
  if (version_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_name_;
    version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Weizhu::set_allocated_version_name(::std::string* version_name) {
  if (version_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_name_;
  }
  if (version_name) {
    set_has_version_name();
    version_name_ = version_name;
  } else {
    clear_has_version_name();
    version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Weizhu.version_name)
}

// required int32 version_code = 3;
inline bool Weizhu::has_version_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Weizhu::set_has_version_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Weizhu::clear_has_version_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Weizhu::clear_version_code() {
  version_code_ = 0;
  clear_has_version_code();
}
inline ::google::protobuf::int32 Weizhu::version_code() const {
  // @@protoc_insertion_point(field_get:weizhu.Weizhu.version_code)
  return version_code_;
}
inline void Weizhu::set_version_code(::google::protobuf::int32 value) {
  set_has_version_code();
  version_code_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Weizhu.version_code)
}

// required .weizhu.Weizhu.Stage stage = 4;
inline bool Weizhu::has_stage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Weizhu::set_has_stage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Weizhu::clear_has_stage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Weizhu::clear_stage() {
  stage_ = 0;
  clear_has_stage();
}
inline ::weizhu::Weizhu_Stage Weizhu::stage() const {
  // @@protoc_insertion_point(field_get:weizhu.Weizhu.stage)
  return static_cast< ::weizhu::Weizhu_Stage >(stage_);
}
inline void Weizhu::set_stage(::weizhu::Weizhu_Stage value) {
  assert(::weizhu::Weizhu_Stage_IsValid(value));
  set_has_stage();
  stage_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Weizhu.stage)
}

// required int32 build_time = 5;
inline bool Weizhu::has_build_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Weizhu::set_has_build_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Weizhu::clear_has_build_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Weizhu::clear_build_time() {
  build_time_ = 0;
  clear_has_build_time();
}
inline ::google::protobuf::int32 Weizhu::build_time() const {
  // @@protoc_insertion_point(field_get:weizhu.Weizhu.build_time)
  return build_time_;
}
inline void Weizhu::set_build_time(::google::protobuf::int32 value) {
  set_has_build_time();
  build_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Weizhu.build_time)
}

// optional string build_hash = 6;
inline bool Weizhu::has_build_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Weizhu::set_has_build_hash() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Weizhu::clear_has_build_hash() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Weizhu::clear_build_hash() {
  if (build_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_hash_->clear();
  }
  clear_has_build_hash();
}
inline const ::std::string& Weizhu::build_hash() const {
  // @@protoc_insertion_point(field_get:weizhu.Weizhu.build_hash)
  return *build_hash_;
}
inline void Weizhu::set_build_hash(const ::std::string& value) {
  set_has_build_hash();
  if (build_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_hash_ = new ::std::string;
  }
  build_hash_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Weizhu.build_hash)
}
inline void Weizhu::set_build_hash(const char* value) {
  set_has_build_hash();
  if (build_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_hash_ = new ::std::string;
  }
  build_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Weizhu.build_hash)
}
inline void Weizhu::set_build_hash(const char* value, size_t size) {
  set_has_build_hash();
  if (build_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_hash_ = new ::std::string;
  }
  build_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Weizhu.build_hash)
}
inline ::std::string* Weizhu::mutable_build_hash() {
  set_has_build_hash();
  if (build_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    build_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Weizhu.build_hash)
  return build_hash_;
}
inline ::std::string* Weizhu::release_build_hash() {
  clear_has_build_hash();
  if (build_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = build_hash_;
    build_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Weizhu::set_allocated_build_hash(::std::string* build_hash) {
  if (build_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete build_hash_;
  }
  if (build_hash) {
    set_has_build_hash();
    build_hash_ = build_hash;
  } else {
    clear_has_build_hash();
    build_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Weizhu.build_hash)
}

// -------------------------------------------------------------------

// Android

// required string device = 1;
inline bool Android::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Android::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Android::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Android::clear_device() {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& Android::device() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.device)
  return *device_;
}
inline void Android::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Android.device)
}
inline void Android::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Android.device)
}
inline void Android::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Android.device)
}
inline ::std::string* Android::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Android.device)
  return device_;
}
inline ::std::string* Android::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Android::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Android.device)
}

// required string manufacturer = 2;
inline bool Android::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Android::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Android::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Android::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& Android::manufacturer() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.manufacturer)
  return *manufacturer_;
}
inline void Android::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Android.manufacturer)
}
inline void Android::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Android.manufacturer)
}
inline void Android::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Android.manufacturer)
}
inline ::std::string* Android::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Android.manufacturer)
  return manufacturer_;
}
inline ::std::string* Android::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Android::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manufacturer_;
  }
  if (manufacturer) {
    set_has_manufacturer();
    manufacturer_ = manufacturer;
  } else {
    clear_has_manufacturer();
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Android.manufacturer)
}

// required string brand = 3;
inline bool Android::has_brand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Android::set_has_brand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Android::clear_has_brand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Android::clear_brand() {
  if (brand_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_->clear();
  }
  clear_has_brand();
}
inline const ::std::string& Android::brand() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.brand)
  return *brand_;
}
inline void Android::set_brand(const ::std::string& value) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  brand_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Android.brand)
}
inline void Android::set_brand(const char* value) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  brand_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Android.brand)
}
inline void Android::set_brand(const char* value, size_t size) {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  brand_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Android.brand)
}
inline ::std::string* Android::mutable_brand() {
  set_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    brand_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Android.brand)
  return brand_;
}
inline ::std::string* Android::release_brand() {
  clear_has_brand();
  if (brand_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = brand_;
    brand_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Android::set_allocated_brand(::std::string* brand) {
  if (brand_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete brand_;
  }
  if (brand) {
    set_has_brand();
    brand_ = brand;
  } else {
    clear_has_brand();
    brand_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Android.brand)
}

// required string model = 4;
inline bool Android::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Android::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Android::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Android::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& Android::model() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.model)
  return *model_;
}
inline void Android::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Android.model)
}
inline void Android::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Android.model)
}
inline void Android::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Android.model)
}
inline ::std::string* Android::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Android.model)
  return model_;
}
inline ::std::string* Android::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Android::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Android.model)
}

// required string serial = 5;
inline bool Android::has_serial() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Android::set_has_serial() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Android::clear_has_serial() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Android::clear_serial() {
  if (serial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_->clear();
  }
  clear_has_serial();
}
inline const ::std::string& Android::serial() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.serial)
  return *serial_;
}
inline void Android::set_serial(const ::std::string& value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Android.serial)
}
inline void Android::set_serial(const char* value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Android.serial)
}
inline void Android::set_serial(const char* value, size_t size) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  serial_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Android.serial)
}
inline ::std::string* Android::mutable_serial() {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Android.serial)
  return serial_;
}
inline ::std::string* Android::release_serial() {
  clear_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serial_;
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Android::set_allocated_serial(::std::string* serial) {
  if (serial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serial_;
  }
  if (serial) {
    set_has_serial();
    serial_ = serial;
  } else {
    clear_has_serial();
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Android.serial)
}

// required string release = 6;
inline bool Android::has_release() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Android::set_has_release() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Android::clear_has_release() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Android::clear_release() {
  if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_->clear();
  }
  clear_has_release();
}
inline const ::std::string& Android::release() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.release)
  return *release_;
}
inline void Android::set_release(const ::std::string& value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Android.release)
}
inline void Android::set_release(const char* value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Android.release)
}
inline void Android::set_release(const char* value, size_t size) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Android.release)
}
inline ::std::string* Android::mutable_release() {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Android.release)
  return release_;
}
inline ::std::string* Android::release_release() {
  clear_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = release_;
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Android::set_allocated_release(::std::string* release) {
  if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete release_;
  }
  if (release) {
    set_has_release();
    release_ = release;
  } else {
    clear_has_release();
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Android.release)
}

// required int32 sdk_int = 7;
inline bool Android::has_sdk_int() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Android::set_has_sdk_int() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Android::clear_has_sdk_int() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Android::clear_sdk_int() {
  sdk_int_ = 0;
  clear_has_sdk_int();
}
inline ::google::protobuf::int32 Android::sdk_int() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.sdk_int)
  return sdk_int_;
}
inline void Android::set_sdk_int(::google::protobuf::int32 value) {
  set_has_sdk_int();
  sdk_int_ = value;
  // @@protoc_insertion_point(field_set:weizhu.Android.sdk_int)
}

// required string codename = 8;
inline bool Android::has_codename() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Android::set_has_codename() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Android::clear_has_codename() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Android::clear_codename() {
  if (codename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_->clear();
  }
  clear_has_codename();
}
inline const ::std::string& Android::codename() const {
  // @@protoc_insertion_point(field_get:weizhu.Android.codename)
  return *codename_;
}
inline void Android::set_codename(const ::std::string& value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Android.codename)
}
inline void Android::set_codename(const char* value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Android.codename)
}
inline void Android::set_codename(const char* value, size_t size) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Android.codename)
}
inline ::std::string* Android::mutable_codename() {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Android.codename)
  return codename_;
}
inline ::std::string* Android::release_codename() {
  clear_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = codename_;
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Android::set_allocated_codename(::std::string* codename) {
  if (codename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete codename_;
  }
  if (codename) {
    set_has_codename();
    codename_ = codename;
  } else {
    clear_has_codename();
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Android.codename)
}

// -------------------------------------------------------------------

// Iphone

// required string name = 1;
inline bool Iphone::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Iphone::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Iphone::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Iphone::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Iphone::name() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.name)
  return *name_;
}
inline void Iphone::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.name)
}
inline void Iphone::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.name)
}
inline void Iphone::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.name)
}
inline ::std::string* Iphone::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.name)
  return name_;
}
inline ::std::string* Iphone::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Iphone::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.name)
}

// required string system_name = 2;
inline bool Iphone::has_system_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Iphone::set_has_system_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Iphone::clear_has_system_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Iphone::clear_system_name() {
  if (system_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_name_->clear();
  }
  clear_has_system_name();
}
inline const ::std::string& Iphone::system_name() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.system_name)
  return *system_name_;
}
inline void Iphone::set_system_name(const ::std::string& value) {
  set_has_system_name();
  if (system_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_name_ = new ::std::string;
  }
  system_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.system_name)
}
inline void Iphone::set_system_name(const char* value) {
  set_has_system_name();
  if (system_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_name_ = new ::std::string;
  }
  system_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.system_name)
}
inline void Iphone::set_system_name(const char* value, size_t size) {
  set_has_system_name();
  if (system_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_name_ = new ::std::string;
  }
  system_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.system_name)
}
inline ::std::string* Iphone::mutable_system_name() {
  set_has_system_name();
  if (system_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.system_name)
  return system_name_;
}
inline ::std::string* Iphone::release_system_name() {
  clear_has_system_name();
  if (system_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = system_name_;
    system_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Iphone::set_allocated_system_name(::std::string* system_name) {
  if (system_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete system_name_;
  }
  if (system_name) {
    set_has_system_name();
    system_name_ = system_name;
  } else {
    clear_has_system_name();
    system_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.system_name)
}

// required string system_version = 3;
inline bool Iphone::has_system_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Iphone::set_has_system_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Iphone::clear_has_system_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Iphone::clear_system_version() {
  if (system_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_version_->clear();
  }
  clear_has_system_version();
}
inline const ::std::string& Iphone::system_version() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.system_version)
  return *system_version_;
}
inline void Iphone::set_system_version(const ::std::string& value) {
  set_has_system_version();
  if (system_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_version_ = new ::std::string;
  }
  system_version_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.system_version)
}
inline void Iphone::set_system_version(const char* value) {
  set_has_system_version();
  if (system_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_version_ = new ::std::string;
  }
  system_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.system_version)
}
inline void Iphone::set_system_version(const char* value, size_t size) {
  set_has_system_version();
  if (system_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_version_ = new ::std::string;
  }
  system_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.system_version)
}
inline ::std::string* Iphone::mutable_system_version() {
  set_has_system_version();
  if (system_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    system_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.system_version)
  return system_version_;
}
inline ::std::string* Iphone::release_system_version() {
  clear_has_system_version();
  if (system_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = system_version_;
    system_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Iphone::set_allocated_system_version(::std::string* system_version) {
  if (system_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete system_version_;
  }
  if (system_version) {
    set_has_system_version();
    system_version_ = system_version;
  } else {
    clear_has_system_version();
    system_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.system_version)
}

// required string model = 4;
inline bool Iphone::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Iphone::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Iphone::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Iphone::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& Iphone::model() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.model)
  return *model_;
}
inline void Iphone::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.model)
}
inline void Iphone::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.model)
}
inline void Iphone::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.model)
}
inline ::std::string* Iphone::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.model)
  return model_;
}
inline ::std::string* Iphone::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Iphone::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.model)
}

// required string localized_model = 5;
inline bool Iphone::has_localized_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Iphone::set_has_localized_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Iphone::clear_has_localized_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Iphone::clear_localized_model() {
  if (localized_model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_model_->clear();
  }
  clear_has_localized_model();
}
inline const ::std::string& Iphone::localized_model() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.localized_model)
  return *localized_model_;
}
inline void Iphone::set_localized_model(const ::std::string& value) {
  set_has_localized_model();
  if (localized_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_model_ = new ::std::string;
  }
  localized_model_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.localized_model)
}
inline void Iphone::set_localized_model(const char* value) {
  set_has_localized_model();
  if (localized_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_model_ = new ::std::string;
  }
  localized_model_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.localized_model)
}
inline void Iphone::set_localized_model(const char* value, size_t size) {
  set_has_localized_model();
  if (localized_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_model_ = new ::std::string;
  }
  localized_model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.localized_model)
}
inline ::std::string* Iphone::mutable_localized_model() {
  set_has_localized_model();
  if (localized_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.localized_model)
  return localized_model_;
}
inline ::std::string* Iphone::release_localized_model() {
  clear_has_localized_model();
  if (localized_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = localized_model_;
    localized_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Iphone::set_allocated_localized_model(::std::string* localized_model) {
  if (localized_model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete localized_model_;
  }
  if (localized_model) {
    set_has_localized_model();
    localized_model_ = localized_model;
  } else {
    clear_has_localized_model();
    localized_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.localized_model)
}

// required string device_token = 6;
inline bool Iphone::has_device_token() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Iphone::set_has_device_token() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Iphone::clear_has_device_token() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Iphone::clear_device_token() {
  if (device_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_token_->clear();
  }
  clear_has_device_token();
}
inline const ::std::string& Iphone::device_token() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.device_token)
  return *device_token_;
}
inline void Iphone::set_device_token(const ::std::string& value) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.device_token)
}
inline void Iphone::set_device_token(const char* value) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.device_token)
}
inline void Iphone::set_device_token(const char* value, size_t size) {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_token_ = new ::std::string;
  }
  device_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.device_token)
}
inline ::std::string* Iphone::mutable_device_token() {
  set_has_device_token();
  if (device_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.device_token)
  return device_token_;
}
inline ::std::string* Iphone::release_device_token() {
  clear_has_device_token();
  if (device_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_token_;
    device_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Iphone::set_allocated_device_token(::std::string* device_token) {
  if (device_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_token_;
  }
  if (device_token) {
    set_has_device_token();
    device_token_ = device_token;
  } else {
    clear_has_device_token();
    device_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.device_token)
}

// required string mac = 7;
inline bool Iphone::has_mac() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Iphone::set_has_mac() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Iphone::clear_has_mac() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Iphone::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& Iphone::mac() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.mac)
  return *mac_;
}
inline void Iphone::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.mac)
}
inline void Iphone::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.mac)
}
inline void Iphone::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.mac)
}
inline ::std::string* Iphone::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.mac)
  return mac_;
}
inline ::std::string* Iphone::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Iphone::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.mac)
}

// optional string app_id = 8 [default = "com.21tb.weizhu"];
inline bool Iphone::has_app_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Iphone::set_has_app_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Iphone::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Iphone::clear_app_id() {
  if (app_id_ != _default_app_id_) {
    app_id_->assign(*_default_app_id_);
  }
  clear_has_app_id();
}
inline const ::std::string& Iphone::app_id() const {
  // @@protoc_insertion_point(field_get:weizhu.Iphone.app_id)
  return *app_id_;
}
inline void Iphone::set_app_id(const ::std::string& value) {
  set_has_app_id();
  if (app_id_ == _default_app_id_) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.Iphone.app_id)
}
inline void Iphone::set_app_id(const char* value) {
  set_has_app_id();
  if (app_id_ == _default_app_id_) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.Iphone.app_id)
}
inline void Iphone::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  if (app_id_ == _default_app_id_) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.Iphone.app_id)
}
inline ::std::string* Iphone::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == _default_app_id_) {
    app_id_ = new ::std::string(*_default_app_id_);
  }
  // @@protoc_insertion_point(field_mutable:weizhu.Iphone.app_id)
  return app_id_;
}
inline ::std::string* Iphone::release_app_id() {
  clear_has_app_id();
  if (app_id_ == _default_app_id_) {
    return NULL;
  } else {
    ::std::string* temp = app_id_;
    app_id_ = const_cast< ::std::string*>(_default_app_id_);
    return temp;
  }
}
inline void Iphone::set_allocated_app_id(::std::string* app_id) {
  if (app_id_ != _default_app_id_) {
    delete app_id_;
  }
  if (app_id) {
    set_has_app_id();
    app_id_ = app_id;
  } else {
    clear_has_app_id();
    app_id_ = const_cast< ::std::string*>(_default_app_id_);
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.Iphone.app_id)
}

// -------------------------------------------------------------------

// WebMobile

// required string user_agent = 1;
inline bool WebMobile::has_user_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebMobile::set_has_user_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebMobile::clear_has_user_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebMobile::clear_user_agent() {
  if (user_agent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_->clear();
  }
  clear_has_user_agent();
}
inline const ::std::string& WebMobile::user_agent() const {
  // @@protoc_insertion_point(field_get:weizhu.WebMobile.user_agent)
  return *user_agent_;
}
inline void WebMobile::set_user_agent(const ::std::string& value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.WebMobile.user_agent)
}
inline void WebMobile::set_user_agent(const char* value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.WebMobile.user_agent)
}
inline void WebMobile::set_user_agent(const char* value, size_t size) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.WebMobile.user_agent)
}
inline ::std::string* WebMobile::mutable_user_agent() {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_agent_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.WebMobile.user_agent)
  return user_agent_;
}
inline ::std::string* WebMobile::release_user_agent() {
  clear_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_agent_;
    user_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WebMobile::set_allocated_user_agent(::std::string* user_agent) {
  if (user_agent_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_agent_;
  }
  if (user_agent) {
    set_has_user_agent();
    user_agent_ = user_agent;
  } else {
    clear_has_user_agent();
    user_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.WebMobile.user_agent)
}

// -------------------------------------------------------------------

// HttpApiRequest

// required bytes session_key = 1;
inline bool HttpApiRequest::has_session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HttpApiRequest::set_has_session_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HttpApiRequest::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HttpApiRequest::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& HttpApiRequest::session_key() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiRequest.session_key)
  return *session_key_;
}
inline void HttpApiRequest::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.HttpApiRequest.session_key)
}
inline void HttpApiRequest::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.HttpApiRequest.session_key)
}
inline void HttpApiRequest::set_session_key(const void* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.HttpApiRequest.session_key)
}
inline ::std::string* HttpApiRequest::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiRequest.session_key)
  return session_key_;
}
inline ::std::string* HttpApiRequest::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HttpApiRequest::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiRequest.session_key)
}

// required .weizhu.Invoke invoke = 2;
inline bool HttpApiRequest::has_invoke() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HttpApiRequest::set_has_invoke() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HttpApiRequest::clear_has_invoke() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HttpApiRequest::clear_invoke() {
  if (invoke_ != NULL) invoke_->::weizhu::Invoke::Clear();
  clear_has_invoke();
}
inline const ::weizhu::Invoke& HttpApiRequest::invoke() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiRequest.invoke)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invoke_ != NULL ? *invoke_ : *default_instance().invoke_;
#else
  return invoke_ != NULL ? *invoke_ : *default_instance_->invoke_;
#endif
}
inline ::weizhu::Invoke* HttpApiRequest::mutable_invoke() {
  set_has_invoke();
  if (invoke_ == NULL) invoke_ = new ::weizhu::Invoke;
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiRequest.invoke)
  return invoke_;
}
inline ::weizhu::Invoke* HttpApiRequest::release_invoke() {
  clear_has_invoke();
  ::weizhu::Invoke* temp = invoke_;
  invoke_ = NULL;
  return temp;
}
inline void HttpApiRequest::set_allocated_invoke(::weizhu::Invoke* invoke) {
  delete invoke_;
  invoke_ = invoke;
  if (invoke) {
    set_has_invoke();
  } else {
    clear_has_invoke();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiRequest.invoke)
}

// required .weizhu.Network.Type network_type = 3;
inline bool HttpApiRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HttpApiRequest::set_has_network_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HttpApiRequest::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HttpApiRequest::clear_network_type() {
  network_type_ = 0;
  clear_has_network_type();
}
inline ::weizhu::Network_Type HttpApiRequest::network_type() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiRequest.network_type)
  return static_cast< ::weizhu::Network_Type >(network_type_);
}
inline void HttpApiRequest::set_network_type(::weizhu::Network_Type value) {
  assert(::weizhu::Network_Type_IsValid(value));
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:weizhu.HttpApiRequest.network_type)
}

// required .weizhu.Weizhu weizhu = 4;
inline bool HttpApiRequest::has_weizhu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HttpApiRequest::set_has_weizhu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HttpApiRequest::clear_has_weizhu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HttpApiRequest::clear_weizhu() {
  if (weizhu_ != NULL) weizhu_->::weizhu::Weizhu::Clear();
  clear_has_weizhu();
}
inline const ::weizhu::Weizhu& HttpApiRequest::weizhu() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiRequest.weizhu)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weizhu_ != NULL ? *weizhu_ : *default_instance().weizhu_;
#else
  return weizhu_ != NULL ? *weizhu_ : *default_instance_->weizhu_;
#endif
}
inline ::weizhu::Weizhu* HttpApiRequest::mutable_weizhu() {
  set_has_weizhu();
  if (weizhu_ == NULL) weizhu_ = new ::weizhu::Weizhu;
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiRequest.weizhu)
  return weizhu_;
}
inline ::weizhu::Weizhu* HttpApiRequest::release_weizhu() {
  clear_has_weizhu();
  ::weizhu::Weizhu* temp = weizhu_;
  weizhu_ = NULL;
  return temp;
}
inline void HttpApiRequest::set_allocated_weizhu(::weizhu::Weizhu* weizhu) {
  delete weizhu_;
  weizhu_ = weizhu;
  if (weizhu) {
    set_has_weizhu();
  } else {
    clear_has_weizhu();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiRequest.weizhu)
}

// optional .weizhu.Android android = 5;
inline bool HttpApiRequest::has_android() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HttpApiRequest::set_has_android() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HttpApiRequest::clear_has_android() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HttpApiRequest::clear_android() {
  if (android_ != NULL) android_->::weizhu::Android::Clear();
  clear_has_android();
}
inline const ::weizhu::Android& HttpApiRequest::android() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiRequest.android)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_ != NULL ? *android_ : *default_instance().android_;
#else
  return android_ != NULL ? *android_ : *default_instance_->android_;
#endif
}
inline ::weizhu::Android* HttpApiRequest::mutable_android() {
  set_has_android();
  if (android_ == NULL) android_ = new ::weizhu::Android;
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiRequest.android)
  return android_;
}
inline ::weizhu::Android* HttpApiRequest::release_android() {
  clear_has_android();
  ::weizhu::Android* temp = android_;
  android_ = NULL;
  return temp;
}
inline void HttpApiRequest::set_allocated_android(::weizhu::Android* android) {
  delete android_;
  android_ = android;
  if (android) {
    set_has_android();
  } else {
    clear_has_android();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiRequest.android)
}

// optional .weizhu.Iphone iphone = 6;
inline bool HttpApiRequest::has_iphone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HttpApiRequest::set_has_iphone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HttpApiRequest::clear_has_iphone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HttpApiRequest::clear_iphone() {
  if (iphone_ != NULL) iphone_->::weizhu::Iphone::Clear();
  clear_has_iphone();
}
inline const ::weizhu::Iphone& HttpApiRequest::iphone() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiRequest.iphone)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return iphone_ != NULL ? *iphone_ : *default_instance().iphone_;
#else
  return iphone_ != NULL ? *iphone_ : *default_instance_->iphone_;
#endif
}
inline ::weizhu::Iphone* HttpApiRequest::mutable_iphone() {
  set_has_iphone();
  if (iphone_ == NULL) iphone_ = new ::weizhu::Iphone;
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiRequest.iphone)
  return iphone_;
}
inline ::weizhu::Iphone* HttpApiRequest::release_iphone() {
  clear_has_iphone();
  ::weizhu::Iphone* temp = iphone_;
  iphone_ = NULL;
  return temp;
}
inline void HttpApiRequest::set_allocated_iphone(::weizhu::Iphone* iphone) {
  delete iphone_;
  iphone_ = iphone;
  if (iphone) {
    set_has_iphone();
  } else {
    clear_has_iphone();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiRequest.iphone)
}

// required bytes request_body = 99;
inline bool HttpApiRequest::has_request_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HttpApiRequest::set_has_request_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HttpApiRequest::clear_has_request_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HttpApiRequest::clear_request_body() {
  if (request_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_->clear();
  }
  clear_has_request_body();
}
inline const ::std::string& HttpApiRequest::request_body() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiRequest.request_body)
  return *request_body_;
}
inline void HttpApiRequest::set_request_body(const ::std::string& value) {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  request_body_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.HttpApiRequest.request_body)
}
inline void HttpApiRequest::set_request_body(const char* value) {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  request_body_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.HttpApiRequest.request_body)
}
inline void HttpApiRequest::set_request_body(const void* value, size_t size) {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  request_body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.HttpApiRequest.request_body)
}
inline ::std::string* HttpApiRequest::mutable_request_body() {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiRequest.request_body)
  return request_body_;
}
inline ::std::string* HttpApiRequest::release_request_body() {
  clear_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = request_body_;
    request_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HttpApiRequest::set_allocated_request_body(::std::string* request_body) {
  if (request_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete request_body_;
  }
  if (request_body) {
    set_has_request_body();
    request_body_ = request_body;
  } else {
    clear_has_request_body();
    request_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiRequest.request_body)
}

// -------------------------------------------------------------------

// HttpApiResponse

// required .weizhu.Invoke invoke = 1;
inline bool HttpApiResponse::has_invoke() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HttpApiResponse::set_has_invoke() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HttpApiResponse::clear_has_invoke() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HttpApiResponse::clear_invoke() {
  if (invoke_ != NULL) invoke_->::weizhu::Invoke::Clear();
  clear_has_invoke();
}
inline const ::weizhu::Invoke& HttpApiResponse::invoke() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiResponse.invoke)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invoke_ != NULL ? *invoke_ : *default_instance().invoke_;
#else
  return invoke_ != NULL ? *invoke_ : *default_instance_->invoke_;
#endif
}
inline ::weizhu::Invoke* HttpApiResponse::mutable_invoke() {
  set_has_invoke();
  if (invoke_ == NULL) invoke_ = new ::weizhu::Invoke;
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiResponse.invoke)
  return invoke_;
}
inline ::weizhu::Invoke* HttpApiResponse::release_invoke() {
  clear_has_invoke();
  ::weizhu::Invoke* temp = invoke_;
  invoke_ = NULL;
  return temp;
}
inline void HttpApiResponse::set_allocated_invoke(::weizhu::Invoke* invoke) {
  delete invoke_;
  invoke_ = invoke;
  if (invoke) {
    set_has_invoke();
  } else {
    clear_has_invoke();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiResponse.invoke)
}

// optional .weizhu.HttpApiResponse.Result result = 2 [default = FAIL_SERVER_EXCEPTION];
inline bool HttpApiResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HttpApiResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HttpApiResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HttpApiResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::HttpApiResponse_Result HttpApiResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiResponse.result)
  return static_cast< ::weizhu::HttpApiResponse_Result >(result_);
}
inline void HttpApiResponse::set_result(::weizhu::HttpApiResponse_Result value) {
  assert(::weizhu::HttpApiResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.HttpApiResponse.result)
}

// optional string fail_text = 3;
inline bool HttpApiResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HttpApiResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HttpApiResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HttpApiResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& HttpApiResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiResponse.fail_text)
  return *fail_text_;
}
inline void HttpApiResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.HttpApiResponse.fail_text)
}
inline void HttpApiResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.HttpApiResponse.fail_text)
}
inline void HttpApiResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.HttpApiResponse.fail_text)
}
inline ::std::string* HttpApiResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiResponse.fail_text)
  return fail_text_;
}
inline ::std::string* HttpApiResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HttpApiResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiResponse.fail_text)
}

// optional bytes response_body = 4;
inline bool HttpApiResponse::has_response_body() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HttpApiResponse::set_has_response_body() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HttpApiResponse::clear_has_response_body() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HttpApiResponse::clear_response_body() {
  if (response_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_->clear();
  }
  clear_has_response_body();
}
inline const ::std::string& HttpApiResponse::response_body() const {
  // @@protoc_insertion_point(field_get:weizhu.HttpApiResponse.response_body)
  return *response_body_;
}
inline void HttpApiResponse::set_response_body(const ::std::string& value) {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  response_body_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.HttpApiResponse.response_body)
}
inline void HttpApiResponse::set_response_body(const char* value) {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  response_body_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.HttpApiResponse.response_body)
}
inline void HttpApiResponse::set_response_body(const void* value, size_t size) {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  response_body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.HttpApiResponse.response_body)
}
inline ::std::string* HttpApiResponse::mutable_response_body() {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.HttpApiResponse.response_body)
  return response_body_;
}
inline ::std::string* HttpApiResponse::release_response_body() {
  clear_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = response_body_;
    response_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HttpApiResponse::set_allocated_response_body(::std::string* response_body) {
  if (response_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete response_body_;
  }
  if (response_body) {
    set_has_response_body();
    response_body_ = response_body;
  } else {
    clear_has_response_body();
    response_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.HttpApiResponse.response_body)
}

// -------------------------------------------------------------------

// SocketEstablishRequest

// required bytes session_key = 1;
inline bool SocketEstablishRequest::has_session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketEstablishRequest::set_has_session_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketEstablishRequest::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketEstablishRequest::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& SocketEstablishRequest::session_key() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishRequest.session_key)
  return *session_key_;
}
inline void SocketEstablishRequest::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.SocketEstablishRequest.session_key)
}
inline void SocketEstablishRequest::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.SocketEstablishRequest.session_key)
}
inline void SocketEstablishRequest::set_session_key(const void* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.SocketEstablishRequest.session_key)
}
inline ::std::string* SocketEstablishRequest::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.SocketEstablishRequest.session_key)
  return session_key_;
}
inline ::std::string* SocketEstablishRequest::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SocketEstablishRequest::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketEstablishRequest.session_key)
}

// required .weizhu.Network.Type network_type = 2;
inline bool SocketEstablishRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocketEstablishRequest::set_has_network_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocketEstablishRequest::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocketEstablishRequest::clear_network_type() {
  network_type_ = 0;
  clear_has_network_type();
}
inline ::weizhu::Network_Type SocketEstablishRequest::network_type() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishRequest.network_type)
  return static_cast< ::weizhu::Network_Type >(network_type_);
}
inline void SocketEstablishRequest::set_network_type(::weizhu::Network_Type value) {
  assert(::weizhu::Network_Type_IsValid(value));
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketEstablishRequest.network_type)
}

// required .weizhu.Weizhu weizhu = 3;
inline bool SocketEstablishRequest::has_weizhu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SocketEstablishRequest::set_has_weizhu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SocketEstablishRequest::clear_has_weizhu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SocketEstablishRequest::clear_weizhu() {
  if (weizhu_ != NULL) weizhu_->::weizhu::Weizhu::Clear();
  clear_has_weizhu();
}
inline const ::weizhu::Weizhu& SocketEstablishRequest::weizhu() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishRequest.weizhu)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weizhu_ != NULL ? *weizhu_ : *default_instance().weizhu_;
#else
  return weizhu_ != NULL ? *weizhu_ : *default_instance_->weizhu_;
#endif
}
inline ::weizhu::Weizhu* SocketEstablishRequest::mutable_weizhu() {
  set_has_weizhu();
  if (weizhu_ == NULL) weizhu_ = new ::weizhu::Weizhu;
  // @@protoc_insertion_point(field_mutable:weizhu.SocketEstablishRequest.weizhu)
  return weizhu_;
}
inline ::weizhu::Weizhu* SocketEstablishRequest::release_weizhu() {
  clear_has_weizhu();
  ::weizhu::Weizhu* temp = weizhu_;
  weizhu_ = NULL;
  return temp;
}
inline void SocketEstablishRequest::set_allocated_weizhu(::weizhu::Weizhu* weizhu) {
  delete weizhu_;
  weizhu_ = weizhu;
  if (weizhu) {
    set_has_weizhu();
  } else {
    clear_has_weizhu();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketEstablishRequest.weizhu)
}

// optional .weizhu.Android android = 4;
inline bool SocketEstablishRequest::has_android() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SocketEstablishRequest::set_has_android() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SocketEstablishRequest::clear_has_android() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SocketEstablishRequest::clear_android() {
  if (android_ != NULL) android_->::weizhu::Android::Clear();
  clear_has_android();
}
inline const ::weizhu::Android& SocketEstablishRequest::android() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishRequest.android)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_ != NULL ? *android_ : *default_instance().android_;
#else
  return android_ != NULL ? *android_ : *default_instance_->android_;
#endif
}
inline ::weizhu::Android* SocketEstablishRequest::mutable_android() {
  set_has_android();
  if (android_ == NULL) android_ = new ::weizhu::Android;
  // @@protoc_insertion_point(field_mutable:weizhu.SocketEstablishRequest.android)
  return android_;
}
inline ::weizhu::Android* SocketEstablishRequest::release_android() {
  clear_has_android();
  ::weizhu::Android* temp = android_;
  android_ = NULL;
  return temp;
}
inline void SocketEstablishRequest::set_allocated_android(::weizhu::Android* android) {
  delete android_;
  android_ = android;
  if (android) {
    set_has_android();
  } else {
    clear_has_android();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketEstablishRequest.android)
}

// optional .weizhu.Iphone iphone = 5;
inline bool SocketEstablishRequest::has_iphone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SocketEstablishRequest::set_has_iphone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SocketEstablishRequest::clear_has_iphone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SocketEstablishRequest::clear_iphone() {
  if (iphone_ != NULL) iphone_->::weizhu::Iphone::Clear();
  clear_has_iphone();
}
inline const ::weizhu::Iphone& SocketEstablishRequest::iphone() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishRequest.iphone)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return iphone_ != NULL ? *iphone_ : *default_instance().iphone_;
#else
  return iphone_ != NULL ? *iphone_ : *default_instance_->iphone_;
#endif
}
inline ::weizhu::Iphone* SocketEstablishRequest::mutable_iphone() {
  set_has_iphone();
  if (iphone_ == NULL) iphone_ = new ::weizhu::Iphone;
  // @@protoc_insertion_point(field_mutable:weizhu.SocketEstablishRequest.iphone)
  return iphone_;
}
inline ::weizhu::Iphone* SocketEstablishRequest::release_iphone() {
  clear_has_iphone();
  ::weizhu::Iphone* temp = iphone_;
  iphone_ = NULL;
  return temp;
}
inline void SocketEstablishRequest::set_allocated_iphone(::weizhu::Iphone* iphone) {
  delete iphone_;
  iphone_ = iphone;
  if (iphone) {
    set_has_iphone();
  } else {
    clear_has_iphone();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketEstablishRequest.iphone)
}

// required int64 push_seq = 6;
inline bool SocketEstablishRequest::has_push_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SocketEstablishRequest::set_has_push_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SocketEstablishRequest::clear_has_push_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SocketEstablishRequest::clear_push_seq() {
  push_seq_ = GOOGLE_LONGLONG(0);
  clear_has_push_seq();
}
inline ::google::protobuf::int64 SocketEstablishRequest::push_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishRequest.push_seq)
  return push_seq_;
}
inline void SocketEstablishRequest::set_push_seq(::google::protobuf::int64 value) {
  set_has_push_seq();
  push_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketEstablishRequest.push_seq)
}

// repeated string push_name = 7;
inline int SocketEstablishRequest::push_name_size() const {
  return push_name_.size();
}
inline void SocketEstablishRequest::clear_push_name() {
  push_name_.Clear();
}
inline const ::std::string& SocketEstablishRequest::push_name(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishRequest.push_name)
  return push_name_.Get(index);
}
inline ::std::string* SocketEstablishRequest::mutable_push_name(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.SocketEstablishRequest.push_name)
  return push_name_.Mutable(index);
}
inline void SocketEstablishRequest::set_push_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.SocketEstablishRequest.push_name)
  push_name_.Mutable(index)->assign(value);
}
inline void SocketEstablishRequest::set_push_name(int index, const char* value) {
  push_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.SocketEstablishRequest.push_name)
}
inline void SocketEstablishRequest::set_push_name(int index, const char* value, size_t size) {
  push_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.SocketEstablishRequest.push_name)
}
inline ::std::string* SocketEstablishRequest::add_push_name() {
  return push_name_.Add();
}
inline void SocketEstablishRequest::add_push_name(const ::std::string& value) {
  push_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.SocketEstablishRequest.push_name)
}
inline void SocketEstablishRequest::add_push_name(const char* value) {
  push_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.SocketEstablishRequest.push_name)
}
inline void SocketEstablishRequest::add_push_name(const char* value, size_t size) {
  push_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.SocketEstablishRequest.push_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SocketEstablishRequest::push_name() const {
  // @@protoc_insertion_point(field_list:weizhu.SocketEstablishRequest.push_name)
  return push_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SocketEstablishRequest::mutable_push_name() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.SocketEstablishRequest.push_name)
  return &push_name_;
}

// -------------------------------------------------------------------

// SocketEstablishResponse

// optional .weizhu.SocketEstablishResponse.Result result = 1 [default = FAIL_SERVER_EXCEPTION];
inline bool SocketEstablishResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketEstablishResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketEstablishResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketEstablishResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::SocketEstablishResponse_Result SocketEstablishResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishResponse.result)
  return static_cast< ::weizhu::SocketEstablishResponse_Result >(result_);
}
inline void SocketEstablishResponse::set_result(::weizhu::SocketEstablishResponse_Result value) {
  assert(::weizhu::SocketEstablishResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketEstablishResponse.result)
}

// optional string fail_text = 2;
inline bool SocketEstablishResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocketEstablishResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocketEstablishResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocketEstablishResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& SocketEstablishResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishResponse.fail_text)
  return *fail_text_;
}
inline void SocketEstablishResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.SocketEstablishResponse.fail_text)
}
inline void SocketEstablishResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.SocketEstablishResponse.fail_text)
}
inline void SocketEstablishResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.SocketEstablishResponse.fail_text)
}
inline ::std::string* SocketEstablishResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.SocketEstablishResponse.fail_text)
  return fail_text_;
}
inline ::std::string* SocketEstablishResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SocketEstablishResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketEstablishResponse.fail_text)
}

// optional int64 reset_push_seq = 3;
inline bool SocketEstablishResponse::has_reset_push_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SocketEstablishResponse::set_has_reset_push_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SocketEstablishResponse::clear_has_reset_push_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SocketEstablishResponse::clear_reset_push_seq() {
  reset_push_seq_ = GOOGLE_LONGLONG(0);
  clear_has_reset_push_seq();
}
inline ::google::protobuf::int64 SocketEstablishResponse::reset_push_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketEstablishResponse.reset_push_seq)
  return reset_push_seq_;
}
inline void SocketEstablishResponse::set_reset_push_seq(::google::protobuf::int64 value) {
  set_has_reset_push_seq();
  reset_push_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketEstablishResponse.reset_push_seq)
}

// -------------------------------------------------------------------

// SocketApiRequest

// required .weizhu.Invoke invoke = 1;
inline bool SocketApiRequest::has_invoke() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketApiRequest::set_has_invoke() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketApiRequest::clear_has_invoke() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketApiRequest::clear_invoke() {
  if (invoke_ != NULL) invoke_->::weizhu::Invoke::Clear();
  clear_has_invoke();
}
inline const ::weizhu::Invoke& SocketApiRequest::invoke() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketApiRequest.invoke)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invoke_ != NULL ? *invoke_ : *default_instance().invoke_;
#else
  return invoke_ != NULL ? *invoke_ : *default_instance_->invoke_;
#endif
}
inline ::weizhu::Invoke* SocketApiRequest::mutable_invoke() {
  set_has_invoke();
  if (invoke_ == NULL) invoke_ = new ::weizhu::Invoke;
  // @@protoc_insertion_point(field_mutable:weizhu.SocketApiRequest.invoke)
  return invoke_;
}
inline ::weizhu::Invoke* SocketApiRequest::release_invoke() {
  clear_has_invoke();
  ::weizhu::Invoke* temp = invoke_;
  invoke_ = NULL;
  return temp;
}
inline void SocketApiRequest::set_allocated_invoke(::weizhu::Invoke* invoke) {
  delete invoke_;
  invoke_ = invoke;
  if (invoke) {
    set_has_invoke();
  } else {
    clear_has_invoke();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketApiRequest.invoke)
}

// required bytes request_body = 99;
inline bool SocketApiRequest::has_request_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocketApiRequest::set_has_request_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocketApiRequest::clear_has_request_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocketApiRequest::clear_request_body() {
  if (request_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_->clear();
  }
  clear_has_request_body();
}
inline const ::std::string& SocketApiRequest::request_body() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketApiRequest.request_body)
  return *request_body_;
}
inline void SocketApiRequest::set_request_body(const ::std::string& value) {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  request_body_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.SocketApiRequest.request_body)
}
inline void SocketApiRequest::set_request_body(const char* value) {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  request_body_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.SocketApiRequest.request_body)
}
inline void SocketApiRequest::set_request_body(const void* value, size_t size) {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  request_body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.SocketApiRequest.request_body)
}
inline ::std::string* SocketApiRequest::mutable_request_body() {
  set_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.SocketApiRequest.request_body)
  return request_body_;
}
inline ::std::string* SocketApiRequest::release_request_body() {
  clear_has_request_body();
  if (request_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = request_body_;
    request_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SocketApiRequest::set_allocated_request_body(::std::string* request_body) {
  if (request_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete request_body_;
  }
  if (request_body) {
    set_has_request_body();
    request_body_ = request_body;
  } else {
    clear_has_request_body();
    request_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketApiRequest.request_body)
}

// -------------------------------------------------------------------

// SocketApiResponse

// required .weizhu.Invoke invoke = 1;
inline bool SocketApiResponse::has_invoke() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketApiResponse::set_has_invoke() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketApiResponse::clear_has_invoke() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketApiResponse::clear_invoke() {
  if (invoke_ != NULL) invoke_->::weizhu::Invoke::Clear();
  clear_has_invoke();
}
inline const ::weizhu::Invoke& SocketApiResponse::invoke() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketApiResponse.invoke)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invoke_ != NULL ? *invoke_ : *default_instance().invoke_;
#else
  return invoke_ != NULL ? *invoke_ : *default_instance_->invoke_;
#endif
}
inline ::weizhu::Invoke* SocketApiResponse::mutable_invoke() {
  set_has_invoke();
  if (invoke_ == NULL) invoke_ = new ::weizhu::Invoke;
  // @@protoc_insertion_point(field_mutable:weizhu.SocketApiResponse.invoke)
  return invoke_;
}
inline ::weizhu::Invoke* SocketApiResponse::release_invoke() {
  clear_has_invoke();
  ::weizhu::Invoke* temp = invoke_;
  invoke_ = NULL;
  return temp;
}
inline void SocketApiResponse::set_allocated_invoke(::weizhu::Invoke* invoke) {
  delete invoke_;
  invoke_ = invoke;
  if (invoke) {
    set_has_invoke();
  } else {
    clear_has_invoke();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketApiResponse.invoke)
}

// optional .weizhu.SocketApiResponse.Result result = 2 [default = FAIL_SERVER_EXCEPTION];
inline bool SocketApiResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocketApiResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocketApiResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocketApiResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::SocketApiResponse_Result SocketApiResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketApiResponse.result)
  return static_cast< ::weizhu::SocketApiResponse_Result >(result_);
}
inline void SocketApiResponse::set_result(::weizhu::SocketApiResponse_Result value) {
  assert(::weizhu::SocketApiResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketApiResponse.result)
}

// optional string fail_text = 3;
inline bool SocketApiResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SocketApiResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SocketApiResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SocketApiResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& SocketApiResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketApiResponse.fail_text)
  return *fail_text_;
}
inline void SocketApiResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.SocketApiResponse.fail_text)
}
inline void SocketApiResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.SocketApiResponse.fail_text)
}
inline void SocketApiResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.SocketApiResponse.fail_text)
}
inline ::std::string* SocketApiResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.SocketApiResponse.fail_text)
  return fail_text_;
}
inline ::std::string* SocketApiResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SocketApiResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketApiResponse.fail_text)
}

// optional bytes response_body = 4;
inline bool SocketApiResponse::has_response_body() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SocketApiResponse::set_has_response_body() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SocketApiResponse::clear_has_response_body() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SocketApiResponse::clear_response_body() {
  if (response_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_->clear();
  }
  clear_has_response_body();
}
inline const ::std::string& SocketApiResponse::response_body() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketApiResponse.response_body)
  return *response_body_;
}
inline void SocketApiResponse::set_response_body(const ::std::string& value) {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  response_body_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.SocketApiResponse.response_body)
}
inline void SocketApiResponse::set_response_body(const char* value) {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  response_body_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.SocketApiResponse.response_body)
}
inline void SocketApiResponse::set_response_body(const void* value, size_t size) {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  response_body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.SocketApiResponse.response_body)
}
inline ::std::string* SocketApiResponse::mutable_response_body() {
  set_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.SocketApiResponse.response_body)
  return response_body_;
}
inline ::std::string* SocketApiResponse::release_response_body() {
  clear_has_response_body();
  if (response_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = response_body_;
    response_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SocketApiResponse::set_allocated_response_body(::std::string* response_body) {
  if (response_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete response_body_;
  }
  if (response_body) {
    set_has_response_body();
    response_body_ = response_body;
  } else {
    clear_has_response_body();
    response_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketApiResponse.response_body)
}

// -------------------------------------------------------------------

// PushMessage

// required int64 push_seq = 1;
inline bool PushMessage::has_push_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushMessage::set_has_push_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushMessage::clear_has_push_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushMessage::clear_push_seq() {
  push_seq_ = GOOGLE_LONGLONG(0);
  clear_has_push_seq();
}
inline ::google::protobuf::int64 PushMessage::push_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.PushMessage.push_seq)
  return push_seq_;
}
inline void PushMessage::set_push_seq(::google::protobuf::int64 value) {
  set_has_push_seq();
  push_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.PushMessage.push_seq)
}

// required string push_name = 2;
inline bool PushMessage::has_push_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushMessage::set_has_push_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushMessage::clear_has_push_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushMessage::clear_push_name() {
  if (push_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_name_->clear();
  }
  clear_has_push_name();
}
inline const ::std::string& PushMessage::push_name() const {
  // @@protoc_insertion_point(field_get:weizhu.PushMessage.push_name)
  return *push_name_;
}
inline void PushMessage::set_push_name(const ::std::string& value) {
  set_has_push_name();
  if (push_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_name_ = new ::std::string;
  }
  push_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.PushMessage.push_name)
}
inline void PushMessage::set_push_name(const char* value) {
  set_has_push_name();
  if (push_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_name_ = new ::std::string;
  }
  push_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.PushMessage.push_name)
}
inline void PushMessage::set_push_name(const char* value, size_t size) {
  set_has_push_name();
  if (push_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_name_ = new ::std::string;
  }
  push_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.PushMessage.push_name)
}
inline ::std::string* PushMessage::mutable_push_name() {
  set_has_push_name();
  if (push_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.PushMessage.push_name)
  return push_name_;
}
inline ::std::string* PushMessage::release_push_name() {
  clear_has_push_name();
  if (push_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = push_name_;
    push_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushMessage::set_allocated_push_name(::std::string* push_name) {
  if (push_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete push_name_;
  }
  if (push_name) {
    set_has_push_name();
    push_name_ = push_name;
  } else {
    clear_has_push_name();
    push_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.PushMessage.push_name)
}

// required bytes push_body = 3;
inline bool PushMessage::has_push_body() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushMessage::set_has_push_body() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushMessage::clear_has_push_body() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushMessage::clear_push_body() {
  if (push_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_body_->clear();
  }
  clear_has_push_body();
}
inline const ::std::string& PushMessage::push_body() const {
  // @@protoc_insertion_point(field_get:weizhu.PushMessage.push_body)
  return *push_body_;
}
inline void PushMessage::set_push_body(const ::std::string& value) {
  set_has_push_body();
  if (push_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_body_ = new ::std::string;
  }
  push_body_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.PushMessage.push_body)
}
inline void PushMessage::set_push_body(const char* value) {
  set_has_push_body();
  if (push_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_body_ = new ::std::string;
  }
  push_body_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.PushMessage.push_body)
}
inline void PushMessage::set_push_body(const void* value, size_t size) {
  set_has_push_body();
  if (push_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_body_ = new ::std::string;
  }
  push_body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.PushMessage.push_body)
}
inline ::std::string* PushMessage::mutable_push_body() {
  set_has_push_body();
  if (push_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    push_body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.PushMessage.push_body)
  return push_body_;
}
inline ::std::string* PushMessage::release_push_body() {
  clear_has_push_body();
  if (push_body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = push_body_;
    push_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushMessage::set_allocated_push_body(::std::string* push_body) {
  if (push_body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete push_body_;
  }
  if (push_body) {
    set_has_push_body();
    push_body_ = push_body;
  } else {
    clear_has_push_body();
    push_body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.PushMessage.push_body)
}

// -------------------------------------------------------------------

// SocketPushMsg

// required .weizhu.PushMessage push_msg = 1;
inline bool SocketPushMsg::has_push_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketPushMsg::set_has_push_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketPushMsg::clear_has_push_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketPushMsg::clear_push_msg() {
  if (push_msg_ != NULL) push_msg_->::weizhu::PushMessage::Clear();
  clear_has_push_msg();
}
inline const ::weizhu::PushMessage& SocketPushMsg::push_msg() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketPushMsg.push_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return push_msg_ != NULL ? *push_msg_ : *default_instance().push_msg_;
#else
  return push_msg_ != NULL ? *push_msg_ : *default_instance_->push_msg_;
#endif
}
inline ::weizhu::PushMessage* SocketPushMsg::mutable_push_msg() {
  set_has_push_msg();
  if (push_msg_ == NULL) push_msg_ = new ::weizhu::PushMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.SocketPushMsg.push_msg)
  return push_msg_;
}
inline ::weizhu::PushMessage* SocketPushMsg::release_push_msg() {
  clear_has_push_msg();
  ::weizhu::PushMessage* temp = push_msg_;
  push_msg_ = NULL;
  return temp;
}
inline void SocketPushMsg::set_allocated_push_msg(::weizhu::PushMessage* push_msg) {
  delete push_msg_;
  push_msg_ = push_msg;
  if (push_msg) {
    set_has_push_msg();
  } else {
    clear_has_push_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.SocketPushMsg.push_msg)
}

// required bool has_more = 2;
inline bool SocketPushMsg::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocketPushMsg::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocketPushMsg::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocketPushMsg::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool SocketPushMsg::has_more() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketPushMsg.has_more)
  return has_more_;
}
inline void SocketPushMsg::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketPushMsg.has_more)
}

// -------------------------------------------------------------------

// SocketPushAck

// required int64 push_seq = 1;
inline bool SocketPushAck::has_push_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketPushAck::set_has_push_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketPushAck::clear_has_push_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketPushAck::clear_push_seq() {
  push_seq_ = GOOGLE_LONGLONG(0);
  clear_has_push_seq();
}
inline ::google::protobuf::int64 SocketPushAck::push_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketPushAck.push_seq)
  return push_seq_;
}
inline void SocketPushAck::set_push_seq(::google::protobuf::int64 value) {
  set_has_push_seq();
  push_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketPushAck.push_seq)
}

// -------------------------------------------------------------------

// SocketPing

// required int32 id = 1;
inline bool SocketPing::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketPing::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketPing::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketPing::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SocketPing::id() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketPing.id)
  return id_;
}
inline void SocketPing::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketPing.id)
}

// -------------------------------------------------------------------

// SocketPong

// required int32 id = 1;
inline bool SocketPong::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketPong::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketPong::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketPong::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SocketPong::id() const {
  // @@protoc_insertion_point(field_get:weizhu.SocketPong.id)
  return id_;
}
inline void SocketPong::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SocketPong.id)
}

// -------------------------------------------------------------------

// SocketUpPacket

// optional .weizhu.SocketEstablishRequest establish_request = 1;
inline bool SocketUpPacket::has_establish_request() const {
  return packet_case() == kEstablishRequest;
}
inline void SocketUpPacket::set_has_establish_request() {
  _oneof_case_[0] = kEstablishRequest;
}
inline void SocketUpPacket::clear_establish_request() {
  if (has_establish_request()) {
    delete packet_.establish_request_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketEstablishRequest& SocketUpPacket::establish_request() const {
  return has_establish_request() ? *packet_.establish_request_
                      : ::weizhu::SocketEstablishRequest::default_instance();
}
inline ::weizhu::SocketEstablishRequest* SocketUpPacket::mutable_establish_request() {
  if (!has_establish_request()) {
    clear_packet();
    set_has_establish_request();
    packet_.establish_request_ = new ::weizhu::SocketEstablishRequest;
  }
  return packet_.establish_request_;
}
inline ::weizhu::SocketEstablishRequest* SocketUpPacket::release_establish_request() {
  if (has_establish_request()) {
    clear_has_packet();
    ::weizhu::SocketEstablishRequest* temp = packet_.establish_request_;
    packet_.establish_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketUpPacket::set_allocated_establish_request(::weizhu::SocketEstablishRequest* establish_request) {
  clear_packet();
  if (establish_request) {
    set_has_establish_request();
    packet_.establish_request_ = establish_request;
  }
}

// optional .weizhu.SocketApiRequest api_request = 2;
inline bool SocketUpPacket::has_api_request() const {
  return packet_case() == kApiRequest;
}
inline void SocketUpPacket::set_has_api_request() {
  _oneof_case_[0] = kApiRequest;
}
inline void SocketUpPacket::clear_api_request() {
  if (has_api_request()) {
    delete packet_.api_request_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketApiRequest& SocketUpPacket::api_request() const {
  return has_api_request() ? *packet_.api_request_
                      : ::weizhu::SocketApiRequest::default_instance();
}
inline ::weizhu::SocketApiRequest* SocketUpPacket::mutable_api_request() {
  if (!has_api_request()) {
    clear_packet();
    set_has_api_request();
    packet_.api_request_ = new ::weizhu::SocketApiRequest;
  }
  return packet_.api_request_;
}
inline ::weizhu::SocketApiRequest* SocketUpPacket::release_api_request() {
  if (has_api_request()) {
    clear_has_packet();
    ::weizhu::SocketApiRequest* temp = packet_.api_request_;
    packet_.api_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketUpPacket::set_allocated_api_request(::weizhu::SocketApiRequest* api_request) {
  clear_packet();
  if (api_request) {
    set_has_api_request();
    packet_.api_request_ = api_request;
  }
}

// optional .weizhu.SocketPushAck push_ack = 3;
inline bool SocketUpPacket::has_push_ack() const {
  return packet_case() == kPushAck;
}
inline void SocketUpPacket::set_has_push_ack() {
  _oneof_case_[0] = kPushAck;
}
inline void SocketUpPacket::clear_push_ack() {
  if (has_push_ack()) {
    delete packet_.push_ack_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketPushAck& SocketUpPacket::push_ack() const {
  return has_push_ack() ? *packet_.push_ack_
                      : ::weizhu::SocketPushAck::default_instance();
}
inline ::weizhu::SocketPushAck* SocketUpPacket::mutable_push_ack() {
  if (!has_push_ack()) {
    clear_packet();
    set_has_push_ack();
    packet_.push_ack_ = new ::weizhu::SocketPushAck;
  }
  return packet_.push_ack_;
}
inline ::weizhu::SocketPushAck* SocketUpPacket::release_push_ack() {
  if (has_push_ack()) {
    clear_has_packet();
    ::weizhu::SocketPushAck* temp = packet_.push_ack_;
    packet_.push_ack_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketUpPacket::set_allocated_push_ack(::weizhu::SocketPushAck* push_ack) {
  clear_packet();
  if (push_ack) {
    set_has_push_ack();
    packet_.push_ack_ = push_ack;
  }
}

// optional .weizhu.SocketPing ping = 4;
inline bool SocketUpPacket::has_ping() const {
  return packet_case() == kPing;
}
inline void SocketUpPacket::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void SocketUpPacket::clear_ping() {
  if (has_ping()) {
    delete packet_.ping_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketPing& SocketUpPacket::ping() const {
  return has_ping() ? *packet_.ping_
                      : ::weizhu::SocketPing::default_instance();
}
inline ::weizhu::SocketPing* SocketUpPacket::mutable_ping() {
  if (!has_ping()) {
    clear_packet();
    set_has_ping();
    packet_.ping_ = new ::weizhu::SocketPing;
  }
  return packet_.ping_;
}
inline ::weizhu::SocketPing* SocketUpPacket::release_ping() {
  if (has_ping()) {
    clear_has_packet();
    ::weizhu::SocketPing* temp = packet_.ping_;
    packet_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketUpPacket::set_allocated_ping(::weizhu::SocketPing* ping) {
  clear_packet();
  if (ping) {
    set_has_ping();
    packet_.ping_ = ping;
  }
}

// optional .weizhu.SocketPong pong = 5;
inline bool SocketUpPacket::has_pong() const {
  return packet_case() == kPong;
}
inline void SocketUpPacket::set_has_pong() {
  _oneof_case_[0] = kPong;
}
inline void SocketUpPacket::clear_pong() {
  if (has_pong()) {
    delete packet_.pong_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketPong& SocketUpPacket::pong() const {
  return has_pong() ? *packet_.pong_
                      : ::weizhu::SocketPong::default_instance();
}
inline ::weizhu::SocketPong* SocketUpPacket::mutable_pong() {
  if (!has_pong()) {
    clear_packet();
    set_has_pong();
    packet_.pong_ = new ::weizhu::SocketPong;
  }
  return packet_.pong_;
}
inline ::weizhu::SocketPong* SocketUpPacket::release_pong() {
  if (has_pong()) {
    clear_has_packet();
    ::weizhu::SocketPong* temp = packet_.pong_;
    packet_.pong_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketUpPacket::set_allocated_pong(::weizhu::SocketPong* pong) {
  clear_packet();
  if (pong) {
    set_has_pong();
    packet_.pong_ = pong;
  }
}

inline bool SocketUpPacket::has_packet() {
  return packet_case() != PACKET_NOT_SET;
}
inline void SocketUpPacket::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline SocketUpPacket::PacketCase SocketUpPacket::packet_case() const {
  return SocketUpPacket::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SocketDownPacket

// optional .weizhu.SocketEstablishResponse establish_response = 1;
inline bool SocketDownPacket::has_establish_response() const {
  return packet_case() == kEstablishResponse;
}
inline void SocketDownPacket::set_has_establish_response() {
  _oneof_case_[0] = kEstablishResponse;
}
inline void SocketDownPacket::clear_establish_response() {
  if (has_establish_response()) {
    delete packet_.establish_response_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketEstablishResponse& SocketDownPacket::establish_response() const {
  return has_establish_response() ? *packet_.establish_response_
                      : ::weizhu::SocketEstablishResponse::default_instance();
}
inline ::weizhu::SocketEstablishResponse* SocketDownPacket::mutable_establish_response() {
  if (!has_establish_response()) {
    clear_packet();
    set_has_establish_response();
    packet_.establish_response_ = new ::weizhu::SocketEstablishResponse;
  }
  return packet_.establish_response_;
}
inline ::weizhu::SocketEstablishResponse* SocketDownPacket::release_establish_response() {
  if (has_establish_response()) {
    clear_has_packet();
    ::weizhu::SocketEstablishResponse* temp = packet_.establish_response_;
    packet_.establish_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketDownPacket::set_allocated_establish_response(::weizhu::SocketEstablishResponse* establish_response) {
  clear_packet();
  if (establish_response) {
    set_has_establish_response();
    packet_.establish_response_ = establish_response;
  }
}

// optional .weizhu.SocketApiResponse api_response = 2;
inline bool SocketDownPacket::has_api_response() const {
  return packet_case() == kApiResponse;
}
inline void SocketDownPacket::set_has_api_response() {
  _oneof_case_[0] = kApiResponse;
}
inline void SocketDownPacket::clear_api_response() {
  if (has_api_response()) {
    delete packet_.api_response_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketApiResponse& SocketDownPacket::api_response() const {
  return has_api_response() ? *packet_.api_response_
                      : ::weizhu::SocketApiResponse::default_instance();
}
inline ::weizhu::SocketApiResponse* SocketDownPacket::mutable_api_response() {
  if (!has_api_response()) {
    clear_packet();
    set_has_api_response();
    packet_.api_response_ = new ::weizhu::SocketApiResponse;
  }
  return packet_.api_response_;
}
inline ::weizhu::SocketApiResponse* SocketDownPacket::release_api_response() {
  if (has_api_response()) {
    clear_has_packet();
    ::weizhu::SocketApiResponse* temp = packet_.api_response_;
    packet_.api_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketDownPacket::set_allocated_api_response(::weizhu::SocketApiResponse* api_response) {
  clear_packet();
  if (api_response) {
    set_has_api_response();
    packet_.api_response_ = api_response;
  }
}

// optional .weizhu.SocketPushMsg push_msg = 3;
inline bool SocketDownPacket::has_push_msg() const {
  return packet_case() == kPushMsg;
}
inline void SocketDownPacket::set_has_push_msg() {
  _oneof_case_[0] = kPushMsg;
}
inline void SocketDownPacket::clear_push_msg() {
  if (has_push_msg()) {
    delete packet_.push_msg_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketPushMsg& SocketDownPacket::push_msg() const {
  return has_push_msg() ? *packet_.push_msg_
                      : ::weizhu::SocketPushMsg::default_instance();
}
inline ::weizhu::SocketPushMsg* SocketDownPacket::mutable_push_msg() {
  if (!has_push_msg()) {
    clear_packet();
    set_has_push_msg();
    packet_.push_msg_ = new ::weizhu::SocketPushMsg;
  }
  return packet_.push_msg_;
}
inline ::weizhu::SocketPushMsg* SocketDownPacket::release_push_msg() {
  if (has_push_msg()) {
    clear_has_packet();
    ::weizhu::SocketPushMsg* temp = packet_.push_msg_;
    packet_.push_msg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketDownPacket::set_allocated_push_msg(::weizhu::SocketPushMsg* push_msg) {
  clear_packet();
  if (push_msg) {
    set_has_push_msg();
    packet_.push_msg_ = push_msg;
  }
}

// optional .weizhu.SocketPing ping = 4;
inline bool SocketDownPacket::has_ping() const {
  return packet_case() == kPing;
}
inline void SocketDownPacket::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void SocketDownPacket::clear_ping() {
  if (has_ping()) {
    delete packet_.ping_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketPing& SocketDownPacket::ping() const {
  return has_ping() ? *packet_.ping_
                      : ::weizhu::SocketPing::default_instance();
}
inline ::weizhu::SocketPing* SocketDownPacket::mutable_ping() {
  if (!has_ping()) {
    clear_packet();
    set_has_ping();
    packet_.ping_ = new ::weizhu::SocketPing;
  }
  return packet_.ping_;
}
inline ::weizhu::SocketPing* SocketDownPacket::release_ping() {
  if (has_ping()) {
    clear_has_packet();
    ::weizhu::SocketPing* temp = packet_.ping_;
    packet_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketDownPacket::set_allocated_ping(::weizhu::SocketPing* ping) {
  clear_packet();
  if (ping) {
    set_has_ping();
    packet_.ping_ = ping;
  }
}

// optional .weizhu.SocketPong pong = 5;
inline bool SocketDownPacket::has_pong() const {
  return packet_case() == kPong;
}
inline void SocketDownPacket::set_has_pong() {
  _oneof_case_[0] = kPong;
}
inline void SocketDownPacket::clear_pong() {
  if (has_pong()) {
    delete packet_.pong_;
    clear_has_packet();
  }
}
inline const ::weizhu::SocketPong& SocketDownPacket::pong() const {
  return has_pong() ? *packet_.pong_
                      : ::weizhu::SocketPong::default_instance();
}
inline ::weizhu::SocketPong* SocketDownPacket::mutable_pong() {
  if (!has_pong()) {
    clear_packet();
    set_has_pong();
    packet_.pong_ = new ::weizhu::SocketPong;
  }
  return packet_.pong_;
}
inline ::weizhu::SocketPong* SocketDownPacket::release_pong() {
  if (has_pong()) {
    clear_has_packet();
    ::weizhu::SocketPong* temp = packet_.pong_;
    packet_.pong_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SocketDownPacket::set_allocated_pong(::weizhu::SocketPong* pong) {
  clear_packet();
  if (pong) {
    set_has_pong();
    packet_.pong_ = pong;
  }
}

inline bool SocketDownPacket::has_packet() {
  return packet_case() != PACKET_NOT_SET;
}
inline void SocketDownPacket::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline SocketDownPacket::PacketCase SocketDownPacket::packet_case() const {
  return SocketDownPacket::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SystemHead

// optional int64 company_id = 1;
inline bool SystemHead::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemHead::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemHead::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemHead::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 SystemHead::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.SystemHead.company_id)
  return company_id_;
}
inline void SystemHead::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.SystemHead.company_id)
}

// -------------------------------------------------------------------

// RequestHead

// required .weizhu.Session session = 1;
inline bool RequestHead::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHead::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHead::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHead::clear_session() {
  if (session_ != NULL) session_->::weizhu::Session::Clear();
  clear_has_session();
}
inline const ::weizhu::Session& RequestHead::session() const {
  // @@protoc_insertion_point(field_get:weizhu.RequestHead.session)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return session_ != NULL ? *session_ : *default_instance().session_;
#else
  return session_ != NULL ? *session_ : *default_instance_->session_;
#endif
}
inline ::weizhu::Session* RequestHead::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::weizhu::Session;
  // @@protoc_insertion_point(field_mutable:weizhu.RequestHead.session)
  return session_;
}
inline ::weizhu::Session* RequestHead::release_session() {
  clear_has_session();
  ::weizhu::Session* temp = session_;
  session_ = NULL;
  return temp;
}
inline void RequestHead::set_allocated_session(::weizhu::Session* session) {
  delete session_;
  session_ = session;
  if (session) {
    set_has_session();
  } else {
    clear_has_session();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.RequestHead.session)
}

// required .weizhu.Invoke invoke = 2;
inline bool RequestHead::has_invoke() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestHead::set_has_invoke() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestHead::clear_has_invoke() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestHead::clear_invoke() {
  if (invoke_ != NULL) invoke_->::weizhu::Invoke::Clear();
  clear_has_invoke();
}
inline const ::weizhu::Invoke& RequestHead::invoke() const {
  // @@protoc_insertion_point(field_get:weizhu.RequestHead.invoke)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invoke_ != NULL ? *invoke_ : *default_instance().invoke_;
#else
  return invoke_ != NULL ? *invoke_ : *default_instance_->invoke_;
#endif
}
inline ::weizhu::Invoke* RequestHead::mutable_invoke() {
  set_has_invoke();
  if (invoke_ == NULL) invoke_ = new ::weizhu::Invoke;
  // @@protoc_insertion_point(field_mutable:weizhu.RequestHead.invoke)
  return invoke_;
}
inline ::weizhu::Invoke* RequestHead::release_invoke() {
  clear_has_invoke();
  ::weizhu::Invoke* temp = invoke_;
  invoke_ = NULL;
  return temp;
}
inline void RequestHead::set_allocated_invoke(::weizhu::Invoke* invoke) {
  delete invoke_;
  invoke_ = invoke;
  if (invoke) {
    set_has_invoke();
  } else {
    clear_has_invoke();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.RequestHead.invoke)
}

// required .weizhu.Network network = 3;
inline bool RequestHead::has_network() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestHead::set_has_network() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestHead::clear_has_network() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestHead::clear_network() {
  if (network_ != NULL) network_->::weizhu::Network::Clear();
  clear_has_network();
}
inline const ::weizhu::Network& RequestHead::network() const {
  // @@protoc_insertion_point(field_get:weizhu.RequestHead.network)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return network_ != NULL ? *network_ : *default_instance().network_;
#else
  return network_ != NULL ? *network_ : *default_instance_->network_;
#endif
}
inline ::weizhu::Network* RequestHead::mutable_network() {
  set_has_network();
  if (network_ == NULL) network_ = new ::weizhu::Network;
  // @@protoc_insertion_point(field_mutable:weizhu.RequestHead.network)
  return network_;
}
inline ::weizhu::Network* RequestHead::release_network() {
  clear_has_network();
  ::weizhu::Network* temp = network_;
  network_ = NULL;
  return temp;
}
inline void RequestHead::set_allocated_network(::weizhu::Network* network) {
  delete network_;
  network_ = network;
  if (network) {
    set_has_network();
  } else {
    clear_has_network();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.RequestHead.network)
}

// optional .weizhu.Weizhu weizhu = 4;
inline bool RequestHead::has_weizhu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestHead::set_has_weizhu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestHead::clear_has_weizhu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestHead::clear_weizhu() {
  if (weizhu_ != NULL) weizhu_->::weizhu::Weizhu::Clear();
  clear_has_weizhu();
}
inline const ::weizhu::Weizhu& RequestHead::weizhu() const {
  // @@protoc_insertion_point(field_get:weizhu.RequestHead.weizhu)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weizhu_ != NULL ? *weizhu_ : *default_instance().weizhu_;
#else
  return weizhu_ != NULL ? *weizhu_ : *default_instance_->weizhu_;
#endif
}
inline ::weizhu::Weizhu* RequestHead::mutable_weizhu() {
  set_has_weizhu();
  if (weizhu_ == NULL) weizhu_ = new ::weizhu::Weizhu;
  // @@protoc_insertion_point(field_mutable:weizhu.RequestHead.weizhu)
  return weizhu_;
}
inline ::weizhu::Weizhu* RequestHead::release_weizhu() {
  clear_has_weizhu();
  ::weizhu::Weizhu* temp = weizhu_;
  weizhu_ = NULL;
  return temp;
}
inline void RequestHead::set_allocated_weizhu(::weizhu::Weizhu* weizhu) {
  delete weizhu_;
  weizhu_ = weizhu;
  if (weizhu) {
    set_has_weizhu();
  } else {
    clear_has_weizhu();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.RequestHead.weizhu)
}

// optional .weizhu.Android android = 5;
inline bool RequestHead::has_android() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestHead::set_has_android() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestHead::clear_has_android() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestHead::clear_android() {
  if (android_ != NULL) android_->::weizhu::Android::Clear();
  clear_has_android();
}
inline const ::weizhu::Android& RequestHead::android() const {
  // @@protoc_insertion_point(field_get:weizhu.RequestHead.android)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_ != NULL ? *android_ : *default_instance().android_;
#else
  return android_ != NULL ? *android_ : *default_instance_->android_;
#endif
}
inline ::weizhu::Android* RequestHead::mutable_android() {
  set_has_android();
  if (android_ == NULL) android_ = new ::weizhu::Android;
  // @@protoc_insertion_point(field_mutable:weizhu.RequestHead.android)
  return android_;
}
inline ::weizhu::Android* RequestHead::release_android() {
  clear_has_android();
  ::weizhu::Android* temp = android_;
  android_ = NULL;
  return temp;
}
inline void RequestHead::set_allocated_android(::weizhu::Android* android) {
  delete android_;
  android_ = android;
  if (android) {
    set_has_android();
  } else {
    clear_has_android();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.RequestHead.android)
}

// optional .weizhu.Iphone iphone = 6;
inline bool RequestHead::has_iphone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestHead::set_has_iphone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestHead::clear_has_iphone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestHead::clear_iphone() {
  if (iphone_ != NULL) iphone_->::weizhu::Iphone::Clear();
  clear_has_iphone();
}
inline const ::weizhu::Iphone& RequestHead::iphone() const {
  // @@protoc_insertion_point(field_get:weizhu.RequestHead.iphone)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return iphone_ != NULL ? *iphone_ : *default_instance().iphone_;
#else
  return iphone_ != NULL ? *iphone_ : *default_instance_->iphone_;
#endif
}
inline ::weizhu::Iphone* RequestHead::mutable_iphone() {
  set_has_iphone();
  if (iphone_ == NULL) iphone_ = new ::weizhu::Iphone;
  // @@protoc_insertion_point(field_mutable:weizhu.RequestHead.iphone)
  return iphone_;
}
inline ::weizhu::Iphone* RequestHead::release_iphone() {
  clear_has_iphone();
  ::weizhu::Iphone* temp = iphone_;
  iphone_ = NULL;
  return temp;
}
inline void RequestHead::set_allocated_iphone(::weizhu::Iphone* iphone) {
  delete iphone_;
  iphone_ = iphone;
  if (iphone) {
    set_has_iphone();
  } else {
    clear_has_iphone();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.RequestHead.iphone)
}

// optional .weizhu.WebMobile web_mobile = 7;
inline bool RequestHead::has_web_mobile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestHead::set_has_web_mobile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestHead::clear_has_web_mobile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestHead::clear_web_mobile() {
  if (web_mobile_ != NULL) web_mobile_->::weizhu::WebMobile::Clear();
  clear_has_web_mobile();
}
inline const ::weizhu::WebMobile& RequestHead::web_mobile() const {
  // @@protoc_insertion_point(field_get:weizhu.RequestHead.web_mobile)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return web_mobile_ != NULL ? *web_mobile_ : *default_instance().web_mobile_;
#else
  return web_mobile_ != NULL ? *web_mobile_ : *default_instance_->web_mobile_;
#endif
}
inline ::weizhu::WebMobile* RequestHead::mutable_web_mobile() {
  set_has_web_mobile();
  if (web_mobile_ == NULL) web_mobile_ = new ::weizhu::WebMobile;
  // @@protoc_insertion_point(field_mutable:weizhu.RequestHead.web_mobile)
  return web_mobile_;
}
inline ::weizhu::WebMobile* RequestHead::release_web_mobile() {
  clear_has_web_mobile();
  ::weizhu::WebMobile* temp = web_mobile_;
  web_mobile_ = NULL;
  return temp;
}
inline void RequestHead::set_allocated_web_mobile(::weizhu::WebMobile* web_mobile) {
  delete web_mobile_;
  web_mobile_ = web_mobile;
  if (web_mobile) {
    set_has_web_mobile();
  } else {
    clear_has_web_mobile();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.RequestHead.web_mobile)
}

// -------------------------------------------------------------------

// AnonymousHead

// optional int64 company_id = 1;
inline bool AnonymousHead::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnonymousHead::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnonymousHead::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnonymousHead::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 AnonymousHead::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.AnonymousHead.company_id)
  return company_id_;
}
inline void AnonymousHead::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.AnonymousHead.company_id)
}

// required .weizhu.Invoke invoke = 2;
inline bool AnonymousHead::has_invoke() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnonymousHead::set_has_invoke() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnonymousHead::clear_has_invoke() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnonymousHead::clear_invoke() {
  if (invoke_ != NULL) invoke_->::weizhu::Invoke::Clear();
  clear_has_invoke();
}
inline const ::weizhu::Invoke& AnonymousHead::invoke() const {
  // @@protoc_insertion_point(field_get:weizhu.AnonymousHead.invoke)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invoke_ != NULL ? *invoke_ : *default_instance().invoke_;
#else
  return invoke_ != NULL ? *invoke_ : *default_instance_->invoke_;
#endif
}
inline ::weizhu::Invoke* AnonymousHead::mutable_invoke() {
  set_has_invoke();
  if (invoke_ == NULL) invoke_ = new ::weizhu::Invoke;
  // @@protoc_insertion_point(field_mutable:weizhu.AnonymousHead.invoke)
  return invoke_;
}
inline ::weizhu::Invoke* AnonymousHead::release_invoke() {
  clear_has_invoke();
  ::weizhu::Invoke* temp = invoke_;
  invoke_ = NULL;
  return temp;
}
inline void AnonymousHead::set_allocated_invoke(::weizhu::Invoke* invoke) {
  delete invoke_;
  invoke_ = invoke;
  if (invoke) {
    set_has_invoke();
  } else {
    clear_has_invoke();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.AnonymousHead.invoke)
}

// required .weizhu.Network network = 3;
inline bool AnonymousHead::has_network() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnonymousHead::set_has_network() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnonymousHead::clear_has_network() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnonymousHead::clear_network() {
  if (network_ != NULL) network_->::weizhu::Network::Clear();
  clear_has_network();
}
inline const ::weizhu::Network& AnonymousHead::network() const {
  // @@protoc_insertion_point(field_get:weizhu.AnonymousHead.network)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return network_ != NULL ? *network_ : *default_instance().network_;
#else
  return network_ != NULL ? *network_ : *default_instance_->network_;
#endif
}
inline ::weizhu::Network* AnonymousHead::mutable_network() {
  set_has_network();
  if (network_ == NULL) network_ = new ::weizhu::Network;
  // @@protoc_insertion_point(field_mutable:weizhu.AnonymousHead.network)
  return network_;
}
inline ::weizhu::Network* AnonymousHead::release_network() {
  clear_has_network();
  ::weizhu::Network* temp = network_;
  network_ = NULL;
  return temp;
}
inline void AnonymousHead::set_allocated_network(::weizhu::Network* network) {
  delete network_;
  network_ = network;
  if (network) {
    set_has_network();
  } else {
    clear_has_network();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.AnonymousHead.network)
}

// optional .weizhu.Weizhu weizhu = 4;
inline bool AnonymousHead::has_weizhu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnonymousHead::set_has_weizhu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnonymousHead::clear_has_weizhu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnonymousHead::clear_weizhu() {
  if (weizhu_ != NULL) weizhu_->::weizhu::Weizhu::Clear();
  clear_has_weizhu();
}
inline const ::weizhu::Weizhu& AnonymousHead::weizhu() const {
  // @@protoc_insertion_point(field_get:weizhu.AnonymousHead.weizhu)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weizhu_ != NULL ? *weizhu_ : *default_instance().weizhu_;
#else
  return weizhu_ != NULL ? *weizhu_ : *default_instance_->weizhu_;
#endif
}
inline ::weizhu::Weizhu* AnonymousHead::mutable_weizhu() {
  set_has_weizhu();
  if (weizhu_ == NULL) weizhu_ = new ::weizhu::Weizhu;
  // @@protoc_insertion_point(field_mutable:weizhu.AnonymousHead.weizhu)
  return weizhu_;
}
inline ::weizhu::Weizhu* AnonymousHead::release_weizhu() {
  clear_has_weizhu();
  ::weizhu::Weizhu* temp = weizhu_;
  weizhu_ = NULL;
  return temp;
}
inline void AnonymousHead::set_allocated_weizhu(::weizhu::Weizhu* weizhu) {
  delete weizhu_;
  weizhu_ = weizhu;
  if (weizhu) {
    set_has_weizhu();
  } else {
    clear_has_weizhu();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.AnonymousHead.weizhu)
}

// optional .weizhu.Android android = 5;
inline bool AnonymousHead::has_android() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnonymousHead::set_has_android() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnonymousHead::clear_has_android() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnonymousHead::clear_android() {
  if (android_ != NULL) android_->::weizhu::Android::Clear();
  clear_has_android();
}
inline const ::weizhu::Android& AnonymousHead::android() const {
  // @@protoc_insertion_point(field_get:weizhu.AnonymousHead.android)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_ != NULL ? *android_ : *default_instance().android_;
#else
  return android_ != NULL ? *android_ : *default_instance_->android_;
#endif
}
inline ::weizhu::Android* AnonymousHead::mutable_android() {
  set_has_android();
  if (android_ == NULL) android_ = new ::weizhu::Android;
  // @@protoc_insertion_point(field_mutable:weizhu.AnonymousHead.android)
  return android_;
}
inline ::weizhu::Android* AnonymousHead::release_android() {
  clear_has_android();
  ::weizhu::Android* temp = android_;
  android_ = NULL;
  return temp;
}
inline void AnonymousHead::set_allocated_android(::weizhu::Android* android) {
  delete android_;
  android_ = android;
  if (android) {
    set_has_android();
  } else {
    clear_has_android();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.AnonymousHead.android)
}

// optional .weizhu.Iphone iphone = 6;
inline bool AnonymousHead::has_iphone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnonymousHead::set_has_iphone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnonymousHead::clear_has_iphone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnonymousHead::clear_iphone() {
  if (iphone_ != NULL) iphone_->::weizhu::Iphone::Clear();
  clear_has_iphone();
}
inline const ::weizhu::Iphone& AnonymousHead::iphone() const {
  // @@protoc_insertion_point(field_get:weizhu.AnonymousHead.iphone)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return iphone_ != NULL ? *iphone_ : *default_instance().iphone_;
#else
  return iphone_ != NULL ? *iphone_ : *default_instance_->iphone_;
#endif
}
inline ::weizhu::Iphone* AnonymousHead::mutable_iphone() {
  set_has_iphone();
  if (iphone_ == NULL) iphone_ = new ::weizhu::Iphone;
  // @@protoc_insertion_point(field_mutable:weizhu.AnonymousHead.iphone)
  return iphone_;
}
inline ::weizhu::Iphone* AnonymousHead::release_iphone() {
  clear_has_iphone();
  ::weizhu::Iphone* temp = iphone_;
  iphone_ = NULL;
  return temp;
}
inline void AnonymousHead::set_allocated_iphone(::weizhu::Iphone* iphone) {
  delete iphone_;
  iphone_ = iphone;
  if (iphone) {
    set_has_iphone();
  } else {
    clear_has_iphone();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.AnonymousHead.iphone)
}

// optional .weizhu.WebMobile web_mobile = 7;
inline bool AnonymousHead::has_web_mobile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnonymousHead::set_has_web_mobile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnonymousHead::clear_has_web_mobile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnonymousHead::clear_web_mobile() {
  if (web_mobile_ != NULL) web_mobile_->::weizhu::WebMobile::Clear();
  clear_has_web_mobile();
}
inline const ::weizhu::WebMobile& AnonymousHead::web_mobile() const {
  // @@protoc_insertion_point(field_get:weizhu.AnonymousHead.web_mobile)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return web_mobile_ != NULL ? *web_mobile_ : *default_instance().web_mobile_;
#else
  return web_mobile_ != NULL ? *web_mobile_ : *default_instance_->web_mobile_;
#endif
}
inline ::weizhu::WebMobile* AnonymousHead::mutable_web_mobile() {
  set_has_web_mobile();
  if (web_mobile_ == NULL) web_mobile_ = new ::weizhu::WebMobile;
  // @@protoc_insertion_point(field_mutable:weizhu.AnonymousHead.web_mobile)
  return web_mobile_;
}
inline ::weizhu::WebMobile* AnonymousHead::release_web_mobile() {
  clear_has_web_mobile();
  ::weizhu::WebMobile* temp = web_mobile_;
  web_mobile_ = NULL;
  return temp;
}
inline void AnonymousHead::set_allocated_web_mobile(::weizhu::WebMobile* web_mobile) {
  delete web_mobile_;
  web_mobile_ = web_mobile;
  if (web_mobile) {
    set_has_web_mobile();
  } else {
    clear_has_web_mobile();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.AnonymousHead.web_mobile)
}

// -------------------------------------------------------------------

// EmptyRequest

// -------------------------------------------------------------------

// EmptyResponse

// -------------------------------------------------------------------

// TestPush

// required string message = 1;
inline bool TestPush::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestPush::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestPush::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestPush::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& TestPush::message() const {
  // @@protoc_insertion_point(field_get:weizhu.TestPush.message)
  return *message_;
}
inline void TestPush::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.TestPush.message)
}
inline void TestPush::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.TestPush.message)
}
inline void TestPush::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.TestPush.message)
}
inline ::std::string* TestPush::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.TestPush.message)
  return message_;
}
inline ::std::string* TestPush::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TestPush::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.TestPush.message)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace weizhu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_weizhu_2eproto__INCLUDED
