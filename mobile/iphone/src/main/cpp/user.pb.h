// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "weizhu.pb.h"
// @@protoc_insertion_point(includes)

namespace weizhu {
namespace user {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class Team;
class Position;
class Level;
class UserBase;
class UserMark;
class UserTeam;
class UserExtends;
class UserExperience;
class UserAbilityTag;
class User;
class GetUserByIdRequest;
class GetUserByMobileNoRequest;
class GetUserResponse;
class GetTeamRequest;
class GetTeamResponse;
class UpdateUserAvatarRequest;
class UpdateUserAvatarResponse;
class UpdateUserSignatureRequest;
class UpdateUserSignatureResponse;
class UpdateUserInterestRequest;
class UpdateUserInterestResponse;
class GetUserExperienceRequest;
class GetUserExperienceResponse;
class CreateUserExperienceRequest;
class CreateUserExperienceResponse;
class UpdateUserExperienceRequest;
class UpdateUserExperienceResponse;
class DeleteUserExperienceRequest;
class DeleteUserExperienceResponse;
class MarkUserNameRequest;
class MarkUserNameResponse;
class MarkUserStarRequest;
class MarkUserStarResponse;
class GetMarkStarUserRequest;
class GetMarkStarUserResponse;
class GetUserAbilityTagRequest;
class GetUserAbilityTagResponse;
class TagUserAbilityRequest;
class TagUserAbilityResponse;
class CreateAbilityTagRequest;
class CreateAbilityTagResponse;
class DeleteAbilityTagRequest;
class GetRandomAbilityTagUserRequest;
class GetRandomAbilityTagUserResponse;
class GetAbilityTagUserIdRequest;
class GetAbilityTagUserIdResponse;
class GetAllPositionRequest;
class GetAllPositionResponse;
class GetAllLevelRequest;
class GetAllLevelResponse;
class SearchUserRequest;
class SearchUserResponse;

enum UserBase_Gender {
  UserBase_Gender_MALE = 0,
  UserBase_Gender_FEMALE = 1
};
bool UserBase_Gender_IsValid(int value);
const UserBase_Gender UserBase_Gender_Gender_MIN = UserBase_Gender_MALE;
const UserBase_Gender UserBase_Gender_Gender_MAX = UserBase_Gender_FEMALE;
const int UserBase_Gender_Gender_ARRAYSIZE = UserBase_Gender_Gender_MAX + 1;

enum UserBase_State {
  UserBase_State_NORMAL = 0,
  UserBase_State_DISABLE = 1,
  UserBase_State_DELETE = 2,
  UserBase_State_APPROVE = 3
};
bool UserBase_State_IsValid(int value);
const UserBase_State UserBase_State_State_MIN = UserBase_State_NORMAL;
const UserBase_State UserBase_State_State_MAX = UserBase_State_APPROVE;
const int UserBase_State_State_ARRAYSIZE = UserBase_State_State_MAX + 1;

enum UpdateUserAvatarResponse_Result {
  UpdateUserAvatarResponse_Result_SUCC = 0,
  UpdateUserAvatarResponse_Result_FAIL_AVATAR_INVALID = 1,
  UpdateUserAvatarResponse_Result_FAIL_UNKNOWN = 99
};
bool UpdateUserAvatarResponse_Result_IsValid(int value);
const UpdateUserAvatarResponse_Result UpdateUserAvatarResponse_Result_Result_MIN = UpdateUserAvatarResponse_Result_SUCC;
const UpdateUserAvatarResponse_Result UpdateUserAvatarResponse_Result_Result_MAX = UpdateUserAvatarResponse_Result_FAIL_UNKNOWN;
const int UpdateUserAvatarResponse_Result_Result_ARRAYSIZE = UpdateUserAvatarResponse_Result_Result_MAX + 1;

enum UpdateUserSignatureResponse_Result {
  UpdateUserSignatureResponse_Result_SUCC = 0,
  UpdateUserSignatureResponse_Result_FAIL_SIGNATURE_INVALID = 1,
  UpdateUserSignatureResponse_Result_FAIL_UNKNOWN = 99
};
bool UpdateUserSignatureResponse_Result_IsValid(int value);
const UpdateUserSignatureResponse_Result UpdateUserSignatureResponse_Result_Result_MIN = UpdateUserSignatureResponse_Result_SUCC;
const UpdateUserSignatureResponse_Result UpdateUserSignatureResponse_Result_Result_MAX = UpdateUserSignatureResponse_Result_FAIL_UNKNOWN;
const int UpdateUserSignatureResponse_Result_Result_ARRAYSIZE = UpdateUserSignatureResponse_Result_Result_MAX + 1;

enum UpdateUserInterestResponse_Result {
  UpdateUserInterestResponse_Result_SUCC = 0,
  UpdateUserInterestResponse_Result_FAIL_INTEREST_INVALID = 1,
  UpdateUserInterestResponse_Result_FAIL_UNKNOWN = 99
};
bool UpdateUserInterestResponse_Result_IsValid(int value);
const UpdateUserInterestResponse_Result UpdateUserInterestResponse_Result_Result_MIN = UpdateUserInterestResponse_Result_SUCC;
const UpdateUserInterestResponse_Result UpdateUserInterestResponse_Result_Result_MAX = UpdateUserInterestResponse_Result_FAIL_UNKNOWN;
const int UpdateUserInterestResponse_Result_Result_ARRAYSIZE = UpdateUserInterestResponse_Result_Result_MAX + 1;

enum CreateUserExperienceResponse_Result {
  CreateUserExperienceResponse_Result_SUCC = 0,
  CreateUserExperienceResponse_Result_FAIL_EXPERIENCE_CONTENT_INVALID = 1,
  CreateUserExperienceResponse_Result_FAIL_EXPERIENCE_NUM_LIMIT = 2,
  CreateUserExperienceResponse_Result_FAIL_UNKNOWN = 99
};
bool CreateUserExperienceResponse_Result_IsValid(int value);
const CreateUserExperienceResponse_Result CreateUserExperienceResponse_Result_Result_MIN = CreateUserExperienceResponse_Result_SUCC;
const CreateUserExperienceResponse_Result CreateUserExperienceResponse_Result_Result_MAX = CreateUserExperienceResponse_Result_FAIL_UNKNOWN;
const int CreateUserExperienceResponse_Result_Result_ARRAYSIZE = CreateUserExperienceResponse_Result_Result_MAX + 1;

enum UpdateUserExperienceResponse_Result {
  UpdateUserExperienceResponse_Result_SUCC = 0,
  UpdateUserExperienceResponse_Result_FAIL_EXPERIENCE_ID_INVALID = 1,
  UpdateUserExperienceResponse_Result_FAIL_EXPERIENCE_CONTENT_INVALID = 2,
  UpdateUserExperienceResponse_Result_FAIL_UNKNOWN = 99
};
bool UpdateUserExperienceResponse_Result_IsValid(int value);
const UpdateUserExperienceResponse_Result UpdateUserExperienceResponse_Result_Result_MIN = UpdateUserExperienceResponse_Result_SUCC;
const UpdateUserExperienceResponse_Result UpdateUserExperienceResponse_Result_Result_MAX = UpdateUserExperienceResponse_Result_FAIL_UNKNOWN;
const int UpdateUserExperienceResponse_Result_Result_ARRAYSIZE = UpdateUserExperienceResponse_Result_Result_MAX + 1;

enum DeleteUserExperienceResponse_Result {
  DeleteUserExperienceResponse_Result_SUCC = 0,
  DeleteUserExperienceResponse_Result_FAIL_EXPERIENCE_ID_INVALID = 1,
  DeleteUserExperienceResponse_Result_FAIL_UNKNOWN = 99
};
bool DeleteUserExperienceResponse_Result_IsValid(int value);
const DeleteUserExperienceResponse_Result DeleteUserExperienceResponse_Result_Result_MIN = DeleteUserExperienceResponse_Result_SUCC;
const DeleteUserExperienceResponse_Result DeleteUserExperienceResponse_Result_Result_MAX = DeleteUserExperienceResponse_Result_FAIL_UNKNOWN;
const int DeleteUserExperienceResponse_Result_Result_ARRAYSIZE = DeleteUserExperienceResponse_Result_Result_MAX + 1;

enum MarkUserNameResponse_Result {
  MarkUserNameResponse_Result_SUCC = 0,
  MarkUserNameResponse_Result_FAIL_USER_NOT_EXSIT = 1,
  MarkUserNameResponse_Result_FAIL_MARK_SELF = 2,
  MarkUserNameResponse_Result_FAIL_MARK_NAME_INVALID = 3,
  MarkUserNameResponse_Result_FAIL_UNKNOWN = 99
};
bool MarkUserNameResponse_Result_IsValid(int value);
const MarkUserNameResponse_Result MarkUserNameResponse_Result_Result_MIN = MarkUserNameResponse_Result_SUCC;
const MarkUserNameResponse_Result MarkUserNameResponse_Result_Result_MAX = MarkUserNameResponse_Result_FAIL_UNKNOWN;
const int MarkUserNameResponse_Result_Result_ARRAYSIZE = MarkUserNameResponse_Result_Result_MAX + 1;

enum MarkUserStarResponse_Result {
  MarkUserStarResponse_Result_SUCC = 0,
  MarkUserStarResponse_Result_FAIL_USER_NOT_EXSIT = 1,
  MarkUserStarResponse_Result_FAIL_MARK_SELF = 2,
  MarkUserStarResponse_Result_FAIL_MARK_STAR_NUM_LIMIT = 3,
  MarkUserStarResponse_Result_FAIL_UNKNOWN = 99
};
bool MarkUserStarResponse_Result_IsValid(int value);
const MarkUserStarResponse_Result MarkUserStarResponse_Result_Result_MIN = MarkUserStarResponse_Result_SUCC;
const MarkUserStarResponse_Result MarkUserStarResponse_Result_Result_MAX = MarkUserStarResponse_Result_FAIL_UNKNOWN;
const int MarkUserStarResponse_Result_Result_ARRAYSIZE = MarkUserStarResponse_Result_Result_MAX + 1;

enum TagUserAbilityResponse_Result {
  TagUserAbilityResponse_Result_SUCC = 0,
  TagUserAbilityResponse_Result_FAIL_USER_NOT_EXSIT = 1,
  TagUserAbilityResponse_Result_FAIL_TAG_SELF = 2,
  TagUserAbilityResponse_Result_FAIL_TAG_NOT_EXIST = 3,
  TagUserAbilityResponse_Result_FAIL_UNKNOWN = 99
};
bool TagUserAbilityResponse_Result_IsValid(int value);
const TagUserAbilityResponse_Result TagUserAbilityResponse_Result_Result_MIN = TagUserAbilityResponse_Result_SUCC;
const TagUserAbilityResponse_Result TagUserAbilityResponse_Result_Result_MAX = TagUserAbilityResponse_Result_FAIL_UNKNOWN;
const int TagUserAbilityResponse_Result_Result_ARRAYSIZE = TagUserAbilityResponse_Result_Result_MAX + 1;

enum CreateAbilityTagResponse_Result {
  CreateAbilityTagResponse_Result_SUCC = 0,
  CreateAbilityTagResponse_Result_FAIL_USER_NOT_EXSIT = 1,
  CreateAbilityTagResponse_Result_FAIL_TAG_NAME_INVALID = 2,
  CreateAbilityTagResponse_Result_FAIL_TAG_NUM_LIMIT = 3,
  CreateAbilityTagResponse_Result_FAIL_TAG_EXIST = 4,
  CreateAbilityTagResponse_Result_FAIL_UNKNOWN = 99
};
bool CreateAbilityTagResponse_Result_IsValid(int value);
const CreateAbilityTagResponse_Result CreateAbilityTagResponse_Result_Result_MIN = CreateAbilityTagResponse_Result_SUCC;
const CreateAbilityTagResponse_Result CreateAbilityTagResponse_Result_Result_MAX = CreateAbilityTagResponse_Result_FAIL_UNKNOWN;
const int CreateAbilityTagResponse_Result_Result_ARRAYSIZE = CreateAbilityTagResponse_Result_Result_MAX + 1;

enum State {
  NORMAL = 0,
  DISABLE = 1,
  DELETE = 2
};
bool State_IsValid(int value);
const State State_MIN = NORMAL;
const State State_MAX = DELETE;
const int State_ARRAYSIZE = State_MAX + 1;

// ===================================================================

class Team : public ::google::protobuf::MessageLite {
 public:
  Team();
  virtual ~Team();

  Team(const Team& from);

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Team& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Team* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Team* other);

  // implements Message ----------------------------------------------

  Team* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline ::google::protobuf::int32 team_id() const;
  inline void set_team_id(::google::protobuf::int32 value);

  // required string team_name = 2;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 2;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const char* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // optional int32 parent_team_id = 3;
  inline bool has_parent_team_id() const;
  inline void clear_parent_team_id();
  static const int kParentTeamIdFieldNumber = 3;
  inline ::google::protobuf::int32 parent_team_id() const;
  inline void set_parent_team_id(::google::protobuf::int32 value);

  // optional .weizhu.user.State state = 95 [default = NORMAL];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 95;
  inline ::weizhu::user::State state() const;
  inline void set_state(::weizhu::user::State value);

  // optional int64 create_admin_id = 96;
  inline bool has_create_admin_id() const;
  inline void clear_create_admin_id();
  static const int kCreateAdminIdFieldNumber = 96;
  inline ::google::protobuf::int64 create_admin_id() const;
  inline void set_create_admin_id(::google::protobuf::int64 value);

  // optional int32 create_time = 97;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 97;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional int64 update_admin_id = 98;
  inline bool has_update_admin_id() const;
  inline void clear_update_admin_id();
  static const int kUpdateAdminIdFieldNumber = 98;
  inline ::google::protobuf::int64 update_admin_id() const;
  inline void set_update_admin_id(::google::protobuf::int64 value);

  // optional int32 update_time = 99;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 99;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.Team)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_team_name();
  inline void clear_has_team_name();
  inline void set_has_parent_team_id();
  inline void clear_has_parent_team_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_create_admin_id();
  inline void clear_has_create_admin_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_update_admin_id();
  inline void clear_has_update_admin_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* team_name_;
  ::google::protobuf::int32 team_id_;
  ::google::protobuf::int32 parent_team_id_;
  ::google::protobuf::int64 create_admin_id_;
  int state_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int64 update_admin_id_;
  ::google::protobuf::int32 update_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static Team* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::MessageLite {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Position& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Position* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 position_id = 1;
  inline bool has_position_id() const;
  inline void clear_position_id();
  static const int kPositionIdFieldNumber = 1;
  inline ::google::protobuf::int32 position_id() const;
  inline void set_position_id(::google::protobuf::int32 value);

  // required string position_name = 2;
  inline bool has_position_name() const;
  inline void clear_position_name();
  static const int kPositionNameFieldNumber = 2;
  inline const ::std::string& position_name() const;
  inline void set_position_name(const ::std::string& value);
  inline void set_position_name(const char* value);
  inline void set_position_name(const char* value, size_t size);
  inline ::std::string* mutable_position_name();
  inline ::std::string* release_position_name();
  inline void set_allocated_position_name(::std::string* position_name);

  // required string position_desc = 3;
  inline bool has_position_desc() const;
  inline void clear_position_desc();
  static const int kPositionDescFieldNumber = 3;
  inline const ::std::string& position_desc() const;
  inline void set_position_desc(const ::std::string& value);
  inline void set_position_desc(const char* value);
  inline void set_position_desc(const char* value, size_t size);
  inline ::std::string* mutable_position_desc();
  inline ::std::string* release_position_desc();
  inline void set_allocated_position_desc(::std::string* position_desc);

  // optional .weizhu.user.State state = 95 [default = NORMAL];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 95;
  inline ::weizhu::user::State state() const;
  inline void set_state(::weizhu::user::State value);

  // optional int64 create_admin_id = 96;
  inline bool has_create_admin_id() const;
  inline void clear_create_admin_id();
  static const int kCreateAdminIdFieldNumber = 96;
  inline ::google::protobuf::int64 create_admin_id() const;
  inline void set_create_admin_id(::google::protobuf::int64 value);

  // optional int32 create_time = 97;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 97;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional int64 update_admin_id = 98;
  inline bool has_update_admin_id() const;
  inline void clear_update_admin_id();
  static const int kUpdateAdminIdFieldNumber = 98;
  inline ::google::protobuf::int64 update_admin_id() const;
  inline void set_update_admin_id(::google::protobuf::int64 value);

  // optional int32 update_time = 99;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 99;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.Position)
 private:
  inline void set_has_position_id();
  inline void clear_has_position_id();
  inline void set_has_position_name();
  inline void clear_has_position_name();
  inline void set_has_position_desc();
  inline void clear_has_position_desc();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_create_admin_id();
  inline void clear_has_create_admin_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_update_admin_id();
  inline void clear_has_update_admin_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* position_name_;
  ::google::protobuf::int32 position_id_;
  int state_;
  ::std::string* position_desc_;
  ::google::protobuf::int64 create_admin_id_;
  ::google::protobuf::int64 update_admin_id_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int32 update_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Level : public ::google::protobuf::MessageLite {
 public:
  Level();
  virtual ~Level();

  Level(const Level& from);

  inline Level& operator=(const Level& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Level& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Level* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Level* other);

  // implements Message ----------------------------------------------

  Level* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Level& from);
  void MergeFrom(const Level& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level_id = 1;
  inline bool has_level_id() const;
  inline void clear_level_id();
  static const int kLevelIdFieldNumber = 1;
  inline ::google::protobuf::int32 level_id() const;
  inline void set_level_id(::google::protobuf::int32 value);

  // required string level_name = 2;
  inline bool has_level_name() const;
  inline void clear_level_name();
  static const int kLevelNameFieldNumber = 2;
  inline const ::std::string& level_name() const;
  inline void set_level_name(const ::std::string& value);
  inline void set_level_name(const char* value);
  inline void set_level_name(const char* value, size_t size);
  inline ::std::string* mutable_level_name();
  inline ::std::string* release_level_name();
  inline void set_allocated_level_name(::std::string* level_name);

  // optional .weizhu.user.State state = 95 [default = NORMAL];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 95;
  inline ::weizhu::user::State state() const;
  inline void set_state(::weizhu::user::State value);

  // optional int64 create_admin_id = 96;
  inline bool has_create_admin_id() const;
  inline void clear_create_admin_id();
  static const int kCreateAdminIdFieldNumber = 96;
  inline ::google::protobuf::int64 create_admin_id() const;
  inline void set_create_admin_id(::google::protobuf::int64 value);

  // optional int32 create_time = 97;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 97;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional int64 update_admin_id = 98;
  inline bool has_update_admin_id() const;
  inline void clear_update_admin_id();
  static const int kUpdateAdminIdFieldNumber = 98;
  inline ::google::protobuf::int64 update_admin_id() const;
  inline void set_update_admin_id(::google::protobuf::int64 value);

  // optional int32 update_time = 99;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 99;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.Level)
 private:
  inline void set_has_level_id();
  inline void clear_has_level_id();
  inline void set_has_level_name();
  inline void clear_has_level_name();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_create_admin_id();
  inline void clear_has_create_admin_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_update_admin_id();
  inline void clear_has_update_admin_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* level_name_;
  ::google::protobuf::int32 level_id_;
  int state_;
  ::google::protobuf::int64 create_admin_id_;
  ::google::protobuf::int64 update_admin_id_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int32 update_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static Level* default_instance_;
};
// -------------------------------------------------------------------

class UserBase : public ::google::protobuf::MessageLite {
 public:
  UserBase();
  virtual ~UserBase();

  UserBase(const UserBase& from);

  inline UserBase& operator=(const UserBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserBase& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserBase* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserBase* other);

  // implements Message ----------------------------------------------

  UserBase* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserBase& from);
  void MergeFrom(const UserBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UserBase_Gender Gender;
  static const Gender MALE = UserBase_Gender_MALE;
  static const Gender FEMALE = UserBase_Gender_FEMALE;
  static inline bool Gender_IsValid(int value) {
    return UserBase_Gender_IsValid(value);
  }
  static const Gender Gender_MIN =
    UserBase_Gender_Gender_MIN;
  static const Gender Gender_MAX =
    UserBase_Gender_Gender_MAX;
  static const int Gender_ARRAYSIZE =
    UserBase_Gender_Gender_ARRAYSIZE;

  typedef UserBase_State State;
  static const State NORMAL = UserBase_State_NORMAL;
  static const State DISABLE = UserBase_State_DISABLE;
  static const State DELETE = UserBase_State_DELETE;
  static const State APPROVE = UserBase_State_APPROVE;
  static inline bool State_IsValid(int value) {
    return UserBase_State_IsValid(value);
  }
  static const State State_MIN =
    UserBase_State_State_MIN;
  static const State State_MAX =
    UserBase_State_State_MAX;
  static const int State_ARRAYSIZE =
    UserBase_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required string raw_id = 2;
  inline bool has_raw_id() const;
  inline void clear_raw_id();
  static const int kRawIdFieldNumber = 2;
  inline const ::std::string& raw_id() const;
  inline void set_raw_id(const ::std::string& value);
  inline void set_raw_id(const char* value);
  inline void set_raw_id(const char* value, size_t size);
  inline ::std::string* mutable_raw_id();
  inline ::std::string* release_raw_id();
  inline void set_allocated_raw_id(::std::string* raw_id);

  // required string user_name = 3;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional .weizhu.user.UserBase.Gender gender = 4;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 4;
  inline ::weizhu::user::UserBase_Gender gender() const;
  inline void set_gender(::weizhu::user::UserBase_Gender value);

  // optional string avatar = 5;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 5;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // repeated string mobile_no = 6;
  inline int mobile_no_size() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 6;
  inline const ::std::string& mobile_no(int index) const;
  inline ::std::string* mutable_mobile_no(int index);
  inline void set_mobile_no(int index, const ::std::string& value);
  inline void set_mobile_no(int index, const char* value);
  inline void set_mobile_no(int index, const char* value, size_t size);
  inline ::std::string* add_mobile_no();
  inline void add_mobile_no(const ::std::string& value);
  inline void add_mobile_no(const char* value);
  inline void add_mobile_no(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mobile_no() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mobile_no();

  // repeated string phone_no = 7;
  inline int phone_no_size() const;
  inline void clear_phone_no();
  static const int kPhoneNoFieldNumber = 7;
  inline const ::std::string& phone_no(int index) const;
  inline ::std::string* mutable_phone_no(int index);
  inline void set_phone_no(int index, const ::std::string& value);
  inline void set_phone_no(int index, const char* value);
  inline void set_phone_no(int index, const char* value, size_t size);
  inline ::std::string* add_phone_no();
  inline void add_phone_no(const ::std::string& value);
  inline void add_phone_no(const char* value);
  inline void add_phone_no(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& phone_no() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_phone_no();

  // optional string email = 8;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 8;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string signature = 9;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 9;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional string interest = 10;
  inline bool has_interest() const;
  inline void clear_interest();
  static const int kInterestFieldNumber = 10;
  inline const ::std::string& interest() const;
  inline void set_interest(const ::std::string& value);
  inline void set_interest(const char* value);
  inline void set_interest(const char* value, size_t size);
  inline ::std::string* mutable_interest();
  inline ::std::string* release_interest();
  inline void set_allocated_interest(::std::string* interest);

  // optional bool is_expert = 11;
  inline bool has_is_expert() const;
  inline void clear_is_expert();
  static const int kIsExpertFieldNumber = 11;
  inline bool is_expert() const;
  inline void set_is_expert(bool value);

  // optional int32 level_id = 12;
  inline bool has_level_id() const;
  inline void clear_level_id();
  static const int kLevelIdFieldNumber = 12;
  inline ::google::protobuf::int32 level_id() const;
  inline void set_level_id(::google::protobuf::int32 value);

  // optional .weizhu.user.UserBase.State state = 13 [default = NORMAL];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 13;
  inline ::weizhu::user::UserBase_State state() const;
  inline void set_state(::weizhu::user::UserBase_State value);

  // optional int64 create_admin_id = 14;
  inline bool has_create_admin_id() const;
  inline void clear_create_admin_id();
  static const int kCreateAdminIdFieldNumber = 14;
  inline ::google::protobuf::int64 create_admin_id() const;
  inline void set_create_admin_id(::google::protobuf::int64 value);

  // optional int32 create_time = 15;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 15;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional int64 update_admin_id = 16;
  inline bool has_update_admin_id() const;
  inline void clear_update_admin_id();
  static const int kUpdateAdminIdFieldNumber = 16;
  inline ::google::protobuf::int64 update_admin_id() const;
  inline void set_update_admin_id(::google::protobuf::int64 value);

  // optional int32 update_time = 17;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 17;
  inline ::google::protobuf::int32 update_time() const;
  inline void set_update_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.UserBase)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_raw_id();
  inline void clear_has_raw_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_interest();
  inline void clear_has_interest();
  inline void set_has_is_expert();
  inline void clear_has_is_expert();
  inline void set_has_level_id();
  inline void clear_has_level_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_create_admin_id();
  inline void clear_has_create_admin_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_update_admin_id();
  inline void clear_has_update_admin_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* raw_id_;
  ::std::string* user_name_;
  ::std::string* avatar_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mobile_no_;
  ::google::protobuf::RepeatedPtrField< ::std::string> phone_no_;
  int gender_;
  bool is_expert_;
  ::std::string* email_;
  ::std::string* signature_;
  ::std::string* interest_;
  ::google::protobuf::int32 level_id_;
  int state_;
  ::google::protobuf::int64 create_admin_id_;
  ::google::protobuf::int64 update_admin_id_;
  ::google::protobuf::int32 create_time_;
  ::google::protobuf::int32 update_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserBase* default_instance_;
};
// -------------------------------------------------------------------

class UserMark : public ::google::protobuf::MessageLite {
 public:
  UserMark();
  virtual ~UserMark();

  UserMark(const UserMark& from);

  inline UserMark& operator=(const UserMark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserMark& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserMark* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserMark* other);

  // implements Message ----------------------------------------------

  UserMark* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserMark& from);
  void MergeFrom(const UserMark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required bool is_star = 2;
  inline bool has_is_star() const;
  inline void clear_is_star();
  static const int kIsStarFieldNumber = 2;
  inline bool is_star() const;
  inline void set_is_star(bool value);

  // optional int32 star_time = 3;
  inline bool has_star_time() const;
  inline void clear_star_time();
  static const int kStarTimeFieldNumber = 3;
  inline ::google::protobuf::int32 star_time() const;
  inline void set_star_time(::google::protobuf::int32 value);

  // optional string mark_name = 4;
  inline bool has_mark_name() const;
  inline void clear_mark_name();
  static const int kMarkNameFieldNumber = 4;
  inline const ::std::string& mark_name() const;
  inline void set_mark_name(const ::std::string& value);
  inline void set_mark_name(const char* value);
  inline void set_mark_name(const char* value, size_t size);
  inline ::std::string* mutable_mark_name();
  inline ::std::string* release_mark_name();
  inline void set_allocated_mark_name(::std::string* mark_name);

  // @@protoc_insertion_point(class_scope:weizhu.user.UserMark)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_is_star();
  inline void clear_has_is_star();
  inline void set_has_star_time();
  inline void clear_has_star_time();
  inline void set_has_mark_name();
  inline void clear_has_mark_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  bool is_star_;
  ::google::protobuf::int32 star_time_;
  ::std::string* mark_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserMark* default_instance_;
};
// -------------------------------------------------------------------

class UserTeam : public ::google::protobuf::MessageLite {
 public:
  UserTeam();
  virtual ~UserTeam();

  UserTeam(const UserTeam& from);

  inline UserTeam& operator=(const UserTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserTeam& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserTeam* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserTeam* other);

  // implements Message ----------------------------------------------

  UserTeam* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserTeam& from);
  void MergeFrom(const UserTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required int32 team_id = 2;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 2;
  inline ::google::protobuf::int32 team_id() const;
  inline void set_team_id(::google::protobuf::int32 value);

  // optional int32 position_id = 3;
  inline bool has_position_id() const;
  inline void clear_position_id();
  static const int kPositionIdFieldNumber = 3;
  inline ::google::protobuf::int32 position_id() const;
  inline void set_position_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.UserTeam)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_position_id();
  inline void clear_has_position_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::google::protobuf::int32 team_id_;
  ::google::protobuf::int32 position_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserTeam* default_instance_;
};
// -------------------------------------------------------------------

class UserExtends : public ::google::protobuf::MessageLite {
 public:
  UserExtends();
  virtual ~UserExtends();

  UserExtends(const UserExtends& from);

  inline UserExtends& operator=(const UserExtends& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserExtends& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserExtends* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserExtends* other);

  // implements Message ----------------------------------------------

  UserExtends* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserExtends& from);
  void MergeFrom(const UserExtends& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:weizhu.user.UserExtends)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* name_;
  ::std::string* value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserExtends* default_instance_;
};
// -------------------------------------------------------------------

class UserExperience : public ::google::protobuf::MessageLite {
 public:
  UserExperience();
  virtual ~UserExperience();

  UserExperience(const UserExperience& from);

  inline UserExperience& operator=(const UserExperience& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserExperience& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserExperience* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserExperience* other);

  // implements Message ----------------------------------------------

  UserExperience* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserExperience& from);
  void MergeFrom(const UserExperience& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 experience_id = 1;
  inline bool has_experience_id() const;
  inline void clear_experience_id();
  static const int kExperienceIdFieldNumber = 1;
  inline ::google::protobuf::int32 experience_id() const;
  inline void set_experience_id(::google::protobuf::int32 value);

  // required string experience_content = 2;
  inline bool has_experience_content() const;
  inline void clear_experience_content();
  static const int kExperienceContentFieldNumber = 2;
  inline const ::std::string& experience_content() const;
  inline void set_experience_content(const ::std::string& value);
  inline void set_experience_content(const char* value);
  inline void set_experience_content(const char* value, size_t size);
  inline ::std::string* mutable_experience_content();
  inline ::std::string* release_experience_content();
  inline void set_allocated_experience_content(::std::string* experience_content);

  // @@protoc_insertion_point(class_scope:weizhu.user.UserExperience)
 private:
  inline void set_has_experience_id();
  inline void clear_has_experience_id();
  inline void set_has_experience_content();
  inline void clear_has_experience_content();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* experience_content_;
  ::google::protobuf::int32 experience_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserExperience* default_instance_;
};
// -------------------------------------------------------------------

class UserAbilityTag : public ::google::protobuf::MessageLite {
 public:
  UserAbilityTag();
  virtual ~UserAbilityTag();

  UserAbilityTag(const UserAbilityTag& from);

  inline UserAbilityTag& operator=(const UserAbilityTag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserAbilityTag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserAbilityTag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserAbilityTag* other);

  // implements Message ----------------------------------------------

  UserAbilityTag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserAbilityTag& from);
  void MergeFrom(const UserAbilityTag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required string tag_name = 2;
  inline bool has_tag_name() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 2;
  inline const ::std::string& tag_name() const;
  inline void set_tag_name(const ::std::string& value);
  inline void set_tag_name(const char* value);
  inline void set_tag_name(const char* value, size_t size);
  inline ::std::string* mutable_tag_name();
  inline ::std::string* release_tag_name();
  inline void set_allocated_tag_name(::std::string* tag_name);

  // required int32 tag_time = 3;
  inline bool has_tag_time() const;
  inline void clear_tag_time();
  static const int kTagTimeFieldNumber = 3;
  inline ::google::protobuf::int32 tag_time() const;
  inline void set_tag_time(::google::protobuf::int32 value);

  // required int32 tag_count = 4;
  inline bool has_tag_count() const;
  inline void clear_tag_count();
  static const int kTagCountFieldNumber = 4;
  inline ::google::protobuf::int32 tag_count() const;
  inline void set_tag_count(::google::protobuf::int32 value);

  // optional int64 create_user_id = 5;
  inline bool has_create_user_id() const;
  inline void clear_create_user_id();
  static const int kCreateUserIdFieldNumber = 5;
  inline ::google::protobuf::int64 create_user_id() const;
  inline void set_create_user_id(::google::protobuf::int64 value);

  // optional int32 create_time = 6;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // optional bool is_tag = 7;
  inline bool has_is_tag() const;
  inline void clear_is_tag();
  static const int kIsTagFieldNumber = 7;
  inline bool is_tag() const;
  inline void set_is_tag(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.user.UserAbilityTag)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_tag_name();
  inline void clear_has_tag_name();
  inline void set_has_tag_time();
  inline void clear_has_tag_time();
  inline void set_has_tag_count();
  inline void clear_has_tag_count();
  inline void set_has_create_user_id();
  inline void clear_has_create_user_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_is_tag();
  inline void clear_has_is_tag();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* tag_name_;
  ::google::protobuf::int32 tag_time_;
  ::google::protobuf::int32 tag_count_;
  ::google::protobuf::int64 create_user_id_;
  ::google::protobuf::int32 create_time_;
  bool is_tag_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UserAbilityTag* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::MessageLite {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const User& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const User* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.user.UserBase base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::weizhu::user::UserBase& base() const;
  inline ::weizhu::user::UserBase* mutable_base();
  inline ::weizhu::user::UserBase* release_base();
  inline void set_allocated_base(::weizhu::user::UserBase* base);

  // optional .weizhu.user.UserMark mark = 2;
  inline bool has_mark() const;
  inline void clear_mark();
  static const int kMarkFieldNumber = 2;
  inline const ::weizhu::user::UserMark& mark() const;
  inline ::weizhu::user::UserMark* mutable_mark();
  inline ::weizhu::user::UserMark* release_mark();
  inline void set_allocated_mark(::weizhu::user::UserMark* mark);

  // repeated .weizhu.user.UserTeam team = 3;
  inline int team_size() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 3;
  inline const ::weizhu::user::UserTeam& team(int index) const;
  inline ::weizhu::user::UserTeam* mutable_team(int index);
  inline ::weizhu::user::UserTeam* add_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >&
      team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >*
      mutable_team();

  // repeated .weizhu.user.UserExtends ext = 4;
  inline int ext_size() const;
  inline void clear_ext();
  static const int kExtFieldNumber = 4;
  inline const ::weizhu::user::UserExtends& ext(int index) const;
  inline ::weizhu::user::UserExtends* mutable_ext(int index);
  inline ::weizhu::user::UserExtends* add_ext();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExtends >&
      ext() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExtends >*
      mutable_ext();

  // @@protoc_insertion_point(class_scope:weizhu.user.User)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_mark();
  inline void clear_has_mark();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::user::UserBase* base_;
  ::weizhu::user::UserMark* mark_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam > team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExtends > ext_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class GetUserByIdRequest : public ::google::protobuf::MessageLite {
 public:
  GetUserByIdRequest();
  virtual ~GetUserByIdRequest();

  GetUserByIdRequest(const GetUserByIdRequest& from);

  inline GetUserByIdRequest& operator=(const GetUserByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserByIdRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserByIdRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserByIdRequest* other);

  // implements Message ----------------------------------------------

  GetUserByIdRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserByIdRequest& from);
  void MergeFrom(const GetUserByIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 user_id = 1;
  inline int user_id_size() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id(int index) const;
  inline void set_user_id(int index, ::google::protobuf::int64 value);
  inline void add_user_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_user_id();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetUserByIdRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetUserByIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetUserByMobileNoRequest : public ::google::protobuf::MessageLite {
 public:
  GetUserByMobileNoRequest();
  virtual ~GetUserByMobileNoRequest();

  GetUserByMobileNoRequest(const GetUserByMobileNoRequest& from);

  inline GetUserByMobileNoRequest& operator=(const GetUserByMobileNoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserByMobileNoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserByMobileNoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserByMobileNoRequest* other);

  // implements Message ----------------------------------------------

  GetUserByMobileNoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserByMobileNoRequest& from);
  void MergeFrom(const GetUserByMobileNoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mobile_no = 1;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 1;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // @@protoc_insertion_point(class_scope:weizhu.user.GetUserByMobileNoRequest)
 private:
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mobile_no_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetUserByMobileNoRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetUserResponse : public ::google::protobuf::MessageLite {
 public:
  GetUserResponse();
  virtual ~GetUserResponse();

  GetUserResponse(const GetUserResponse& from);

  inline GetUserResponse& operator=(const GetUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserResponse* other);

  // implements Message ----------------------------------------------

  GetUserResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserResponse& from);
  void MergeFrom(const GetUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.User user = 1;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::weizhu::user::User& user(int index) const;
  inline ::weizhu::user::User* mutable_user(int index);
  inline ::weizhu::user::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
      mutable_user();

  // repeated .weizhu.user.Team ref_team = 2;
  inline int ref_team_size() const;
  inline void clear_ref_team();
  static const int kRefTeamFieldNumber = 2;
  inline const ::weizhu::user::Team& ref_team(int index) const;
  inline ::weizhu::user::Team* mutable_ref_team(int index);
  inline ::weizhu::user::Team* add_ref_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
      ref_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
      mutable_ref_team();

  // repeated .weizhu.user.Position ref_position = 3;
  inline int ref_position_size() const;
  inline void clear_ref_position();
  static const int kRefPositionFieldNumber = 3;
  inline const ::weizhu::user::Position& ref_position(int index) const;
  inline ::weizhu::user::Position* mutable_ref_position(int index);
  inline ::weizhu::user::Position* add_ref_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      ref_position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_ref_position();

  // repeated .weizhu.user.Level ref_level = 4;
  inline int ref_level_size() const;
  inline void clear_ref_level();
  static const int kRefLevelFieldNumber = 4;
  inline const ::weizhu::user::Level& ref_level(int index) const;
  inline ::weizhu::user::Level* mutable_ref_level(int index);
  inline ::weizhu::user::Level* add_ref_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      ref_level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_ref_level();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetUserResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::User > user_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team > ref_team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > ref_position_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > ref_level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetUserResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetTeamRequest : public ::google::protobuf::MessageLite {
 public:
  GetTeamRequest();
  virtual ~GetTeamRequest();

  GetTeamRequest(const GetTeamRequest& from);

  inline GetTeamRequest& operator=(const GetTeamRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTeamRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTeamRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTeamRequest* other);

  // implements Message ----------------------------------------------

  GetTeamRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTeamRequest& from);
  void MergeFrom(const GetTeamRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 team_id = 1;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  inline ::google::protobuf::int32 team_id() const;
  inline void set_team_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.GetTeamRequest)
 private:
  inline void set_has_team_id();
  inline void clear_has_team_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 team_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetTeamRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetTeamResponse : public ::google::protobuf::MessageLite {
 public:
  GetTeamResponse();
  virtual ~GetTeamResponse();

  GetTeamResponse(const GetTeamResponse& from);

  inline GetTeamResponse& operator=(const GetTeamResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTeamResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTeamResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTeamResponse* other);

  // implements Message ----------------------------------------------

  GetTeamResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTeamResponse& from);
  void MergeFrom(const GetTeamResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .weizhu.user.Team team = 1;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 1;
  inline const ::weizhu::user::Team& team() const;
  inline ::weizhu::user::Team* mutable_team();
  inline ::weizhu::user::Team* release_team();
  inline void set_allocated_team(::weizhu::user::Team* team);

  // repeated .weizhu.user.UserTeam sub_user_team = 2;
  inline int sub_user_team_size() const;
  inline void clear_sub_user_team();
  static const int kSubUserTeamFieldNumber = 2;
  inline const ::weizhu::user::UserTeam& sub_user_team(int index) const;
  inline ::weizhu::user::UserTeam* mutable_sub_user_team(int index);
  inline ::weizhu::user::UserTeam* add_sub_user_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >&
      sub_user_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >*
      mutable_sub_user_team();

  // repeated int32 sub_team_id = 3;
  inline int sub_team_id_size() const;
  inline void clear_sub_team_id();
  static const int kSubTeamIdFieldNumber = 3;
  inline ::google::protobuf::int32 sub_team_id(int index) const;
  inline void set_sub_team_id(int index, ::google::protobuf::int32 value);
  inline void add_sub_team_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sub_team_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sub_team_id();

  // repeated .weizhu.user.User ref_user = 4;
  inline int ref_user_size() const;
  inline void clear_ref_user();
  static const int kRefUserFieldNumber = 4;
  inline const ::weizhu::user::User& ref_user(int index) const;
  inline ::weizhu::user::User* mutable_ref_user(int index);
  inline ::weizhu::user::User* add_ref_user();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
      ref_user() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
      mutable_ref_user();

  // repeated .weizhu.user.Team ref_team = 5;
  inline int ref_team_size() const;
  inline void clear_ref_team();
  static const int kRefTeamFieldNumber = 5;
  inline const ::weizhu::user::Team& ref_team(int index) const;
  inline ::weizhu::user::Team* mutable_ref_team(int index);
  inline ::weizhu::user::Team* add_ref_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
      ref_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
      mutable_ref_team();

  // repeated .weizhu.user.Position ref_position = 6;
  inline int ref_position_size() const;
  inline void clear_ref_position();
  static const int kRefPositionFieldNumber = 6;
  inline const ::weizhu::user::Position& ref_position(int index) const;
  inline ::weizhu::user::Position* mutable_ref_position(int index);
  inline ::weizhu::user::Position* add_ref_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      ref_position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_ref_position();

  // repeated .weizhu.user.Level ref_level = 7;
  inline int ref_level_size() const;
  inline void clear_ref_level();
  static const int kRefLevelFieldNumber = 7;
  inline const ::weizhu::user::Level& ref_level(int index) const;
  inline ::weizhu::user::Level* mutable_ref_level(int index);
  inline ::weizhu::user::Level* add_ref_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      ref_level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_ref_level();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetTeamResponse)
 private:
  inline void set_has_team();
  inline void clear_has_team();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::user::Team* team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam > sub_user_team_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sub_team_id_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::User > ref_user_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team > ref_team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > ref_position_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > ref_level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetTeamResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserAvatarRequest : public ::google::protobuf::MessageLite {
 public:
  UpdateUserAvatarRequest();
  virtual ~UpdateUserAvatarRequest();

  UpdateUserAvatarRequest(const UpdateUserAvatarRequest& from);

  inline UpdateUserAvatarRequest& operator=(const UpdateUserAvatarRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserAvatarRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserAvatarRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserAvatarRequest* other);

  // implements Message ----------------------------------------------

  UpdateUserAvatarRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserAvatarRequest& from);
  void MergeFrom(const UpdateUserAvatarRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string avatar = 1;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 1;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserAvatarRequest)
 private:
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* avatar_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserAvatarRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserAvatarResponse : public ::google::protobuf::MessageLite {
 public:
  UpdateUserAvatarResponse();
  virtual ~UpdateUserAvatarResponse();

  UpdateUserAvatarResponse(const UpdateUserAvatarResponse& from);

  inline UpdateUserAvatarResponse& operator=(const UpdateUserAvatarResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserAvatarResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserAvatarResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserAvatarResponse* other);

  // implements Message ----------------------------------------------

  UpdateUserAvatarResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserAvatarResponse& from);
  void MergeFrom(const UpdateUserAvatarResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UpdateUserAvatarResponse_Result Result;
  static const Result SUCC = UpdateUserAvatarResponse_Result_SUCC;
  static const Result FAIL_AVATAR_INVALID = UpdateUserAvatarResponse_Result_FAIL_AVATAR_INVALID;
  static const Result FAIL_UNKNOWN = UpdateUserAvatarResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return UpdateUserAvatarResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    UpdateUserAvatarResponse_Result_Result_MIN;
  static const Result Result_MAX =
    UpdateUserAvatarResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    UpdateUserAvatarResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.UpdateUserAvatarResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::UpdateUserAvatarResponse_Result result() const;
  inline void set_result(::weizhu::user::UpdateUserAvatarResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserAvatarResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserAvatarResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserSignatureRequest : public ::google::protobuf::MessageLite {
 public:
  UpdateUserSignatureRequest();
  virtual ~UpdateUserSignatureRequest();

  UpdateUserSignatureRequest(const UpdateUserSignatureRequest& from);

  inline UpdateUserSignatureRequest& operator=(const UpdateUserSignatureRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserSignatureRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserSignatureRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserSignatureRequest* other);

  // implements Message ----------------------------------------------

  UpdateUserSignatureRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserSignatureRequest& from);
  void MergeFrom(const UpdateUserSignatureRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string signature = 1;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 1;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserSignatureRequest)
 private:
  inline void set_has_signature();
  inline void clear_has_signature();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* signature_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserSignatureRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserSignatureResponse : public ::google::protobuf::MessageLite {
 public:
  UpdateUserSignatureResponse();
  virtual ~UpdateUserSignatureResponse();

  UpdateUserSignatureResponse(const UpdateUserSignatureResponse& from);

  inline UpdateUserSignatureResponse& operator=(const UpdateUserSignatureResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserSignatureResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserSignatureResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserSignatureResponse* other);

  // implements Message ----------------------------------------------

  UpdateUserSignatureResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserSignatureResponse& from);
  void MergeFrom(const UpdateUserSignatureResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UpdateUserSignatureResponse_Result Result;
  static const Result SUCC = UpdateUserSignatureResponse_Result_SUCC;
  static const Result FAIL_SIGNATURE_INVALID = UpdateUserSignatureResponse_Result_FAIL_SIGNATURE_INVALID;
  static const Result FAIL_UNKNOWN = UpdateUserSignatureResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return UpdateUserSignatureResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    UpdateUserSignatureResponse_Result_Result_MIN;
  static const Result Result_MAX =
    UpdateUserSignatureResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    UpdateUserSignatureResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.UpdateUserSignatureResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::UpdateUserSignatureResponse_Result result() const;
  inline void set_result(::weizhu::user::UpdateUserSignatureResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserSignatureResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserSignatureResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserInterestRequest : public ::google::protobuf::MessageLite {
 public:
  UpdateUserInterestRequest();
  virtual ~UpdateUserInterestRequest();

  UpdateUserInterestRequest(const UpdateUserInterestRequest& from);

  inline UpdateUserInterestRequest& operator=(const UpdateUserInterestRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserInterestRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserInterestRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserInterestRequest* other);

  // implements Message ----------------------------------------------

  UpdateUserInterestRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserInterestRequest& from);
  void MergeFrom(const UpdateUserInterestRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string interest = 1;
  inline bool has_interest() const;
  inline void clear_interest();
  static const int kInterestFieldNumber = 1;
  inline const ::std::string& interest() const;
  inline void set_interest(const ::std::string& value);
  inline void set_interest(const char* value);
  inline void set_interest(const char* value, size_t size);
  inline ::std::string* mutable_interest();
  inline ::std::string* release_interest();
  inline void set_allocated_interest(::std::string* interest);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserInterestRequest)
 private:
  inline void set_has_interest();
  inline void clear_has_interest();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* interest_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserInterestRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserInterestResponse : public ::google::protobuf::MessageLite {
 public:
  UpdateUserInterestResponse();
  virtual ~UpdateUserInterestResponse();

  UpdateUserInterestResponse(const UpdateUserInterestResponse& from);

  inline UpdateUserInterestResponse& operator=(const UpdateUserInterestResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserInterestResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserInterestResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserInterestResponse* other);

  // implements Message ----------------------------------------------

  UpdateUserInterestResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserInterestResponse& from);
  void MergeFrom(const UpdateUserInterestResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UpdateUserInterestResponse_Result Result;
  static const Result SUCC = UpdateUserInterestResponse_Result_SUCC;
  static const Result FAIL_INTEREST_INVALID = UpdateUserInterestResponse_Result_FAIL_INTEREST_INVALID;
  static const Result FAIL_UNKNOWN = UpdateUserInterestResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return UpdateUserInterestResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    UpdateUserInterestResponse_Result_Result_MIN;
  static const Result Result_MAX =
    UpdateUserInterestResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    UpdateUserInterestResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.UpdateUserInterestResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::UpdateUserInterestResponse_Result result() const;
  inline void set_result(::weizhu::user::UpdateUserInterestResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserInterestResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserInterestResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetUserExperienceRequest : public ::google::protobuf::MessageLite {
 public:
  GetUserExperienceRequest();
  virtual ~GetUserExperienceRequest();

  GetUserExperienceRequest(const GetUserExperienceRequest& from);

  inline GetUserExperienceRequest& operator=(const GetUserExperienceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserExperienceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserExperienceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserExperienceRequest* other);

  // implements Message ----------------------------------------------

  GetUserExperienceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserExperienceRequest& from);
  void MergeFrom(const GetUserExperienceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.GetUserExperienceRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetUserExperienceRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetUserExperienceResponse : public ::google::protobuf::MessageLite {
 public:
  GetUserExperienceResponse();
  virtual ~GetUserExperienceResponse();

  GetUserExperienceResponse(const GetUserExperienceResponse& from);

  inline GetUserExperienceResponse& operator=(const GetUserExperienceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserExperienceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserExperienceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserExperienceResponse* other);

  // implements Message ----------------------------------------------

  GetUserExperienceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserExperienceResponse& from);
  void MergeFrom(const GetUserExperienceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.UserExperience experience = 1;
  inline int experience_size() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 1;
  inline const ::weizhu::user::UserExperience& experience(int index) const;
  inline ::weizhu::user::UserExperience* mutable_experience(int index);
  inline ::weizhu::user::UserExperience* add_experience();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExperience >&
      experience() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExperience >*
      mutable_experience();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetUserExperienceResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExperience > experience_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetUserExperienceResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateUserExperienceRequest : public ::google::protobuf::MessageLite {
 public:
  CreateUserExperienceRequest();
  virtual ~CreateUserExperienceRequest();

  CreateUserExperienceRequest(const CreateUserExperienceRequest& from);

  inline CreateUserExperienceRequest& operator=(const CreateUserExperienceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateUserExperienceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateUserExperienceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateUserExperienceRequest* other);

  // implements Message ----------------------------------------------

  CreateUserExperienceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateUserExperienceRequest& from);
  void MergeFrom(const CreateUserExperienceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.user.UserExperience experience = 1;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 1;
  inline const ::weizhu::user::UserExperience& experience() const;
  inline ::weizhu::user::UserExperience* mutable_experience();
  inline ::weizhu::user::UserExperience* release_experience();
  inline void set_allocated_experience(::weizhu::user::UserExperience* experience);

  // @@protoc_insertion_point(class_scope:weizhu.user.CreateUserExperienceRequest)
 private:
  inline void set_has_experience();
  inline void clear_has_experience();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::user::UserExperience* experience_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static CreateUserExperienceRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateUserExperienceResponse : public ::google::protobuf::MessageLite {
 public:
  CreateUserExperienceResponse();
  virtual ~CreateUserExperienceResponse();

  CreateUserExperienceResponse(const CreateUserExperienceResponse& from);

  inline CreateUserExperienceResponse& operator=(const CreateUserExperienceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateUserExperienceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateUserExperienceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateUserExperienceResponse* other);

  // implements Message ----------------------------------------------

  CreateUserExperienceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateUserExperienceResponse& from);
  void MergeFrom(const CreateUserExperienceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CreateUserExperienceResponse_Result Result;
  static const Result SUCC = CreateUserExperienceResponse_Result_SUCC;
  static const Result FAIL_EXPERIENCE_CONTENT_INVALID = CreateUserExperienceResponse_Result_FAIL_EXPERIENCE_CONTENT_INVALID;
  static const Result FAIL_EXPERIENCE_NUM_LIMIT = CreateUserExperienceResponse_Result_FAIL_EXPERIENCE_NUM_LIMIT;
  static const Result FAIL_UNKNOWN = CreateUserExperienceResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return CreateUserExperienceResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CreateUserExperienceResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CreateUserExperienceResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CreateUserExperienceResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.CreateUserExperienceResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::CreateUserExperienceResponse_Result result() const;
  inline void set_result(::weizhu::user::CreateUserExperienceResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional .weizhu.user.UserExperience experience = 3;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 3;
  inline const ::weizhu::user::UserExperience& experience() const;
  inline ::weizhu::user::UserExperience* mutable_experience();
  inline ::weizhu::user::UserExperience* release_experience();
  inline void set_allocated_experience(::weizhu::user::UserExperience* experience);

  // @@protoc_insertion_point(class_scope:weizhu.user.CreateUserExperienceResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_experience();
  inline void clear_has_experience();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::weizhu::user::UserExperience* experience_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static CreateUserExperienceResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserExperienceRequest : public ::google::protobuf::MessageLite {
 public:
  UpdateUserExperienceRequest();
  virtual ~UpdateUserExperienceRequest();

  UpdateUserExperienceRequest(const UpdateUserExperienceRequest& from);

  inline UpdateUserExperienceRequest& operator=(const UpdateUserExperienceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserExperienceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserExperienceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserExperienceRequest* other);

  // implements Message ----------------------------------------------

  UpdateUserExperienceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserExperienceRequest& from);
  void MergeFrom(const UpdateUserExperienceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.user.UserExperience experience = 1;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 1;
  inline const ::weizhu::user::UserExperience& experience() const;
  inline ::weizhu::user::UserExperience* mutable_experience();
  inline ::weizhu::user::UserExperience* release_experience();
  inline void set_allocated_experience(::weizhu::user::UserExperience* experience);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserExperienceRequest)
 private:
  inline void set_has_experience();
  inline void clear_has_experience();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::user::UserExperience* experience_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserExperienceRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserExperienceResponse : public ::google::protobuf::MessageLite {
 public:
  UpdateUserExperienceResponse();
  virtual ~UpdateUserExperienceResponse();

  UpdateUserExperienceResponse(const UpdateUserExperienceResponse& from);

  inline UpdateUserExperienceResponse& operator=(const UpdateUserExperienceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateUserExperienceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateUserExperienceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateUserExperienceResponse* other);

  // implements Message ----------------------------------------------

  UpdateUserExperienceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateUserExperienceResponse& from);
  void MergeFrom(const UpdateUserExperienceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UpdateUserExperienceResponse_Result Result;
  static const Result SUCC = UpdateUserExperienceResponse_Result_SUCC;
  static const Result FAIL_EXPERIENCE_ID_INVALID = UpdateUserExperienceResponse_Result_FAIL_EXPERIENCE_ID_INVALID;
  static const Result FAIL_EXPERIENCE_CONTENT_INVALID = UpdateUserExperienceResponse_Result_FAIL_EXPERIENCE_CONTENT_INVALID;
  static const Result FAIL_UNKNOWN = UpdateUserExperienceResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return UpdateUserExperienceResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    UpdateUserExperienceResponse_Result_Result_MIN;
  static const Result Result_MAX =
    UpdateUserExperienceResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    UpdateUserExperienceResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.UpdateUserExperienceResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::UpdateUserExperienceResponse_Result result() const;
  inline void set_result(::weizhu::user::UpdateUserExperienceResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional .weizhu.user.UserExperience experience = 3;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 3;
  inline const ::weizhu::user::UserExperience& experience() const;
  inline ::weizhu::user::UserExperience* mutable_experience();
  inline ::weizhu::user::UserExperience* release_experience();
  inline void set_allocated_experience(::weizhu::user::UserExperience* experience);

  // @@protoc_insertion_point(class_scope:weizhu.user.UpdateUserExperienceResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_experience();
  inline void clear_has_experience();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::weizhu::user::UserExperience* experience_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserExperienceResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteUserExperienceRequest : public ::google::protobuf::MessageLite {
 public:
  DeleteUserExperienceRequest();
  virtual ~DeleteUserExperienceRequest();

  DeleteUserExperienceRequest(const DeleteUserExperienceRequest& from);

  inline DeleteUserExperienceRequest& operator=(const DeleteUserExperienceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteUserExperienceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteUserExperienceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteUserExperienceRequest* other);

  // implements Message ----------------------------------------------

  DeleteUserExperienceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteUserExperienceRequest& from);
  void MergeFrom(const DeleteUserExperienceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 experience_id = 1;
  inline bool has_experience_id() const;
  inline void clear_experience_id();
  static const int kExperienceIdFieldNumber = 1;
  inline ::google::protobuf::int32 experience_id() const;
  inline void set_experience_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.DeleteUserExperienceRequest)
 private:
  inline void set_has_experience_id();
  inline void clear_has_experience_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 experience_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static DeleteUserExperienceRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteUserExperienceResponse : public ::google::protobuf::MessageLite {
 public:
  DeleteUserExperienceResponse();
  virtual ~DeleteUserExperienceResponse();

  DeleteUserExperienceResponse(const DeleteUserExperienceResponse& from);

  inline DeleteUserExperienceResponse& operator=(const DeleteUserExperienceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteUserExperienceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteUserExperienceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteUserExperienceResponse* other);

  // implements Message ----------------------------------------------

  DeleteUserExperienceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteUserExperienceResponse& from);
  void MergeFrom(const DeleteUserExperienceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DeleteUserExperienceResponse_Result Result;
  static const Result SUCC = DeleteUserExperienceResponse_Result_SUCC;
  static const Result FAIL_EXPERIENCE_ID_INVALID = DeleteUserExperienceResponse_Result_FAIL_EXPERIENCE_ID_INVALID;
  static const Result FAIL_UNKNOWN = DeleteUserExperienceResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return DeleteUserExperienceResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    DeleteUserExperienceResponse_Result_Result_MIN;
  static const Result Result_MAX =
    DeleteUserExperienceResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    DeleteUserExperienceResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.DeleteUserExperienceResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::DeleteUserExperienceResponse_Result result() const;
  inline void set_result(::weizhu::user::DeleteUserExperienceResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.DeleteUserExperienceResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static DeleteUserExperienceResponse* default_instance_;
};
// -------------------------------------------------------------------

class MarkUserNameRequest : public ::google::protobuf::MessageLite {
 public:
  MarkUserNameRequest();
  virtual ~MarkUserNameRequest();

  MarkUserNameRequest(const MarkUserNameRequest& from);

  inline MarkUserNameRequest& operator=(const MarkUserNameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MarkUserNameRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MarkUserNameRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MarkUserNameRequest* other);

  // implements Message ----------------------------------------------

  MarkUserNameRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MarkUserNameRequest& from);
  void MergeFrom(const MarkUserNameRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // optional string mark_name = 2;
  inline bool has_mark_name() const;
  inline void clear_mark_name();
  static const int kMarkNameFieldNumber = 2;
  inline const ::std::string& mark_name() const;
  inline void set_mark_name(const ::std::string& value);
  inline void set_mark_name(const char* value);
  inline void set_mark_name(const char* value, size_t size);
  inline ::std::string* mutable_mark_name();
  inline ::std::string* release_mark_name();
  inline void set_allocated_mark_name(::std::string* mark_name);

  // @@protoc_insertion_point(class_scope:weizhu.user.MarkUserNameRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_mark_name();
  inline void clear_has_mark_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* mark_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MarkUserNameRequest* default_instance_;
};
// -------------------------------------------------------------------

class MarkUserNameResponse : public ::google::protobuf::MessageLite {
 public:
  MarkUserNameResponse();
  virtual ~MarkUserNameResponse();

  MarkUserNameResponse(const MarkUserNameResponse& from);

  inline MarkUserNameResponse& operator=(const MarkUserNameResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MarkUserNameResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MarkUserNameResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MarkUserNameResponse* other);

  // implements Message ----------------------------------------------

  MarkUserNameResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MarkUserNameResponse& from);
  void MergeFrom(const MarkUserNameResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MarkUserNameResponse_Result Result;
  static const Result SUCC = MarkUserNameResponse_Result_SUCC;
  static const Result FAIL_USER_NOT_EXSIT = MarkUserNameResponse_Result_FAIL_USER_NOT_EXSIT;
  static const Result FAIL_MARK_SELF = MarkUserNameResponse_Result_FAIL_MARK_SELF;
  static const Result FAIL_MARK_NAME_INVALID = MarkUserNameResponse_Result_FAIL_MARK_NAME_INVALID;
  static const Result FAIL_UNKNOWN = MarkUserNameResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return MarkUserNameResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    MarkUserNameResponse_Result_Result_MIN;
  static const Result Result_MAX =
    MarkUserNameResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    MarkUserNameResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.MarkUserNameResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::MarkUserNameResponse_Result result() const;
  inline void set_result(::weizhu::user::MarkUserNameResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.MarkUserNameResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MarkUserNameResponse* default_instance_;
};
// -------------------------------------------------------------------

class MarkUserStarRequest : public ::google::protobuf::MessageLite {
 public:
  MarkUserStarRequest();
  virtual ~MarkUserStarRequest();

  MarkUserStarRequest(const MarkUserStarRequest& from);

  inline MarkUserStarRequest& operator=(const MarkUserStarRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MarkUserStarRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MarkUserStarRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MarkUserStarRequest* other);

  // implements Message ----------------------------------------------

  MarkUserStarRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MarkUserStarRequest& from);
  void MergeFrom(const MarkUserStarRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required bool is_star = 2;
  inline bool has_is_star() const;
  inline void clear_is_star();
  static const int kIsStarFieldNumber = 2;
  inline bool is_star() const;
  inline void set_is_star(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.user.MarkUserStarRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_is_star();
  inline void clear_has_is_star();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  bool is_star_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MarkUserStarRequest* default_instance_;
};
// -------------------------------------------------------------------

class MarkUserStarResponse : public ::google::protobuf::MessageLite {
 public:
  MarkUserStarResponse();
  virtual ~MarkUserStarResponse();

  MarkUserStarResponse(const MarkUserStarResponse& from);

  inline MarkUserStarResponse& operator=(const MarkUserStarResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MarkUserStarResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MarkUserStarResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MarkUserStarResponse* other);

  // implements Message ----------------------------------------------

  MarkUserStarResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MarkUserStarResponse& from);
  void MergeFrom(const MarkUserStarResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MarkUserStarResponse_Result Result;
  static const Result SUCC = MarkUserStarResponse_Result_SUCC;
  static const Result FAIL_USER_NOT_EXSIT = MarkUserStarResponse_Result_FAIL_USER_NOT_EXSIT;
  static const Result FAIL_MARK_SELF = MarkUserStarResponse_Result_FAIL_MARK_SELF;
  static const Result FAIL_MARK_STAR_NUM_LIMIT = MarkUserStarResponse_Result_FAIL_MARK_STAR_NUM_LIMIT;
  static const Result FAIL_UNKNOWN = MarkUserStarResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return MarkUserStarResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    MarkUserStarResponse_Result_Result_MIN;
  static const Result Result_MAX =
    MarkUserStarResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    MarkUserStarResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.MarkUserStarResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::MarkUserStarResponse_Result result() const;
  inline void set_result(::weizhu::user::MarkUserStarResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.MarkUserStarResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static MarkUserStarResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetMarkStarUserRequest : public ::google::protobuf::MessageLite {
 public:
  GetMarkStarUserRequest();
  virtual ~GetMarkStarUserRequest();

  GetMarkStarUserRequest(const GetMarkStarUserRequest& from);

  inline GetMarkStarUserRequest& operator=(const GetMarkStarUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetMarkStarUserRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMarkStarUserRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetMarkStarUserRequest* other);

  // implements Message ----------------------------------------------

  GetMarkStarUserRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMarkStarUserRequest& from);
  void MergeFrom(const GetMarkStarUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:weizhu.user.GetMarkStarUserRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetMarkStarUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetMarkStarUserResponse : public ::google::protobuf::MessageLite {
 public:
  GetMarkStarUserResponse();
  virtual ~GetMarkStarUserResponse();

  GetMarkStarUserResponse(const GetMarkStarUserResponse& from);

  inline GetMarkStarUserResponse& operator=(const GetMarkStarUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetMarkStarUserResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMarkStarUserResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetMarkStarUserResponse* other);

  // implements Message ----------------------------------------------

  GetMarkStarUserResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMarkStarUserResponse& from);
  void MergeFrom(const GetMarkStarUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.User user = 1;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::weizhu::user::User& user(int index) const;
  inline ::weizhu::user::User* mutable_user(int index);
  inline ::weizhu::user::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
      mutable_user();

  // repeated .weizhu.user.Team ref_team = 2;
  inline int ref_team_size() const;
  inline void clear_ref_team();
  static const int kRefTeamFieldNumber = 2;
  inline const ::weizhu::user::Team& ref_team(int index) const;
  inline ::weizhu::user::Team* mutable_ref_team(int index);
  inline ::weizhu::user::Team* add_ref_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
      ref_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
      mutable_ref_team();

  // repeated .weizhu.user.Position ref_position = 3;
  inline int ref_position_size() const;
  inline void clear_ref_position();
  static const int kRefPositionFieldNumber = 3;
  inline const ::weizhu::user::Position& ref_position(int index) const;
  inline ::weizhu::user::Position* mutable_ref_position(int index);
  inline ::weizhu::user::Position* add_ref_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      ref_position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_ref_position();

  // repeated .weizhu.user.Level ref_level = 4;
  inline int ref_level_size() const;
  inline void clear_ref_level();
  static const int kRefLevelFieldNumber = 4;
  inline const ::weizhu::user::Level& ref_level(int index) const;
  inline ::weizhu::user::Level* mutable_ref_level(int index);
  inline ::weizhu::user::Level* add_ref_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      ref_level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_ref_level();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetMarkStarUserResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::User > user_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team > ref_team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > ref_position_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > ref_level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetMarkStarUserResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetUserAbilityTagRequest : public ::google::protobuf::MessageLite {
 public:
  GetUserAbilityTagRequest();
  virtual ~GetUserAbilityTagRequest();

  GetUserAbilityTagRequest(const GetUserAbilityTagRequest& from);

  inline GetUserAbilityTagRequest& operator=(const GetUserAbilityTagRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserAbilityTagRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserAbilityTagRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserAbilityTagRequest* other);

  // implements Message ----------------------------------------------

  GetUserAbilityTagRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserAbilityTagRequest& from);
  void MergeFrom(const GetUserAbilityTagRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.GetUserAbilityTagRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetUserAbilityTagRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetUserAbilityTagResponse : public ::google::protobuf::MessageLite {
 public:
  GetUserAbilityTagResponse();
  virtual ~GetUserAbilityTagResponse();

  GetUserAbilityTagResponse(const GetUserAbilityTagResponse& from);

  inline GetUserAbilityTagResponse& operator=(const GetUserAbilityTagResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUserAbilityTagResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUserAbilityTagResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUserAbilityTagResponse* other);

  // implements Message ----------------------------------------------

  GetUserAbilityTagResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUserAbilityTagResponse& from);
  void MergeFrom(const GetUserAbilityTagResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.UserAbilityTag ability_tag = 1;
  inline int ability_tag_size() const;
  inline void clear_ability_tag();
  static const int kAbilityTagFieldNumber = 1;
  inline const ::weizhu::user::UserAbilityTag& ability_tag(int index) const;
  inline ::weizhu::user::UserAbilityTag* mutable_ability_tag(int index);
  inline ::weizhu::user::UserAbilityTag* add_ability_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >&
      ability_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >*
      mutable_ability_tag();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetUserAbilityTagResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag > ability_tag_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetUserAbilityTagResponse* default_instance_;
};
// -------------------------------------------------------------------

class TagUserAbilityRequest : public ::google::protobuf::MessageLite {
 public:
  TagUserAbilityRequest();
  virtual ~TagUserAbilityRequest();

  TagUserAbilityRequest(const TagUserAbilityRequest& from);

  inline TagUserAbilityRequest& operator=(const TagUserAbilityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TagUserAbilityRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TagUserAbilityRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TagUserAbilityRequest* other);

  // implements Message ----------------------------------------------

  TagUserAbilityRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TagUserAbilityRequest& from);
  void MergeFrom(const TagUserAbilityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required string tag_name = 2;
  inline bool has_tag_name() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 2;
  inline const ::std::string& tag_name() const;
  inline void set_tag_name(const ::std::string& value);
  inline void set_tag_name(const char* value);
  inline void set_tag_name(const char* value, size_t size);
  inline ::std::string* mutable_tag_name();
  inline ::std::string* release_tag_name();
  inline void set_allocated_tag_name(::std::string* tag_name);

  // required bool is_tag = 3;
  inline bool has_is_tag() const;
  inline void clear_is_tag();
  static const int kIsTagFieldNumber = 3;
  inline bool is_tag() const;
  inline void set_is_tag(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.user.TagUserAbilityRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_tag_name();
  inline void clear_has_tag_name();
  inline void set_has_is_tag();
  inline void clear_has_is_tag();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* tag_name_;
  bool is_tag_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TagUserAbilityRequest* default_instance_;
};
// -------------------------------------------------------------------

class TagUserAbilityResponse : public ::google::protobuf::MessageLite {
 public:
  TagUserAbilityResponse();
  virtual ~TagUserAbilityResponse();

  TagUserAbilityResponse(const TagUserAbilityResponse& from);

  inline TagUserAbilityResponse& operator=(const TagUserAbilityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TagUserAbilityResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TagUserAbilityResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TagUserAbilityResponse* other);

  // implements Message ----------------------------------------------

  TagUserAbilityResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TagUserAbilityResponse& from);
  void MergeFrom(const TagUserAbilityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TagUserAbilityResponse_Result Result;
  static const Result SUCC = TagUserAbilityResponse_Result_SUCC;
  static const Result FAIL_USER_NOT_EXSIT = TagUserAbilityResponse_Result_FAIL_USER_NOT_EXSIT;
  static const Result FAIL_TAG_SELF = TagUserAbilityResponse_Result_FAIL_TAG_SELF;
  static const Result FAIL_TAG_NOT_EXIST = TagUserAbilityResponse_Result_FAIL_TAG_NOT_EXIST;
  static const Result FAIL_UNKNOWN = TagUserAbilityResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return TagUserAbilityResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    TagUserAbilityResponse_Result_Result_MIN;
  static const Result Result_MAX =
    TagUserAbilityResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    TagUserAbilityResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.TagUserAbilityResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::TagUserAbilityResponse_Result result() const;
  inline void set_result(::weizhu::user::TagUserAbilityResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.TagUserAbilityResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static TagUserAbilityResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateAbilityTagRequest : public ::google::protobuf::MessageLite {
 public:
  CreateAbilityTagRequest();
  virtual ~CreateAbilityTagRequest();

  CreateAbilityTagRequest(const CreateAbilityTagRequest& from);

  inline CreateAbilityTagRequest& operator=(const CreateAbilityTagRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateAbilityTagRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateAbilityTagRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateAbilityTagRequest* other);

  // implements Message ----------------------------------------------

  CreateAbilityTagRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateAbilityTagRequest& from);
  void MergeFrom(const CreateAbilityTagRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required string tag_name = 2;
  inline bool has_tag_name() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 2;
  inline const ::std::string& tag_name() const;
  inline void set_tag_name(const ::std::string& value);
  inline void set_tag_name(const char* value);
  inline void set_tag_name(const char* value, size_t size);
  inline ::std::string* mutable_tag_name();
  inline ::std::string* release_tag_name();
  inline void set_allocated_tag_name(::std::string* tag_name);

  // @@protoc_insertion_point(class_scope:weizhu.user.CreateAbilityTagRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_tag_name();
  inline void clear_has_tag_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* tag_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static CreateAbilityTagRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateAbilityTagResponse : public ::google::protobuf::MessageLite {
 public:
  CreateAbilityTagResponse();
  virtual ~CreateAbilityTagResponse();

  CreateAbilityTagResponse(const CreateAbilityTagResponse& from);

  inline CreateAbilityTagResponse& operator=(const CreateAbilityTagResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateAbilityTagResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateAbilityTagResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateAbilityTagResponse* other);

  // implements Message ----------------------------------------------

  CreateAbilityTagResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateAbilityTagResponse& from);
  void MergeFrom(const CreateAbilityTagResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CreateAbilityTagResponse_Result Result;
  static const Result SUCC = CreateAbilityTagResponse_Result_SUCC;
  static const Result FAIL_USER_NOT_EXSIT = CreateAbilityTagResponse_Result_FAIL_USER_NOT_EXSIT;
  static const Result FAIL_TAG_NAME_INVALID = CreateAbilityTagResponse_Result_FAIL_TAG_NAME_INVALID;
  static const Result FAIL_TAG_NUM_LIMIT = CreateAbilityTagResponse_Result_FAIL_TAG_NUM_LIMIT;
  static const Result FAIL_TAG_EXIST = CreateAbilityTagResponse_Result_FAIL_TAG_EXIST;
  static const Result FAIL_UNKNOWN = CreateAbilityTagResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return CreateAbilityTagResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CreateAbilityTagResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CreateAbilityTagResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CreateAbilityTagResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.user.CreateAbilityTagResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::user::CreateAbilityTagResponse_Result result() const;
  inline void set_result(::weizhu::user::CreateAbilityTagResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.user.CreateAbilityTagResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static CreateAbilityTagResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteAbilityTagRequest : public ::google::protobuf::MessageLite {
 public:
  DeleteAbilityTagRequest();
  virtual ~DeleteAbilityTagRequest();

  DeleteAbilityTagRequest(const DeleteAbilityTagRequest& from);

  inline DeleteAbilityTagRequest& operator=(const DeleteAbilityTagRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteAbilityTagRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteAbilityTagRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteAbilityTagRequest* other);

  // implements Message ----------------------------------------------

  DeleteAbilityTagRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteAbilityTagRequest& from);
  void MergeFrom(const DeleteAbilityTagRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tag_name = 1;
  inline int tag_name_size() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 1;
  inline const ::std::string& tag_name(int index) const;
  inline ::std::string* mutable_tag_name(int index);
  inline void set_tag_name(int index, const ::std::string& value);
  inline void set_tag_name(int index, const char* value);
  inline void set_tag_name(int index, const char* value, size_t size);
  inline ::std::string* add_tag_name();
  inline void add_tag_name(const ::std::string& value);
  inline void add_tag_name(const char* value);
  inline void add_tag_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tag_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag_name();

  // @@protoc_insertion_point(class_scope:weizhu.user.DeleteAbilityTagRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static DeleteAbilityTagRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetRandomAbilityTagUserRequest : public ::google::protobuf::MessageLite {
 public:
  GetRandomAbilityTagUserRequest();
  virtual ~GetRandomAbilityTagUserRequest();

  GetRandomAbilityTagUserRequest(const GetRandomAbilityTagUserRequest& from);

  inline GetRandomAbilityTagUserRequest& operator=(const GetRandomAbilityTagUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetRandomAbilityTagUserRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetRandomAbilityTagUserRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetRandomAbilityTagUserRequest* other);

  // implements Message ----------------------------------------------

  GetRandomAbilityTagUserRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetRandomAbilityTagUserRequest& from);
  void MergeFrom(const GetRandomAbilityTagUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tag_name = 1;
  inline int tag_name_size() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 1;
  inline const ::std::string& tag_name(int index) const;
  inline ::std::string* mutable_tag_name(int index);
  inline void set_tag_name(int index, const ::std::string& value);
  inline void set_tag_name(int index, const char* value);
  inline void set_tag_name(int index, const char* value, size_t size);
  inline ::std::string* add_tag_name();
  inline void add_tag_name(const ::std::string& value);
  inline void add_tag_name(const char* value);
  inline void add_tag_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tag_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag_name();

  // optional bool is_expert = 2;
  inline bool has_is_expert() const;
  inline void clear_is_expert();
  static const int kIsExpertFieldNumber = 2;
  inline bool is_expert() const;
  inline void set_is_expert(bool value);

  // required int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.user.GetRandomAbilityTagUserRequest)
 private:
  inline void set_has_is_expert();
  inline void clear_has_is_expert();
  inline void set_has_size();
  inline void clear_has_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_name_;
  bool is_expert_;
  ::google::protobuf::int32 size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetRandomAbilityTagUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetRandomAbilityTagUserResponse : public ::google::protobuf::MessageLite {
 public:
  GetRandomAbilityTagUserResponse();
  virtual ~GetRandomAbilityTagUserResponse();

  GetRandomAbilityTagUserResponse(const GetRandomAbilityTagUserResponse& from);

  inline GetRandomAbilityTagUserResponse& operator=(const GetRandomAbilityTagUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetRandomAbilityTagUserResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetRandomAbilityTagUserResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetRandomAbilityTagUserResponse* other);

  // implements Message ----------------------------------------------

  GetRandomAbilityTagUserResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetRandomAbilityTagUserResponse& from);
  void MergeFrom(const GetRandomAbilityTagUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.User user = 1;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::weizhu::user::User& user(int index) const;
  inline ::weizhu::user::User* mutable_user(int index);
  inline ::weizhu::user::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
      mutable_user();

  // repeated .weizhu.user.Team ref_team = 2;
  inline int ref_team_size() const;
  inline void clear_ref_team();
  static const int kRefTeamFieldNumber = 2;
  inline const ::weizhu::user::Team& ref_team(int index) const;
  inline ::weizhu::user::Team* mutable_ref_team(int index);
  inline ::weizhu::user::Team* add_ref_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
      ref_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
      mutable_ref_team();

  // repeated .weizhu.user.Position ref_position = 3;
  inline int ref_position_size() const;
  inline void clear_ref_position();
  static const int kRefPositionFieldNumber = 3;
  inline const ::weizhu::user::Position& ref_position(int index) const;
  inline ::weizhu::user::Position* mutable_ref_position(int index);
  inline ::weizhu::user::Position* add_ref_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      ref_position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_ref_position();

  // repeated .weizhu.user.Level ref_level = 4;
  inline int ref_level_size() const;
  inline void clear_ref_level();
  static const int kRefLevelFieldNumber = 4;
  inline const ::weizhu::user::Level& ref_level(int index) const;
  inline ::weizhu::user::Level* mutable_ref_level(int index);
  inline ::weizhu::user::Level* add_ref_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      ref_level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_ref_level();

  // repeated .weizhu.user.UserAbilityTag ref_ability_tag = 5;
  inline int ref_ability_tag_size() const;
  inline void clear_ref_ability_tag();
  static const int kRefAbilityTagFieldNumber = 5;
  inline const ::weizhu::user::UserAbilityTag& ref_ability_tag(int index) const;
  inline ::weizhu::user::UserAbilityTag* mutable_ref_ability_tag(int index);
  inline ::weizhu::user::UserAbilityTag* add_ref_ability_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >&
      ref_ability_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >*
      mutable_ref_ability_tag();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetRandomAbilityTagUserResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::User > user_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team > ref_team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > ref_position_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > ref_level_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag > ref_ability_tag_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetRandomAbilityTagUserResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAbilityTagUserIdRequest : public ::google::protobuf::MessageLite {
 public:
  GetAbilityTagUserIdRequest();
  virtual ~GetAbilityTagUserIdRequest();

  GetAbilityTagUserIdRequest(const GetAbilityTagUserIdRequest& from);

  inline GetAbilityTagUserIdRequest& operator=(const GetAbilityTagUserIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAbilityTagUserIdRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAbilityTagUserIdRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAbilityTagUserIdRequest* other);

  // implements Message ----------------------------------------------

  GetAbilityTagUserIdRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAbilityTagUserIdRequest& from);
  void MergeFrom(const GetAbilityTagUserIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tag_name = 1;
  inline int tag_name_size() const;
  inline void clear_tag_name();
  static const int kTagNameFieldNumber = 1;
  inline const ::std::string& tag_name(int index) const;
  inline ::std::string* mutable_tag_name(int index);
  inline void set_tag_name(int index, const ::std::string& value);
  inline void set_tag_name(int index, const char* value);
  inline void set_tag_name(int index, const char* value, size_t size);
  inline ::std::string* add_tag_name();
  inline void add_tag_name(const ::std::string& value);
  inline void add_tag_name(const char* value);
  inline void add_tag_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tag_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag_name();

  // optional bool is_expert = 2;
  inline bool has_is_expert() const;
  inline void clear_is_expert();
  static const int kIsExpertFieldNumber = 2;
  inline bool is_expert() const;
  inline void set_is_expert(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.user.GetAbilityTagUserIdRequest)
 private:
  inline void set_has_is_expert();
  inline void clear_has_is_expert();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_name_;
  bool is_expert_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetAbilityTagUserIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAbilityTagUserIdResponse : public ::google::protobuf::MessageLite {
 public:
  GetAbilityTagUserIdResponse();
  virtual ~GetAbilityTagUserIdResponse();

  GetAbilityTagUserIdResponse(const GetAbilityTagUserIdResponse& from);

  inline GetAbilityTagUserIdResponse& operator=(const GetAbilityTagUserIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAbilityTagUserIdResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAbilityTagUserIdResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAbilityTagUserIdResponse* other);

  // implements Message ----------------------------------------------

  GetAbilityTagUserIdResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAbilityTagUserIdResponse& from);
  void MergeFrom(const GetAbilityTagUserIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 user_id = 1;
  inline int user_id_size() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id(int index) const;
  inline void set_user_id(int index, ::google::protobuf::int64 value);
  inline void add_user_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_user_id();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetAbilityTagUserIdResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetAbilityTagUserIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAllPositionRequest : public ::google::protobuf::MessageLite {
 public:
  GetAllPositionRequest();
  virtual ~GetAllPositionRequest();

  GetAllPositionRequest(const GetAllPositionRequest& from);

  inline GetAllPositionRequest& operator=(const GetAllPositionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAllPositionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAllPositionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAllPositionRequest* other);

  // implements Message ----------------------------------------------

  GetAllPositionRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAllPositionRequest& from);
  void MergeFrom(const GetAllPositionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:weizhu.user.GetAllPositionRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetAllPositionRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAllPositionResponse : public ::google::protobuf::MessageLite {
 public:
  GetAllPositionResponse();
  virtual ~GetAllPositionResponse();

  GetAllPositionResponse(const GetAllPositionResponse& from);

  inline GetAllPositionResponse& operator=(const GetAllPositionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAllPositionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAllPositionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAllPositionResponse* other);

  // implements Message ----------------------------------------------

  GetAllPositionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAllPositionResponse& from);
  void MergeFrom(const GetAllPositionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.Position position = 1;
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::weizhu::user::Position& position(int index) const;
  inline ::weizhu::user::Position* mutable_position(int index);
  inline ::weizhu::user::Position* add_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_position();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetAllPositionResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > position_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetAllPositionResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAllLevelRequest : public ::google::protobuf::MessageLite {
 public:
  GetAllLevelRequest();
  virtual ~GetAllLevelRequest();

  GetAllLevelRequest(const GetAllLevelRequest& from);

  inline GetAllLevelRequest& operator=(const GetAllLevelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAllLevelRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAllLevelRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAllLevelRequest* other);

  // implements Message ----------------------------------------------

  GetAllLevelRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAllLevelRequest& from);
  void MergeFrom(const GetAllLevelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:weizhu.user.GetAllLevelRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetAllLevelRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAllLevelResponse : public ::google::protobuf::MessageLite {
 public:
  GetAllLevelResponse();
  virtual ~GetAllLevelResponse();

  GetAllLevelResponse(const GetAllLevelResponse& from);

  inline GetAllLevelResponse& operator=(const GetAllLevelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAllLevelResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAllLevelResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAllLevelResponse* other);

  // implements Message ----------------------------------------------

  GetAllLevelResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAllLevelResponse& from);
  void MergeFrom(const GetAllLevelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.Level level = 1;
  inline int level_size() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline const ::weizhu::user::Level& level(int index) const;
  inline ::weizhu::user::Level* mutable_level(int index);
  inline ::weizhu::user::Level* add_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_level();

  // @@protoc_insertion_point(class_scope:weizhu.user.GetAllLevelResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static GetAllLevelResponse* default_instance_;
};
// -------------------------------------------------------------------

class SearchUserRequest : public ::google::protobuf::MessageLite {
 public:
  SearchUserRequest();
  virtual ~SearchUserRequest();

  SearchUserRequest(const SearchUserRequest& from);

  inline SearchUserRequest& operator=(const SearchUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SearchUserRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SearchUserRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SearchUserRequest* other);

  // implements Message ----------------------------------------------

  SearchUserRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SearchUserRequest& from);
  void MergeFrom(const SearchUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // @@protoc_insertion_point(class_scope:weizhu.user.SearchUserRequest)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* keyword_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SearchUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class SearchUserResponse : public ::google::protobuf::MessageLite {
 public:
  SearchUserResponse();
  virtual ~SearchUserResponse();

  SearchUserResponse(const SearchUserResponse& from);

  inline SearchUserResponse& operator=(const SearchUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SearchUserResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SearchUserResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SearchUserResponse* other);

  // implements Message ----------------------------------------------

  SearchUserResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SearchUserResponse& from);
  void MergeFrom(const SearchUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.user.User user = 1;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::weizhu::user::User& user(int index) const;
  inline ::weizhu::user::User* mutable_user(int index);
  inline ::weizhu::user::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
      mutable_user();

  // repeated .weizhu.user.Team ref_team = 2;
  inline int ref_team_size() const;
  inline void clear_ref_team();
  static const int kRefTeamFieldNumber = 2;
  inline const ::weizhu::user::Team& ref_team(int index) const;
  inline ::weizhu::user::Team* mutable_ref_team(int index);
  inline ::weizhu::user::Team* add_ref_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
      ref_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
      mutable_ref_team();

  // repeated .weizhu.user.Position ref_position = 3;
  inline int ref_position_size() const;
  inline void clear_ref_position();
  static const int kRefPositionFieldNumber = 3;
  inline const ::weizhu::user::Position& ref_position(int index) const;
  inline ::weizhu::user::Position* mutable_ref_position(int index);
  inline ::weizhu::user::Position* add_ref_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      ref_position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_ref_position();

  // repeated .weizhu.user.Level ref_level = 4;
  inline int ref_level_size() const;
  inline void clear_ref_level();
  static const int kRefLevelFieldNumber = 4;
  inline const ::weizhu::user::Level& ref_level(int index) const;
  inline ::weizhu::user::Level* mutable_ref_level(int index);
  inline ::weizhu::user::Level* add_ref_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      ref_level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_ref_level();

  // @@protoc_insertion_point(class_scope:weizhu.user.SearchUserResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::User > user_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team > ref_team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > ref_position_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > ref_level_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_user_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_user_2eproto();
  #endif
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static SearchUserResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Team

// required int32 team_id = 1;
inline bool Team::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Team::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Team::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Team::clear_team_id() {
  team_id_ = 0;
  clear_has_team_id();
}
inline ::google::protobuf::int32 Team::team_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.team_id)
  return team_id_;
}
inline void Team::set_team_id(::google::protobuf::int32 value) {
  set_has_team_id();
  team_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Team.team_id)
}

// required string team_name = 2;
inline bool Team::has_team_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Team::set_has_team_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Team::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Team::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& Team::team_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.team_name)
  return *team_name_;
}
inline void Team::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.Team.team_name)
}
inline void Team::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.Team.team_name)
}
inline void Team::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.Team.team_name)
}
inline ::std::string* Team::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    team_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.Team.team_name)
  return team_name_;
}
inline ::std::string* Team::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Team::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.Team.team_name)
}

// optional int32 parent_team_id = 3;
inline bool Team::has_parent_team_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Team::set_has_parent_team_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Team::clear_has_parent_team_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Team::clear_parent_team_id() {
  parent_team_id_ = 0;
  clear_has_parent_team_id();
}
inline ::google::protobuf::int32 Team::parent_team_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.parent_team_id)
  return parent_team_id_;
}
inline void Team::set_parent_team_id(::google::protobuf::int32 value) {
  set_has_parent_team_id();
  parent_team_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Team.parent_team_id)
}

// optional .weizhu.user.State state = 95 [default = NORMAL];
inline bool Team::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Team::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Team::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Team::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::weizhu::user::State Team::state() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.state)
  return static_cast< ::weizhu::user::State >(state_);
}
inline void Team::set_state(::weizhu::user::State value) {
  assert(::weizhu::user::State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Team.state)
}

// optional int64 create_admin_id = 96;
inline bool Team::has_create_admin_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Team::set_has_create_admin_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Team::clear_has_create_admin_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Team::clear_create_admin_id() {
  create_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_create_admin_id();
}
inline ::google::protobuf::int64 Team::create_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.create_admin_id)
  return create_admin_id_;
}
inline void Team::set_create_admin_id(::google::protobuf::int64 value) {
  set_has_create_admin_id();
  create_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Team.create_admin_id)
}

// optional int32 create_time = 97;
inline bool Team::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Team::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Team::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Team::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 Team::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.create_time)
  return create_time_;
}
inline void Team::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Team.create_time)
}

// optional int64 update_admin_id = 98;
inline bool Team::has_update_admin_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Team::set_has_update_admin_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Team::clear_has_update_admin_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Team::clear_update_admin_id() {
  update_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_update_admin_id();
}
inline ::google::protobuf::int64 Team::update_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.update_admin_id)
  return update_admin_id_;
}
inline void Team::set_update_admin_id(::google::protobuf::int64 value) {
  set_has_update_admin_id();
  update_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Team.update_admin_id)
}

// optional int32 update_time = 99;
inline bool Team::has_update_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Team::set_has_update_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Team::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Team::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 Team::update_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Team.update_time)
  return update_time_;
}
inline void Team::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Team.update_time)
}

// -------------------------------------------------------------------

// Position

// required int32 position_id = 1;
inline bool Position::has_position_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_position_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_position_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_position_id() {
  position_id_ = 0;
  clear_has_position_id();
}
inline ::google::protobuf::int32 Position::position_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.position_id)
  return position_id_;
}
inline void Position::set_position_id(::google::protobuf::int32 value) {
  set_has_position_id();
  position_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Position.position_id)
}

// required string position_name = 2;
inline bool Position::has_position_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_position_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_position_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_position_name() {
  if (position_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_name_->clear();
  }
  clear_has_position_name();
}
inline const ::std::string& Position::position_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.position_name)
  return *position_name_;
}
inline void Position::set_position_name(const ::std::string& value) {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_name_ = new ::std::string;
  }
  position_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.Position.position_name)
}
inline void Position::set_position_name(const char* value) {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_name_ = new ::std::string;
  }
  position_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.Position.position_name)
}
inline void Position::set_position_name(const char* value, size_t size) {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_name_ = new ::std::string;
  }
  position_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.Position.position_name)
}
inline ::std::string* Position::mutable_position_name() {
  set_has_position_name();
  if (position_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.Position.position_name)
  return position_name_;
}
inline ::std::string* Position::release_position_name() {
  clear_has_position_name();
  if (position_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_name_;
    position_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Position::set_allocated_position_name(::std::string* position_name) {
  if (position_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_name_;
  }
  if (position_name) {
    set_has_position_name();
    position_name_ = position_name;
  } else {
    clear_has_position_name();
    position_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.Position.position_name)
}

// required string position_desc = 3;
inline bool Position::has_position_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_position_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_position_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_position_desc() {
  if (position_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_desc_->clear();
  }
  clear_has_position_desc();
}
inline const ::std::string& Position::position_desc() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.position_desc)
  return *position_desc_;
}
inline void Position::set_position_desc(const ::std::string& value) {
  set_has_position_desc();
  if (position_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_desc_ = new ::std::string;
  }
  position_desc_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.Position.position_desc)
}
inline void Position::set_position_desc(const char* value) {
  set_has_position_desc();
  if (position_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_desc_ = new ::std::string;
  }
  position_desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.Position.position_desc)
}
inline void Position::set_position_desc(const char* value, size_t size) {
  set_has_position_desc();
  if (position_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_desc_ = new ::std::string;
  }
  position_desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.Position.position_desc)
}
inline ::std::string* Position::mutable_position_desc() {
  set_has_position_desc();
  if (position_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.Position.position_desc)
  return position_desc_;
}
inline ::std::string* Position::release_position_desc() {
  clear_has_position_desc();
  if (position_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_desc_;
    position_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Position::set_allocated_position_desc(::std::string* position_desc) {
  if (position_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_desc_;
  }
  if (position_desc) {
    set_has_position_desc();
    position_desc_ = position_desc;
  } else {
    clear_has_position_desc();
    position_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.Position.position_desc)
}

// optional .weizhu.user.State state = 95 [default = NORMAL];
inline bool Position::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::weizhu::user::State Position::state() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.state)
  return static_cast< ::weizhu::user::State >(state_);
}
inline void Position::set_state(::weizhu::user::State value) {
  assert(::weizhu::user::State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Position.state)
}

// optional int64 create_admin_id = 96;
inline bool Position::has_create_admin_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Position::set_has_create_admin_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Position::clear_has_create_admin_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Position::clear_create_admin_id() {
  create_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_create_admin_id();
}
inline ::google::protobuf::int64 Position::create_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.create_admin_id)
  return create_admin_id_;
}
inline void Position::set_create_admin_id(::google::protobuf::int64 value) {
  set_has_create_admin_id();
  create_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Position.create_admin_id)
}

// optional int32 create_time = 97;
inline bool Position::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Position::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Position::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Position::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 Position::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.create_time)
  return create_time_;
}
inline void Position::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Position.create_time)
}

// optional int64 update_admin_id = 98;
inline bool Position::has_update_admin_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Position::set_has_update_admin_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Position::clear_has_update_admin_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Position::clear_update_admin_id() {
  update_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_update_admin_id();
}
inline ::google::protobuf::int64 Position::update_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.update_admin_id)
  return update_admin_id_;
}
inline void Position::set_update_admin_id(::google::protobuf::int64 value) {
  set_has_update_admin_id();
  update_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Position.update_admin_id)
}

// optional int32 update_time = 99;
inline bool Position::has_update_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Position::set_has_update_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Position::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Position::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 Position::update_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Position.update_time)
  return update_time_;
}
inline void Position::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Position.update_time)
}

// -------------------------------------------------------------------

// Level

// required int32 level_id = 1;
inline bool Level::has_level_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Level::set_has_level_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Level::clear_has_level_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Level::clear_level_id() {
  level_id_ = 0;
  clear_has_level_id();
}
inline ::google::protobuf::int32 Level::level_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Level.level_id)
  return level_id_;
}
inline void Level::set_level_id(::google::protobuf::int32 value) {
  set_has_level_id();
  level_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Level.level_id)
}

// required string level_name = 2;
inline bool Level::has_level_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Level::set_has_level_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Level::clear_has_level_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Level::clear_level_name() {
  if (level_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_name_->clear();
  }
  clear_has_level_name();
}
inline const ::std::string& Level::level_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Level.level_name)
  return *level_name_;
}
inline void Level::set_level_name(const ::std::string& value) {
  set_has_level_name();
  if (level_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_name_ = new ::std::string;
  }
  level_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.Level.level_name)
}
inline void Level::set_level_name(const char* value) {
  set_has_level_name();
  if (level_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_name_ = new ::std::string;
  }
  level_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.Level.level_name)
}
inline void Level::set_level_name(const char* value, size_t size) {
  set_has_level_name();
  if (level_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_name_ = new ::std::string;
  }
  level_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.Level.level_name)
}
inline ::std::string* Level::mutable_level_name() {
  set_has_level_name();
  if (level_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.Level.level_name)
  return level_name_;
}
inline ::std::string* Level::release_level_name() {
  clear_has_level_name();
  if (level_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = level_name_;
    level_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Level::set_allocated_level_name(::std::string* level_name) {
  if (level_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete level_name_;
  }
  if (level_name) {
    set_has_level_name();
    level_name_ = level_name;
  } else {
    clear_has_level_name();
    level_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.Level.level_name)
}

// optional .weizhu.user.State state = 95 [default = NORMAL];
inline bool Level::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Level::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Level::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Level::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::weizhu::user::State Level::state() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Level.state)
  return static_cast< ::weizhu::user::State >(state_);
}
inline void Level::set_state(::weizhu::user::State value) {
  assert(::weizhu::user::State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Level.state)
}

// optional int64 create_admin_id = 96;
inline bool Level::has_create_admin_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Level::set_has_create_admin_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Level::clear_has_create_admin_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Level::clear_create_admin_id() {
  create_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_create_admin_id();
}
inline ::google::protobuf::int64 Level::create_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Level.create_admin_id)
  return create_admin_id_;
}
inline void Level::set_create_admin_id(::google::protobuf::int64 value) {
  set_has_create_admin_id();
  create_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Level.create_admin_id)
}

// optional int32 create_time = 97;
inline bool Level::has_create_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Level::set_has_create_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Level::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Level::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 Level::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Level.create_time)
  return create_time_;
}
inline void Level::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Level.create_time)
}

// optional int64 update_admin_id = 98;
inline bool Level::has_update_admin_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Level::set_has_update_admin_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Level::clear_has_update_admin_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Level::clear_update_admin_id() {
  update_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_update_admin_id();
}
inline ::google::protobuf::int64 Level::update_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Level.update_admin_id)
  return update_admin_id_;
}
inline void Level::set_update_admin_id(::google::protobuf::int64 value) {
  set_has_update_admin_id();
  update_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Level.update_admin_id)
}

// optional int32 update_time = 99;
inline bool Level::has_update_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Level::set_has_update_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Level::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Level::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 Level::update_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.Level.update_time)
  return update_time_;
}
inline void Level::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.Level.update_time)
}

// -------------------------------------------------------------------

// UserBase

// required int64 user_id = 1;
inline bool UserBase::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBase::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBase::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBase::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 UserBase::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.user_id)
  return user_id_;
}
inline void UserBase::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.user_id)
}

// required string raw_id = 2;
inline bool UserBase::has_raw_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBase::set_has_raw_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBase::clear_has_raw_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBase::clear_raw_id() {
  if (raw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_id_->clear();
  }
  clear_has_raw_id();
}
inline const ::std::string& UserBase::raw_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.raw_id)
  return *raw_id_;
}
inline void UserBase::set_raw_id(const ::std::string& value) {
  set_has_raw_id();
  if (raw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_id_ = new ::std::string;
  }
  raw_id_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.raw_id)
}
inline void UserBase::set_raw_id(const char* value) {
  set_has_raw_id();
  if (raw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_id_ = new ::std::string;
  }
  raw_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.raw_id)
}
inline void UserBase::set_raw_id(const char* value, size_t size) {
  set_has_raw_id();
  if (raw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_id_ = new ::std::string;
  }
  raw_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.raw_id)
}
inline ::std::string* UserBase::mutable_raw_id() {
  set_has_raw_id();
  if (raw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.raw_id)
  return raw_id_;
}
inline ::std::string* UserBase::release_raw_id() {
  clear_has_raw_id();
  if (raw_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = raw_id_;
    raw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserBase::set_allocated_raw_id(::std::string* raw_id) {
  if (raw_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete raw_id_;
  }
  if (raw_id) {
    set_has_raw_id();
    raw_id_ = raw_id;
  } else {
    clear_has_raw_id();
    raw_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserBase.raw_id)
}

// required string user_name = 3;
inline bool UserBase::has_user_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserBase::set_has_user_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserBase::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserBase::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& UserBase::user_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.user_name)
  return *user_name_;
}
inline void UserBase::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.user_name)
}
inline void UserBase::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.user_name)
}
inline void UserBase::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.user_name)
}
inline ::std::string* UserBase::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.user_name)
  return user_name_;
}
inline ::std::string* UserBase::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserBase::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserBase.user_name)
}

// optional .weizhu.user.UserBase.Gender gender = 4;
inline bool UserBase::has_gender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserBase::set_has_gender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserBase::clear_has_gender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserBase::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::weizhu::user::UserBase_Gender UserBase::gender() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.gender)
  return static_cast< ::weizhu::user::UserBase_Gender >(gender_);
}
inline void UserBase::set_gender(::weizhu::user::UserBase_Gender value) {
  assert(::weizhu::user::UserBase_Gender_IsValid(value));
  set_has_gender();
  gender_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.gender)
}

// optional string avatar = 5;
inline bool UserBase::has_avatar() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserBase::set_has_avatar() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserBase::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserBase::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& UserBase::avatar() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.avatar)
  return *avatar_;
}
inline void UserBase::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.avatar)
}
inline void UserBase::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.avatar)
}
inline void UserBase::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.avatar)
}
inline ::std::string* UserBase::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.avatar)
  return avatar_;
}
inline ::std::string* UserBase::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserBase::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserBase.avatar)
}

// repeated string mobile_no = 6;
inline int UserBase::mobile_no_size() const {
  return mobile_no_.size();
}
inline void UserBase::clear_mobile_no() {
  mobile_no_.Clear();
}
inline const ::std::string& UserBase::mobile_no(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.mobile_no)
  return mobile_no_.Get(index);
}
inline ::std::string* UserBase::mutable_mobile_no(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.mobile_no)
  return mobile_no_.Mutable(index);
}
inline void UserBase::set_mobile_no(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.mobile_no)
  mobile_no_.Mutable(index)->assign(value);
}
inline void UserBase::set_mobile_no(int index, const char* value) {
  mobile_no_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.mobile_no)
}
inline void UserBase::set_mobile_no(int index, const char* value, size_t size) {
  mobile_no_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.mobile_no)
}
inline ::std::string* UserBase::add_mobile_no() {
  return mobile_no_.Add();
}
inline void UserBase::add_mobile_no(const ::std::string& value) {
  mobile_no_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.user.UserBase.mobile_no)
}
inline void UserBase::add_mobile_no(const char* value) {
  mobile_no_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.user.UserBase.mobile_no)
}
inline void UserBase::add_mobile_no(const char* value, size_t size) {
  mobile_no_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.user.UserBase.mobile_no)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserBase::mobile_no() const {
  // @@protoc_insertion_point(field_list:weizhu.user.UserBase.mobile_no)
  return mobile_no_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserBase::mutable_mobile_no() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.UserBase.mobile_no)
  return &mobile_no_;
}

// repeated string phone_no = 7;
inline int UserBase::phone_no_size() const {
  return phone_no_.size();
}
inline void UserBase::clear_phone_no() {
  phone_no_.Clear();
}
inline const ::std::string& UserBase::phone_no(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.phone_no)
  return phone_no_.Get(index);
}
inline ::std::string* UserBase::mutable_phone_no(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.phone_no)
  return phone_no_.Mutable(index);
}
inline void UserBase::set_phone_no(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.phone_no)
  phone_no_.Mutable(index)->assign(value);
}
inline void UserBase::set_phone_no(int index, const char* value) {
  phone_no_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.phone_no)
}
inline void UserBase::set_phone_no(int index, const char* value, size_t size) {
  phone_no_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.phone_no)
}
inline ::std::string* UserBase::add_phone_no() {
  return phone_no_.Add();
}
inline void UserBase::add_phone_no(const ::std::string& value) {
  phone_no_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.user.UserBase.phone_no)
}
inline void UserBase::add_phone_no(const char* value) {
  phone_no_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.user.UserBase.phone_no)
}
inline void UserBase::add_phone_no(const char* value, size_t size) {
  phone_no_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.user.UserBase.phone_no)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserBase::phone_no() const {
  // @@protoc_insertion_point(field_list:weizhu.user.UserBase.phone_no)
  return phone_no_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserBase::mutable_phone_no() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.UserBase.phone_no)
  return &phone_no_;
}

// optional string email = 8;
inline bool UserBase::has_email() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserBase::set_has_email() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserBase::clear_has_email() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserBase::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserBase::email() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.email)
  return *email_;
}
inline void UserBase::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.email)
}
inline void UserBase::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.email)
}
inline void UserBase::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.email)
}
inline ::std::string* UserBase::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.email)
  return email_;
}
inline ::std::string* UserBase::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserBase::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserBase.email)
}

// optional string signature = 9;
inline bool UserBase::has_signature() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserBase::set_has_signature() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserBase::clear_has_signature() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserBase::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& UserBase::signature() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.signature)
  return *signature_;
}
inline void UserBase::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.signature)
}
inline void UserBase::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.signature)
}
inline void UserBase::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.signature)
}
inline ::std::string* UserBase::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.signature)
  return signature_;
}
inline ::std::string* UserBase::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserBase::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserBase.signature)
}

// optional string interest = 10;
inline bool UserBase::has_interest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserBase::set_has_interest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserBase::clear_has_interest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserBase::clear_interest() {
  if (interest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_->clear();
  }
  clear_has_interest();
}
inline const ::std::string& UserBase::interest() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.interest)
  return *interest_;
}
inline void UserBase::set_interest(const ::std::string& value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.interest)
}
inline void UserBase::set_interest(const char* value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserBase.interest)
}
inline void UserBase::set_interest(const char* value, size_t size) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  interest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserBase.interest)
}
inline ::std::string* UserBase::mutable_interest() {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserBase.interest)
  return interest_;
}
inline ::std::string* UserBase::release_interest() {
  clear_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = interest_;
    interest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserBase::set_allocated_interest(::std::string* interest) {
  if (interest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete interest_;
  }
  if (interest) {
    set_has_interest();
    interest_ = interest;
  } else {
    clear_has_interest();
    interest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserBase.interest)
}

// optional bool is_expert = 11;
inline bool UserBase::has_is_expert() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserBase::set_has_is_expert() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserBase::clear_has_is_expert() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserBase::clear_is_expert() {
  is_expert_ = false;
  clear_has_is_expert();
}
inline bool UserBase::is_expert() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.is_expert)
  return is_expert_;
}
inline void UserBase::set_is_expert(bool value) {
  set_has_is_expert();
  is_expert_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.is_expert)
}

// optional int32 level_id = 12;
inline bool UserBase::has_level_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserBase::set_has_level_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserBase::clear_has_level_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserBase::clear_level_id() {
  level_id_ = 0;
  clear_has_level_id();
}
inline ::google::protobuf::int32 UserBase::level_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.level_id)
  return level_id_;
}
inline void UserBase::set_level_id(::google::protobuf::int32 value) {
  set_has_level_id();
  level_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.level_id)
}

// optional .weizhu.user.UserBase.State state = 13 [default = NORMAL];
inline bool UserBase::has_state() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserBase::set_has_state() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserBase::clear_has_state() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserBase::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::weizhu::user::UserBase_State UserBase::state() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.state)
  return static_cast< ::weizhu::user::UserBase_State >(state_);
}
inline void UserBase::set_state(::weizhu::user::UserBase_State value) {
  assert(::weizhu::user::UserBase_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.state)
}

// optional int64 create_admin_id = 14;
inline bool UserBase::has_create_admin_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserBase::set_has_create_admin_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserBase::clear_has_create_admin_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserBase::clear_create_admin_id() {
  create_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_create_admin_id();
}
inline ::google::protobuf::int64 UserBase::create_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.create_admin_id)
  return create_admin_id_;
}
inline void UserBase::set_create_admin_id(::google::protobuf::int64 value) {
  set_has_create_admin_id();
  create_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.create_admin_id)
}

// optional int32 create_time = 15;
inline bool UserBase::has_create_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserBase::set_has_create_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserBase::clear_has_create_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserBase::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 UserBase::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.create_time)
  return create_time_;
}
inline void UserBase::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.create_time)
}

// optional int64 update_admin_id = 16;
inline bool UserBase::has_update_admin_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserBase::set_has_update_admin_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserBase::clear_has_update_admin_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserBase::clear_update_admin_id() {
  update_admin_id_ = GOOGLE_LONGLONG(0);
  clear_has_update_admin_id();
}
inline ::google::protobuf::int64 UserBase::update_admin_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.update_admin_id)
  return update_admin_id_;
}
inline void UserBase::set_update_admin_id(::google::protobuf::int64 value) {
  set_has_update_admin_id();
  update_admin_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.update_admin_id)
}

// optional int32 update_time = 17;
inline bool UserBase::has_update_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserBase::set_has_update_time() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserBase::clear_has_update_time() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserBase::clear_update_time() {
  update_time_ = 0;
  clear_has_update_time();
}
inline ::google::protobuf::int32 UserBase::update_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserBase.update_time)
  return update_time_;
}
inline void UserBase::set_update_time(::google::protobuf::int32 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserBase.update_time)
}

// -------------------------------------------------------------------

// UserMark

// required int64 user_id = 1;
inline bool UserMark::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMark::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMark::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMark::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 UserMark::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserMark.user_id)
  return user_id_;
}
inline void UserMark::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserMark.user_id)
}

// required bool is_star = 2;
inline bool UserMark::has_is_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMark::set_has_is_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMark::clear_has_is_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMark::clear_is_star() {
  is_star_ = false;
  clear_has_is_star();
}
inline bool UserMark::is_star() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserMark.is_star)
  return is_star_;
}
inline void UserMark::set_is_star(bool value) {
  set_has_is_star();
  is_star_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserMark.is_star)
}

// optional int32 star_time = 3;
inline bool UserMark::has_star_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMark::set_has_star_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMark::clear_has_star_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMark::clear_star_time() {
  star_time_ = 0;
  clear_has_star_time();
}
inline ::google::protobuf::int32 UserMark::star_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserMark.star_time)
  return star_time_;
}
inline void UserMark::set_star_time(::google::protobuf::int32 value) {
  set_has_star_time();
  star_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserMark.star_time)
}

// optional string mark_name = 4;
inline bool UserMark::has_mark_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMark::set_has_mark_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMark::clear_has_mark_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMark::clear_mark_name() {
  if (mark_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_->clear();
  }
  clear_has_mark_name();
}
inline const ::std::string& UserMark::mark_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserMark.mark_name)
  return *mark_name_;
}
inline void UserMark::set_mark_name(const ::std::string& value) {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  mark_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserMark.mark_name)
}
inline void UserMark::set_mark_name(const char* value) {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  mark_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserMark.mark_name)
}
inline void UserMark::set_mark_name(const char* value, size_t size) {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  mark_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserMark.mark_name)
}
inline ::std::string* UserMark::mutable_mark_name() {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserMark.mark_name)
  return mark_name_;
}
inline ::std::string* UserMark::release_mark_name() {
  clear_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mark_name_;
    mark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserMark::set_allocated_mark_name(::std::string* mark_name) {
  if (mark_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mark_name_;
  }
  if (mark_name) {
    set_has_mark_name();
    mark_name_ = mark_name;
  } else {
    clear_has_mark_name();
    mark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserMark.mark_name)
}

// -------------------------------------------------------------------

// UserTeam

// required int64 user_id = 1;
inline bool UserTeam::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTeam::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTeam::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTeam::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 UserTeam::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserTeam.user_id)
  return user_id_;
}
inline void UserTeam::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserTeam.user_id)
}

// required int32 team_id = 2;
inline bool UserTeam::has_team_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTeam::set_has_team_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTeam::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTeam::clear_team_id() {
  team_id_ = 0;
  clear_has_team_id();
}
inline ::google::protobuf::int32 UserTeam::team_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserTeam.team_id)
  return team_id_;
}
inline void UserTeam::set_team_id(::google::protobuf::int32 value) {
  set_has_team_id();
  team_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserTeam.team_id)
}

// optional int32 position_id = 3;
inline bool UserTeam::has_position_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTeam::set_has_position_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTeam::clear_has_position_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTeam::clear_position_id() {
  position_id_ = 0;
  clear_has_position_id();
}
inline ::google::protobuf::int32 UserTeam::position_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserTeam.position_id)
  return position_id_;
}
inline void UserTeam::set_position_id(::google::protobuf::int32 value) {
  set_has_position_id();
  position_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserTeam.position_id)
}

// -------------------------------------------------------------------

// UserExtends

// required int64 user_id = 1;
inline bool UserExtends::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserExtends::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserExtends::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserExtends::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 UserExtends::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserExtends.user_id)
  return user_id_;
}
inline void UserExtends::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserExtends.user_id)
}

// required string name = 2;
inline bool UserExtends::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserExtends::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserExtends::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserExtends::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserExtends::name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserExtends.name)
  return *name_;
}
inline void UserExtends::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserExtends.name)
}
inline void UserExtends::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserExtends.name)
}
inline void UserExtends::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserExtends.name)
}
inline ::std::string* UserExtends::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserExtends.name)
  return name_;
}
inline ::std::string* UserExtends::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserExtends::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserExtends.name)
}

// required string value = 3;
inline bool UserExtends::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserExtends::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserExtends::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserExtends::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& UserExtends::value() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserExtends.value)
  return *value_;
}
inline void UserExtends::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserExtends.value)
}
inline void UserExtends::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserExtends.value)
}
inline void UserExtends::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserExtends.value)
}
inline ::std::string* UserExtends::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserExtends.value)
  return value_;
}
inline ::std::string* UserExtends::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserExtends::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserExtends.value)
}

// -------------------------------------------------------------------

// UserExperience

// required int32 experience_id = 1;
inline bool UserExperience::has_experience_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserExperience::set_has_experience_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserExperience::clear_has_experience_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserExperience::clear_experience_id() {
  experience_id_ = 0;
  clear_has_experience_id();
}
inline ::google::protobuf::int32 UserExperience::experience_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserExperience.experience_id)
  return experience_id_;
}
inline void UserExperience::set_experience_id(::google::protobuf::int32 value) {
  set_has_experience_id();
  experience_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserExperience.experience_id)
}

// required string experience_content = 2;
inline bool UserExperience::has_experience_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserExperience::set_has_experience_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserExperience::clear_has_experience_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserExperience::clear_experience_content() {
  if (experience_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    experience_content_->clear();
  }
  clear_has_experience_content();
}
inline const ::std::string& UserExperience::experience_content() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserExperience.experience_content)
  return *experience_content_;
}
inline void UserExperience::set_experience_content(const ::std::string& value) {
  set_has_experience_content();
  if (experience_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    experience_content_ = new ::std::string;
  }
  experience_content_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserExperience.experience_content)
}
inline void UserExperience::set_experience_content(const char* value) {
  set_has_experience_content();
  if (experience_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    experience_content_ = new ::std::string;
  }
  experience_content_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserExperience.experience_content)
}
inline void UserExperience::set_experience_content(const char* value, size_t size) {
  set_has_experience_content();
  if (experience_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    experience_content_ = new ::std::string;
  }
  experience_content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserExperience.experience_content)
}
inline ::std::string* UserExperience::mutable_experience_content() {
  set_has_experience_content();
  if (experience_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    experience_content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserExperience.experience_content)
  return experience_content_;
}
inline ::std::string* UserExperience::release_experience_content() {
  clear_has_experience_content();
  if (experience_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = experience_content_;
    experience_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserExperience::set_allocated_experience_content(::std::string* experience_content) {
  if (experience_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete experience_content_;
  }
  if (experience_content) {
    set_has_experience_content();
    experience_content_ = experience_content;
  } else {
    clear_has_experience_content();
    experience_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserExperience.experience_content)
}

// -------------------------------------------------------------------

// UserAbilityTag

// required int64 user_id = 1;
inline bool UserAbilityTag::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserAbilityTag::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserAbilityTag::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserAbilityTag::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 UserAbilityTag::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserAbilityTag.user_id)
  return user_id_;
}
inline void UserAbilityTag::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserAbilityTag.user_id)
}

// required string tag_name = 2;
inline bool UserAbilityTag::has_tag_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserAbilityTag::set_has_tag_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserAbilityTag::clear_has_tag_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserAbilityTag::clear_tag_name() {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_->clear();
  }
  clear_has_tag_name();
}
inline const ::std::string& UserAbilityTag::tag_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserAbilityTag.tag_name)
  return *tag_name_;
}
inline void UserAbilityTag::set_tag_name(const ::std::string& value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UserAbilityTag.tag_name)
}
inline void UserAbilityTag::set_tag_name(const char* value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UserAbilityTag.tag_name)
}
inline void UserAbilityTag::set_tag_name(const char* value, size_t size) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UserAbilityTag.tag_name)
}
inline ::std::string* UserAbilityTag::mutable_tag_name() {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UserAbilityTag.tag_name)
  return tag_name_;
}
inline ::std::string* UserAbilityTag::release_tag_name() {
  clear_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_name_;
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserAbilityTag::set_allocated_tag_name(::std::string* tag_name) {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_name_;
  }
  if (tag_name) {
    set_has_tag_name();
    tag_name_ = tag_name;
  } else {
    clear_has_tag_name();
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UserAbilityTag.tag_name)
}

// required int32 tag_time = 3;
inline bool UserAbilityTag::has_tag_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserAbilityTag::set_has_tag_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserAbilityTag::clear_has_tag_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserAbilityTag::clear_tag_time() {
  tag_time_ = 0;
  clear_has_tag_time();
}
inline ::google::protobuf::int32 UserAbilityTag::tag_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserAbilityTag.tag_time)
  return tag_time_;
}
inline void UserAbilityTag::set_tag_time(::google::protobuf::int32 value) {
  set_has_tag_time();
  tag_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserAbilityTag.tag_time)
}

// required int32 tag_count = 4;
inline bool UserAbilityTag::has_tag_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserAbilityTag::set_has_tag_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserAbilityTag::clear_has_tag_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserAbilityTag::clear_tag_count() {
  tag_count_ = 0;
  clear_has_tag_count();
}
inline ::google::protobuf::int32 UserAbilityTag::tag_count() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserAbilityTag.tag_count)
  return tag_count_;
}
inline void UserAbilityTag::set_tag_count(::google::protobuf::int32 value) {
  set_has_tag_count();
  tag_count_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserAbilityTag.tag_count)
}

// optional int64 create_user_id = 5;
inline bool UserAbilityTag::has_create_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserAbilityTag::set_has_create_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserAbilityTag::clear_has_create_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserAbilityTag::clear_create_user_id() {
  create_user_id_ = GOOGLE_LONGLONG(0);
  clear_has_create_user_id();
}
inline ::google::protobuf::int64 UserAbilityTag::create_user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserAbilityTag.create_user_id)
  return create_user_id_;
}
inline void UserAbilityTag::set_create_user_id(::google::protobuf::int64 value) {
  set_has_create_user_id();
  create_user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserAbilityTag.create_user_id)
}

// optional int32 create_time = 6;
inline bool UserAbilityTag::has_create_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserAbilityTag::set_has_create_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserAbilityTag::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserAbilityTag::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 UserAbilityTag::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserAbilityTag.create_time)
  return create_time_;
}
inline void UserAbilityTag::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserAbilityTag.create_time)
}

// optional bool is_tag = 7;
inline bool UserAbilityTag::has_is_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserAbilityTag::set_has_is_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserAbilityTag::clear_has_is_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserAbilityTag::clear_is_tag() {
  is_tag_ = false;
  clear_has_is_tag();
}
inline bool UserAbilityTag::is_tag() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UserAbilityTag.is_tag)
  return is_tag_;
}
inline void UserAbilityTag::set_is_tag(bool value) {
  set_has_is_tag();
  is_tag_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UserAbilityTag.is_tag)
}

// -------------------------------------------------------------------

// User

// required .weizhu.user.UserBase base = 1;
inline bool User::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_base() {
  if (base_ != NULL) base_->::weizhu::user::UserBase::Clear();
  clear_has_base();
}
inline const ::weizhu::user::UserBase& User::base() const {
  // @@protoc_insertion_point(field_get:weizhu.user.User.base)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return base_ != NULL ? *base_ : *default_instance().base_;
#else
  return base_ != NULL ? *base_ : *default_instance_->base_;
#endif
}
inline ::weizhu::user::UserBase* User::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::weizhu::user::UserBase;
  // @@protoc_insertion_point(field_mutable:weizhu.user.User.base)
  return base_;
}
inline ::weizhu::user::UserBase* User::release_base() {
  clear_has_base();
  ::weizhu::user::UserBase* temp = base_;
  base_ = NULL;
  return temp;
}
inline void User::set_allocated_base(::weizhu::user::UserBase* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.User.base)
}

// optional .weizhu.user.UserMark mark = 2;
inline bool User::has_mark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_mark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_mark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_mark() {
  if (mark_ != NULL) mark_->::weizhu::user::UserMark::Clear();
  clear_has_mark();
}
inline const ::weizhu::user::UserMark& User::mark() const {
  // @@protoc_insertion_point(field_get:weizhu.user.User.mark)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mark_ != NULL ? *mark_ : *default_instance().mark_;
#else
  return mark_ != NULL ? *mark_ : *default_instance_->mark_;
#endif
}
inline ::weizhu::user::UserMark* User::mutable_mark() {
  set_has_mark();
  if (mark_ == NULL) mark_ = new ::weizhu::user::UserMark;
  // @@protoc_insertion_point(field_mutable:weizhu.user.User.mark)
  return mark_;
}
inline ::weizhu::user::UserMark* User::release_mark() {
  clear_has_mark();
  ::weizhu::user::UserMark* temp = mark_;
  mark_ = NULL;
  return temp;
}
inline void User::set_allocated_mark(::weizhu::user::UserMark* mark) {
  delete mark_;
  mark_ = mark;
  if (mark) {
    set_has_mark();
  } else {
    clear_has_mark();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.User.mark)
}

// repeated .weizhu.user.UserTeam team = 3;
inline int User::team_size() const {
  return team_.size();
}
inline void User::clear_team() {
  team_.Clear();
}
inline const ::weizhu::user::UserTeam& User::team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.User.team)
  return team_.Get(index);
}
inline ::weizhu::user::UserTeam* User::mutable_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.User.team)
  return team_.Mutable(index);
}
inline ::weizhu::user::UserTeam* User::add_team() {
  // @@protoc_insertion_point(field_add:weizhu.user.User.team)
  return team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >&
User::team() const {
  // @@protoc_insertion_point(field_list:weizhu.user.User.team)
  return team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >*
User::mutable_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.User.team)
  return &team_;
}

// repeated .weizhu.user.UserExtends ext = 4;
inline int User::ext_size() const {
  return ext_.size();
}
inline void User::clear_ext() {
  ext_.Clear();
}
inline const ::weizhu::user::UserExtends& User::ext(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.User.ext)
  return ext_.Get(index);
}
inline ::weizhu::user::UserExtends* User::mutable_ext(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.User.ext)
  return ext_.Mutable(index);
}
inline ::weizhu::user::UserExtends* User::add_ext() {
  // @@protoc_insertion_point(field_add:weizhu.user.User.ext)
  return ext_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExtends >&
User::ext() const {
  // @@protoc_insertion_point(field_list:weizhu.user.User.ext)
  return ext_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExtends >*
User::mutable_ext() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.User.ext)
  return &ext_;
}

// -------------------------------------------------------------------

// GetUserByIdRequest

// repeated int64 user_id = 1;
inline int GetUserByIdRequest::user_id_size() const {
  return user_id_.size();
}
inline void GetUserByIdRequest::clear_user_id() {
  user_id_.Clear();
}
inline ::google::protobuf::int64 GetUserByIdRequest::user_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserByIdRequest.user_id)
  return user_id_.Get(index);
}
inline void GetUserByIdRequest::set_user_id(int index, ::google::protobuf::int64 value) {
  user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.user.GetUserByIdRequest.user_id)
}
inline void GetUserByIdRequest::add_user_id(::google::protobuf::int64 value) {
  user_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.user.GetUserByIdRequest.user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetUserByIdRequest::user_id() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetUserByIdRequest.user_id)
  return user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetUserByIdRequest::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetUserByIdRequest.user_id)
  return &user_id_;
}

// -------------------------------------------------------------------

// GetUserByMobileNoRequest

// required string mobile_no = 1;
inline bool GetUserByMobileNoRequest::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserByMobileNoRequest::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserByMobileNoRequest::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserByMobileNoRequest::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& GetUserByMobileNoRequest::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserByMobileNoRequest.mobile_no)
  return *mobile_no_;
}
inline void GetUserByMobileNoRequest::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.GetUserByMobileNoRequest.mobile_no)
}
inline void GetUserByMobileNoRequest::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.GetUserByMobileNoRequest.mobile_no)
}
inline void GetUserByMobileNoRequest::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.GetUserByMobileNoRequest.mobile_no)
}
inline ::std::string* GetUserByMobileNoRequest::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetUserByMobileNoRequest.mobile_no)
  return mobile_no_;
}
inline ::std::string* GetUserByMobileNoRequest::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetUserByMobileNoRequest::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.GetUserByMobileNoRequest.mobile_no)
}

// -------------------------------------------------------------------

// GetUserResponse

// repeated .weizhu.user.User user = 1;
inline int GetUserResponse::user_size() const {
  return user_.size();
}
inline void GetUserResponse::clear_user() {
  user_.Clear();
}
inline const ::weizhu::user::User& GetUserResponse::user(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserResponse.user)
  return user_.Get(index);
}
inline ::weizhu::user::User* GetUserResponse::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetUserResponse.user)
  return user_.Mutable(index);
}
inline ::weizhu::user::User* GetUserResponse::add_user() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetUserResponse.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
GetUserResponse::user() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetUserResponse.user)
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
GetUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetUserResponse.user)
  return &user_;
}

// repeated .weizhu.user.Team ref_team = 2;
inline int GetUserResponse::ref_team_size() const {
  return ref_team_.size();
}
inline void GetUserResponse::clear_ref_team() {
  ref_team_.Clear();
}
inline const ::weizhu::user::Team& GetUserResponse::ref_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserResponse.ref_team)
  return ref_team_.Get(index);
}
inline ::weizhu::user::Team* GetUserResponse::mutable_ref_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetUserResponse.ref_team)
  return ref_team_.Mutable(index);
}
inline ::weizhu::user::Team* GetUserResponse::add_ref_team() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetUserResponse.ref_team)
  return ref_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
GetUserResponse::ref_team() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetUserResponse.ref_team)
  return ref_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
GetUserResponse::mutable_ref_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetUserResponse.ref_team)
  return &ref_team_;
}

// repeated .weizhu.user.Position ref_position = 3;
inline int GetUserResponse::ref_position_size() const {
  return ref_position_.size();
}
inline void GetUserResponse::clear_ref_position() {
  ref_position_.Clear();
}
inline const ::weizhu::user::Position& GetUserResponse::ref_position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserResponse.ref_position)
  return ref_position_.Get(index);
}
inline ::weizhu::user::Position* GetUserResponse::mutable_ref_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetUserResponse.ref_position)
  return ref_position_.Mutable(index);
}
inline ::weizhu::user::Position* GetUserResponse::add_ref_position() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetUserResponse.ref_position)
  return ref_position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
GetUserResponse::ref_position() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetUserResponse.ref_position)
  return ref_position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
GetUserResponse::mutable_ref_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetUserResponse.ref_position)
  return &ref_position_;
}

// repeated .weizhu.user.Level ref_level = 4;
inline int GetUserResponse::ref_level_size() const {
  return ref_level_.size();
}
inline void GetUserResponse::clear_ref_level() {
  ref_level_.Clear();
}
inline const ::weizhu::user::Level& GetUserResponse::ref_level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserResponse.ref_level)
  return ref_level_.Get(index);
}
inline ::weizhu::user::Level* GetUserResponse::mutable_ref_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetUserResponse.ref_level)
  return ref_level_.Mutable(index);
}
inline ::weizhu::user::Level* GetUserResponse::add_ref_level() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetUserResponse.ref_level)
  return ref_level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
GetUserResponse::ref_level() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetUserResponse.ref_level)
  return ref_level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
GetUserResponse::mutable_ref_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetUserResponse.ref_level)
  return &ref_level_;
}

// -------------------------------------------------------------------

// GetTeamRequest

// optional int32 team_id = 1;
inline bool GetTeamRequest::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTeamRequest::set_has_team_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTeamRequest::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTeamRequest::clear_team_id() {
  team_id_ = 0;
  clear_has_team_id();
}
inline ::google::protobuf::int32 GetTeamRequest::team_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamRequest.team_id)
  return team_id_;
}
inline void GetTeamRequest::set_team_id(::google::protobuf::int32 value) {
  set_has_team_id();
  team_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.GetTeamRequest.team_id)
}

// -------------------------------------------------------------------

// GetTeamResponse

// optional .weizhu.user.Team team = 1;
inline bool GetTeamResponse::has_team() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTeamResponse::set_has_team() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTeamResponse::clear_has_team() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTeamResponse::clear_team() {
  if (team_ != NULL) team_->::weizhu::user::Team::Clear();
  clear_has_team();
}
inline const ::weizhu::user::Team& GetTeamResponse::team() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamResponse.team)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return team_ != NULL ? *team_ : *default_instance().team_;
#else
  return team_ != NULL ? *team_ : *default_instance_->team_;
#endif
}
inline ::weizhu::user::Team* GetTeamResponse::mutable_team() {
  set_has_team();
  if (team_ == NULL) team_ = new ::weizhu::user::Team;
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetTeamResponse.team)
  return team_;
}
inline ::weizhu::user::Team* GetTeamResponse::release_team() {
  clear_has_team();
  ::weizhu::user::Team* temp = team_;
  team_ = NULL;
  return temp;
}
inline void GetTeamResponse::set_allocated_team(::weizhu::user::Team* team) {
  delete team_;
  team_ = team;
  if (team) {
    set_has_team();
  } else {
    clear_has_team();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.GetTeamResponse.team)
}

// repeated .weizhu.user.UserTeam sub_user_team = 2;
inline int GetTeamResponse::sub_user_team_size() const {
  return sub_user_team_.size();
}
inline void GetTeamResponse::clear_sub_user_team() {
  sub_user_team_.Clear();
}
inline const ::weizhu::user::UserTeam& GetTeamResponse::sub_user_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamResponse.sub_user_team)
  return sub_user_team_.Get(index);
}
inline ::weizhu::user::UserTeam* GetTeamResponse::mutable_sub_user_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetTeamResponse.sub_user_team)
  return sub_user_team_.Mutable(index);
}
inline ::weizhu::user::UserTeam* GetTeamResponse::add_sub_user_team() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetTeamResponse.sub_user_team)
  return sub_user_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >&
GetTeamResponse::sub_user_team() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetTeamResponse.sub_user_team)
  return sub_user_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserTeam >*
GetTeamResponse::mutable_sub_user_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetTeamResponse.sub_user_team)
  return &sub_user_team_;
}

// repeated int32 sub_team_id = 3;
inline int GetTeamResponse::sub_team_id_size() const {
  return sub_team_id_.size();
}
inline void GetTeamResponse::clear_sub_team_id() {
  sub_team_id_.Clear();
}
inline ::google::protobuf::int32 GetTeamResponse::sub_team_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamResponse.sub_team_id)
  return sub_team_id_.Get(index);
}
inline void GetTeamResponse::set_sub_team_id(int index, ::google::protobuf::int32 value) {
  sub_team_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.user.GetTeamResponse.sub_team_id)
}
inline void GetTeamResponse::add_sub_team_id(::google::protobuf::int32 value) {
  sub_team_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.user.GetTeamResponse.sub_team_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GetTeamResponse::sub_team_id() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetTeamResponse.sub_team_id)
  return sub_team_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GetTeamResponse::mutable_sub_team_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetTeamResponse.sub_team_id)
  return &sub_team_id_;
}

// repeated .weizhu.user.User ref_user = 4;
inline int GetTeamResponse::ref_user_size() const {
  return ref_user_.size();
}
inline void GetTeamResponse::clear_ref_user() {
  ref_user_.Clear();
}
inline const ::weizhu::user::User& GetTeamResponse::ref_user(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamResponse.ref_user)
  return ref_user_.Get(index);
}
inline ::weizhu::user::User* GetTeamResponse::mutable_ref_user(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetTeamResponse.ref_user)
  return ref_user_.Mutable(index);
}
inline ::weizhu::user::User* GetTeamResponse::add_ref_user() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetTeamResponse.ref_user)
  return ref_user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
GetTeamResponse::ref_user() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetTeamResponse.ref_user)
  return ref_user_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
GetTeamResponse::mutable_ref_user() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetTeamResponse.ref_user)
  return &ref_user_;
}

// repeated .weizhu.user.Team ref_team = 5;
inline int GetTeamResponse::ref_team_size() const {
  return ref_team_.size();
}
inline void GetTeamResponse::clear_ref_team() {
  ref_team_.Clear();
}
inline const ::weizhu::user::Team& GetTeamResponse::ref_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamResponse.ref_team)
  return ref_team_.Get(index);
}
inline ::weizhu::user::Team* GetTeamResponse::mutable_ref_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetTeamResponse.ref_team)
  return ref_team_.Mutable(index);
}
inline ::weizhu::user::Team* GetTeamResponse::add_ref_team() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetTeamResponse.ref_team)
  return ref_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
GetTeamResponse::ref_team() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetTeamResponse.ref_team)
  return ref_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
GetTeamResponse::mutable_ref_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetTeamResponse.ref_team)
  return &ref_team_;
}

// repeated .weizhu.user.Position ref_position = 6;
inline int GetTeamResponse::ref_position_size() const {
  return ref_position_.size();
}
inline void GetTeamResponse::clear_ref_position() {
  ref_position_.Clear();
}
inline const ::weizhu::user::Position& GetTeamResponse::ref_position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamResponse.ref_position)
  return ref_position_.Get(index);
}
inline ::weizhu::user::Position* GetTeamResponse::mutable_ref_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetTeamResponse.ref_position)
  return ref_position_.Mutable(index);
}
inline ::weizhu::user::Position* GetTeamResponse::add_ref_position() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetTeamResponse.ref_position)
  return ref_position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
GetTeamResponse::ref_position() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetTeamResponse.ref_position)
  return ref_position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
GetTeamResponse::mutable_ref_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetTeamResponse.ref_position)
  return &ref_position_;
}

// repeated .weizhu.user.Level ref_level = 7;
inline int GetTeamResponse::ref_level_size() const {
  return ref_level_.size();
}
inline void GetTeamResponse::clear_ref_level() {
  ref_level_.Clear();
}
inline const ::weizhu::user::Level& GetTeamResponse::ref_level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetTeamResponse.ref_level)
  return ref_level_.Get(index);
}
inline ::weizhu::user::Level* GetTeamResponse::mutable_ref_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetTeamResponse.ref_level)
  return ref_level_.Mutable(index);
}
inline ::weizhu::user::Level* GetTeamResponse::add_ref_level() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetTeamResponse.ref_level)
  return ref_level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
GetTeamResponse::ref_level() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetTeamResponse.ref_level)
  return ref_level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
GetTeamResponse::mutable_ref_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetTeamResponse.ref_level)
  return &ref_level_;
}

// -------------------------------------------------------------------

// UpdateUserAvatarRequest

// required string avatar = 1;
inline bool UpdateUserAvatarRequest::has_avatar() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserAvatarRequest::set_has_avatar() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserAvatarRequest::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserAvatarRequest::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& UpdateUserAvatarRequest::avatar() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserAvatarRequest.avatar)
  return *avatar_;
}
inline void UpdateUserAvatarRequest::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserAvatarRequest.avatar)
}
inline void UpdateUserAvatarRequest::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UpdateUserAvatarRequest.avatar)
}
inline void UpdateUserAvatarRequest::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UpdateUserAvatarRequest.avatar)
}
inline ::std::string* UpdateUserAvatarRequest::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserAvatarRequest.avatar)
  return avatar_;
}
inline ::std::string* UpdateUserAvatarRequest::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserAvatarRequest::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserAvatarRequest.avatar)
}

// -------------------------------------------------------------------

// UpdateUserAvatarResponse

// optional .weizhu.user.UpdateUserAvatarResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool UpdateUserAvatarResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserAvatarResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserAvatarResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserAvatarResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::UpdateUserAvatarResponse_Result UpdateUserAvatarResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserAvatarResponse.result)
  return static_cast< ::weizhu::user::UpdateUserAvatarResponse_Result >(result_);
}
inline void UpdateUserAvatarResponse::set_result(::weizhu::user::UpdateUserAvatarResponse_Result value) {
  assert(::weizhu::user::UpdateUserAvatarResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserAvatarResponse.result)
}

// optional string fail_text = 2;
inline bool UpdateUserAvatarResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserAvatarResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserAvatarResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserAvatarResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& UpdateUserAvatarResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserAvatarResponse.fail_text)
  return *fail_text_;
}
inline void UpdateUserAvatarResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserAvatarResponse.fail_text)
}
inline void UpdateUserAvatarResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UpdateUserAvatarResponse.fail_text)
}
inline void UpdateUserAvatarResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UpdateUserAvatarResponse.fail_text)
}
inline ::std::string* UpdateUserAvatarResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserAvatarResponse.fail_text)
  return fail_text_;
}
inline ::std::string* UpdateUserAvatarResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserAvatarResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserAvatarResponse.fail_text)
}

// -------------------------------------------------------------------

// UpdateUserSignatureRequest

// required string signature = 1;
inline bool UpdateUserSignatureRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserSignatureRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserSignatureRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserSignatureRequest::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& UpdateUserSignatureRequest::signature() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserSignatureRequest.signature)
  return *signature_;
}
inline void UpdateUserSignatureRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserSignatureRequest.signature)
}
inline void UpdateUserSignatureRequest::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UpdateUserSignatureRequest.signature)
}
inline void UpdateUserSignatureRequest::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UpdateUserSignatureRequest.signature)
}
inline ::std::string* UpdateUserSignatureRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserSignatureRequest.signature)
  return signature_;
}
inline ::std::string* UpdateUserSignatureRequest::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserSignatureRequest::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserSignatureRequest.signature)
}

// -------------------------------------------------------------------

// UpdateUserSignatureResponse

// optional .weizhu.user.UpdateUserSignatureResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool UpdateUserSignatureResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserSignatureResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserSignatureResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserSignatureResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::UpdateUserSignatureResponse_Result UpdateUserSignatureResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserSignatureResponse.result)
  return static_cast< ::weizhu::user::UpdateUserSignatureResponse_Result >(result_);
}
inline void UpdateUserSignatureResponse::set_result(::weizhu::user::UpdateUserSignatureResponse_Result value) {
  assert(::weizhu::user::UpdateUserSignatureResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserSignatureResponse.result)
}

// optional string fail_text = 2;
inline bool UpdateUserSignatureResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserSignatureResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserSignatureResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserSignatureResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& UpdateUserSignatureResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserSignatureResponse.fail_text)
  return *fail_text_;
}
inline void UpdateUserSignatureResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserSignatureResponse.fail_text)
}
inline void UpdateUserSignatureResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UpdateUserSignatureResponse.fail_text)
}
inline void UpdateUserSignatureResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UpdateUserSignatureResponse.fail_text)
}
inline ::std::string* UpdateUserSignatureResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserSignatureResponse.fail_text)
  return fail_text_;
}
inline ::std::string* UpdateUserSignatureResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserSignatureResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserSignatureResponse.fail_text)
}

// -------------------------------------------------------------------

// UpdateUserInterestRequest

// required string interest = 1;
inline bool UpdateUserInterestRequest::has_interest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserInterestRequest::set_has_interest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserInterestRequest::clear_has_interest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserInterestRequest::clear_interest() {
  if (interest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_->clear();
  }
  clear_has_interest();
}
inline const ::std::string& UpdateUserInterestRequest::interest() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserInterestRequest.interest)
  return *interest_;
}
inline void UpdateUserInterestRequest::set_interest(const ::std::string& value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserInterestRequest.interest)
}
inline void UpdateUserInterestRequest::set_interest(const char* value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UpdateUserInterestRequest.interest)
}
inline void UpdateUserInterestRequest::set_interest(const char* value, size_t size) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  interest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UpdateUserInterestRequest.interest)
}
inline ::std::string* UpdateUserInterestRequest::mutable_interest() {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserInterestRequest.interest)
  return interest_;
}
inline ::std::string* UpdateUserInterestRequest::release_interest() {
  clear_has_interest();
  if (interest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = interest_;
    interest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserInterestRequest::set_allocated_interest(::std::string* interest) {
  if (interest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete interest_;
  }
  if (interest) {
    set_has_interest();
    interest_ = interest;
  } else {
    clear_has_interest();
    interest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserInterestRequest.interest)
}

// -------------------------------------------------------------------

// UpdateUserInterestResponse

// optional .weizhu.user.UpdateUserInterestResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool UpdateUserInterestResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserInterestResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserInterestResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserInterestResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::UpdateUserInterestResponse_Result UpdateUserInterestResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserInterestResponse.result)
  return static_cast< ::weizhu::user::UpdateUserInterestResponse_Result >(result_);
}
inline void UpdateUserInterestResponse::set_result(::weizhu::user::UpdateUserInterestResponse_Result value) {
  assert(::weizhu::user::UpdateUserInterestResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserInterestResponse.result)
}

// optional string fail_text = 2;
inline bool UpdateUserInterestResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserInterestResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserInterestResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserInterestResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& UpdateUserInterestResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserInterestResponse.fail_text)
  return *fail_text_;
}
inline void UpdateUserInterestResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserInterestResponse.fail_text)
}
inline void UpdateUserInterestResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UpdateUserInterestResponse.fail_text)
}
inline void UpdateUserInterestResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UpdateUserInterestResponse.fail_text)
}
inline ::std::string* UpdateUserInterestResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserInterestResponse.fail_text)
  return fail_text_;
}
inline ::std::string* UpdateUserInterestResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserInterestResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserInterestResponse.fail_text)
}

// -------------------------------------------------------------------

// GetUserExperienceRequest

// required int64 user_id = 1;
inline bool GetUserExperienceRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserExperienceRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserExperienceRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserExperienceRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 GetUserExperienceRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserExperienceRequest.user_id)
  return user_id_;
}
inline void GetUserExperienceRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.GetUserExperienceRequest.user_id)
}

// -------------------------------------------------------------------

// GetUserExperienceResponse

// repeated .weizhu.user.UserExperience experience = 1;
inline int GetUserExperienceResponse::experience_size() const {
  return experience_.size();
}
inline void GetUserExperienceResponse::clear_experience() {
  experience_.Clear();
}
inline const ::weizhu::user::UserExperience& GetUserExperienceResponse::experience(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserExperienceResponse.experience)
  return experience_.Get(index);
}
inline ::weizhu::user::UserExperience* GetUserExperienceResponse::mutable_experience(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetUserExperienceResponse.experience)
  return experience_.Mutable(index);
}
inline ::weizhu::user::UserExperience* GetUserExperienceResponse::add_experience() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetUserExperienceResponse.experience)
  return experience_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExperience >&
GetUserExperienceResponse::experience() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetUserExperienceResponse.experience)
  return experience_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserExperience >*
GetUserExperienceResponse::mutable_experience() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetUserExperienceResponse.experience)
  return &experience_;
}

// -------------------------------------------------------------------

// CreateUserExperienceRequest

// required .weizhu.user.UserExperience experience = 1;
inline bool CreateUserExperienceRequest::has_experience() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateUserExperienceRequest::set_has_experience() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateUserExperienceRequest::clear_has_experience() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateUserExperienceRequest::clear_experience() {
  if (experience_ != NULL) experience_->::weizhu::user::UserExperience::Clear();
  clear_has_experience();
}
inline const ::weizhu::user::UserExperience& CreateUserExperienceRequest::experience() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateUserExperienceRequest.experience)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return experience_ != NULL ? *experience_ : *default_instance().experience_;
#else
  return experience_ != NULL ? *experience_ : *default_instance_->experience_;
#endif
}
inline ::weizhu::user::UserExperience* CreateUserExperienceRequest::mutable_experience() {
  set_has_experience();
  if (experience_ == NULL) experience_ = new ::weizhu::user::UserExperience;
  // @@protoc_insertion_point(field_mutable:weizhu.user.CreateUserExperienceRequest.experience)
  return experience_;
}
inline ::weizhu::user::UserExperience* CreateUserExperienceRequest::release_experience() {
  clear_has_experience();
  ::weizhu::user::UserExperience* temp = experience_;
  experience_ = NULL;
  return temp;
}
inline void CreateUserExperienceRequest::set_allocated_experience(::weizhu::user::UserExperience* experience) {
  delete experience_;
  experience_ = experience;
  if (experience) {
    set_has_experience();
  } else {
    clear_has_experience();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.CreateUserExperienceRequest.experience)
}

// -------------------------------------------------------------------

// CreateUserExperienceResponse

// optional .weizhu.user.CreateUserExperienceResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool CreateUserExperienceResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateUserExperienceResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateUserExperienceResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateUserExperienceResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::CreateUserExperienceResponse_Result CreateUserExperienceResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateUserExperienceResponse.result)
  return static_cast< ::weizhu::user::CreateUserExperienceResponse_Result >(result_);
}
inline void CreateUserExperienceResponse::set_result(::weizhu::user::CreateUserExperienceResponse_Result value) {
  assert(::weizhu::user::CreateUserExperienceResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.CreateUserExperienceResponse.result)
}

// optional string fail_text = 2;
inline bool CreateUserExperienceResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateUserExperienceResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateUserExperienceResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateUserExperienceResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& CreateUserExperienceResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateUserExperienceResponse.fail_text)
  return *fail_text_;
}
inline void CreateUserExperienceResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.CreateUserExperienceResponse.fail_text)
}
inline void CreateUserExperienceResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.CreateUserExperienceResponse.fail_text)
}
inline void CreateUserExperienceResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.CreateUserExperienceResponse.fail_text)
}
inline ::std::string* CreateUserExperienceResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.CreateUserExperienceResponse.fail_text)
  return fail_text_;
}
inline ::std::string* CreateUserExperienceResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateUserExperienceResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.CreateUserExperienceResponse.fail_text)
}

// optional .weizhu.user.UserExperience experience = 3;
inline bool CreateUserExperienceResponse::has_experience() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateUserExperienceResponse::set_has_experience() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateUserExperienceResponse::clear_has_experience() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateUserExperienceResponse::clear_experience() {
  if (experience_ != NULL) experience_->::weizhu::user::UserExperience::Clear();
  clear_has_experience();
}
inline const ::weizhu::user::UserExperience& CreateUserExperienceResponse::experience() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateUserExperienceResponse.experience)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return experience_ != NULL ? *experience_ : *default_instance().experience_;
#else
  return experience_ != NULL ? *experience_ : *default_instance_->experience_;
#endif
}
inline ::weizhu::user::UserExperience* CreateUserExperienceResponse::mutable_experience() {
  set_has_experience();
  if (experience_ == NULL) experience_ = new ::weizhu::user::UserExperience;
  // @@protoc_insertion_point(field_mutable:weizhu.user.CreateUserExperienceResponse.experience)
  return experience_;
}
inline ::weizhu::user::UserExperience* CreateUserExperienceResponse::release_experience() {
  clear_has_experience();
  ::weizhu::user::UserExperience* temp = experience_;
  experience_ = NULL;
  return temp;
}
inline void CreateUserExperienceResponse::set_allocated_experience(::weizhu::user::UserExperience* experience) {
  delete experience_;
  experience_ = experience;
  if (experience) {
    set_has_experience();
  } else {
    clear_has_experience();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.CreateUserExperienceResponse.experience)
}

// -------------------------------------------------------------------

// UpdateUserExperienceRequest

// required .weizhu.user.UserExperience experience = 1;
inline bool UpdateUserExperienceRequest::has_experience() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserExperienceRequest::set_has_experience() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserExperienceRequest::clear_has_experience() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserExperienceRequest::clear_experience() {
  if (experience_ != NULL) experience_->::weizhu::user::UserExperience::Clear();
  clear_has_experience();
}
inline const ::weizhu::user::UserExperience& UpdateUserExperienceRequest::experience() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserExperienceRequest.experience)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return experience_ != NULL ? *experience_ : *default_instance().experience_;
#else
  return experience_ != NULL ? *experience_ : *default_instance_->experience_;
#endif
}
inline ::weizhu::user::UserExperience* UpdateUserExperienceRequest::mutable_experience() {
  set_has_experience();
  if (experience_ == NULL) experience_ = new ::weizhu::user::UserExperience;
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserExperienceRequest.experience)
  return experience_;
}
inline ::weizhu::user::UserExperience* UpdateUserExperienceRequest::release_experience() {
  clear_has_experience();
  ::weizhu::user::UserExperience* temp = experience_;
  experience_ = NULL;
  return temp;
}
inline void UpdateUserExperienceRequest::set_allocated_experience(::weizhu::user::UserExperience* experience) {
  delete experience_;
  experience_ = experience;
  if (experience) {
    set_has_experience();
  } else {
    clear_has_experience();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserExperienceRequest.experience)
}

// -------------------------------------------------------------------

// UpdateUserExperienceResponse

// optional .weizhu.user.UpdateUserExperienceResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool UpdateUserExperienceResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserExperienceResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserExperienceResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserExperienceResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::UpdateUserExperienceResponse_Result UpdateUserExperienceResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserExperienceResponse.result)
  return static_cast< ::weizhu::user::UpdateUserExperienceResponse_Result >(result_);
}
inline void UpdateUserExperienceResponse::set_result(::weizhu::user::UpdateUserExperienceResponse_Result value) {
  assert(::weizhu::user::UpdateUserExperienceResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserExperienceResponse.result)
}

// optional string fail_text = 2;
inline bool UpdateUserExperienceResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserExperienceResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserExperienceResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserExperienceResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& UpdateUserExperienceResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserExperienceResponse.fail_text)
  return *fail_text_;
}
inline void UpdateUserExperienceResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.UpdateUserExperienceResponse.fail_text)
}
inline void UpdateUserExperienceResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.UpdateUserExperienceResponse.fail_text)
}
inline void UpdateUserExperienceResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.UpdateUserExperienceResponse.fail_text)
}
inline ::std::string* UpdateUserExperienceResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserExperienceResponse.fail_text)
  return fail_text_;
}
inline ::std::string* UpdateUserExperienceResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserExperienceResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserExperienceResponse.fail_text)
}

// optional .weizhu.user.UserExperience experience = 3;
inline bool UpdateUserExperienceResponse::has_experience() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateUserExperienceResponse::set_has_experience() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateUserExperienceResponse::clear_has_experience() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateUserExperienceResponse::clear_experience() {
  if (experience_ != NULL) experience_->::weizhu::user::UserExperience::Clear();
  clear_has_experience();
}
inline const ::weizhu::user::UserExperience& UpdateUserExperienceResponse::experience() const {
  // @@protoc_insertion_point(field_get:weizhu.user.UpdateUserExperienceResponse.experience)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return experience_ != NULL ? *experience_ : *default_instance().experience_;
#else
  return experience_ != NULL ? *experience_ : *default_instance_->experience_;
#endif
}
inline ::weizhu::user::UserExperience* UpdateUserExperienceResponse::mutable_experience() {
  set_has_experience();
  if (experience_ == NULL) experience_ = new ::weizhu::user::UserExperience;
  // @@protoc_insertion_point(field_mutable:weizhu.user.UpdateUserExperienceResponse.experience)
  return experience_;
}
inline ::weizhu::user::UserExperience* UpdateUserExperienceResponse::release_experience() {
  clear_has_experience();
  ::weizhu::user::UserExperience* temp = experience_;
  experience_ = NULL;
  return temp;
}
inline void UpdateUserExperienceResponse::set_allocated_experience(::weizhu::user::UserExperience* experience) {
  delete experience_;
  experience_ = experience;
  if (experience) {
    set_has_experience();
  } else {
    clear_has_experience();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.UpdateUserExperienceResponse.experience)
}

// -------------------------------------------------------------------

// DeleteUserExperienceRequest

// required int32 experience_id = 1;
inline bool DeleteUserExperienceRequest::has_experience_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteUserExperienceRequest::set_has_experience_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteUserExperienceRequest::clear_has_experience_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteUserExperienceRequest::clear_experience_id() {
  experience_id_ = 0;
  clear_has_experience_id();
}
inline ::google::protobuf::int32 DeleteUserExperienceRequest::experience_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.DeleteUserExperienceRequest.experience_id)
  return experience_id_;
}
inline void DeleteUserExperienceRequest::set_experience_id(::google::protobuf::int32 value) {
  set_has_experience_id();
  experience_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.DeleteUserExperienceRequest.experience_id)
}

// -------------------------------------------------------------------

// DeleteUserExperienceResponse

// optional .weizhu.user.DeleteUserExperienceResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool DeleteUserExperienceResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteUserExperienceResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteUserExperienceResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteUserExperienceResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::DeleteUserExperienceResponse_Result DeleteUserExperienceResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.DeleteUserExperienceResponse.result)
  return static_cast< ::weizhu::user::DeleteUserExperienceResponse_Result >(result_);
}
inline void DeleteUserExperienceResponse::set_result(::weizhu::user::DeleteUserExperienceResponse_Result value) {
  assert(::weizhu::user::DeleteUserExperienceResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.DeleteUserExperienceResponse.result)
}

// optional string fail_text = 2;
inline bool DeleteUserExperienceResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteUserExperienceResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteUserExperienceResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteUserExperienceResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& DeleteUserExperienceResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.DeleteUserExperienceResponse.fail_text)
  return *fail_text_;
}
inline void DeleteUserExperienceResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.DeleteUserExperienceResponse.fail_text)
}
inline void DeleteUserExperienceResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.DeleteUserExperienceResponse.fail_text)
}
inline void DeleteUserExperienceResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.DeleteUserExperienceResponse.fail_text)
}
inline ::std::string* DeleteUserExperienceResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.DeleteUserExperienceResponse.fail_text)
  return fail_text_;
}
inline ::std::string* DeleteUserExperienceResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteUserExperienceResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.DeleteUserExperienceResponse.fail_text)
}

// -------------------------------------------------------------------

// MarkUserNameRequest

// required int64 user_id = 1;
inline bool MarkUserNameRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkUserNameRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkUserNameRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkUserNameRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 MarkUserNameRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserNameRequest.user_id)
  return user_id_;
}
inline void MarkUserNameRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserNameRequest.user_id)
}

// optional string mark_name = 2;
inline bool MarkUserNameRequest::has_mark_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkUserNameRequest::set_has_mark_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkUserNameRequest::clear_has_mark_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkUserNameRequest::clear_mark_name() {
  if (mark_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_->clear();
  }
  clear_has_mark_name();
}
inline const ::std::string& MarkUserNameRequest::mark_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserNameRequest.mark_name)
  return *mark_name_;
}
inline void MarkUserNameRequest::set_mark_name(const ::std::string& value) {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  mark_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserNameRequest.mark_name)
}
inline void MarkUserNameRequest::set_mark_name(const char* value) {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  mark_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.MarkUserNameRequest.mark_name)
}
inline void MarkUserNameRequest::set_mark_name(const char* value, size_t size) {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  mark_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.MarkUserNameRequest.mark_name)
}
inline ::std::string* MarkUserNameRequest::mutable_mark_name() {
  set_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mark_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.MarkUserNameRequest.mark_name)
  return mark_name_;
}
inline ::std::string* MarkUserNameRequest::release_mark_name() {
  clear_has_mark_name();
  if (mark_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mark_name_;
    mark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarkUserNameRequest::set_allocated_mark_name(::std::string* mark_name) {
  if (mark_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mark_name_;
  }
  if (mark_name) {
    set_has_mark_name();
    mark_name_ = mark_name;
  } else {
    clear_has_mark_name();
    mark_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.MarkUserNameRequest.mark_name)
}

// -------------------------------------------------------------------

// MarkUserNameResponse

// optional .weizhu.user.MarkUserNameResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool MarkUserNameResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkUserNameResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkUserNameResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkUserNameResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::MarkUserNameResponse_Result MarkUserNameResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserNameResponse.result)
  return static_cast< ::weizhu::user::MarkUserNameResponse_Result >(result_);
}
inline void MarkUserNameResponse::set_result(::weizhu::user::MarkUserNameResponse_Result value) {
  assert(::weizhu::user::MarkUserNameResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserNameResponse.result)
}

// optional string fail_text = 2;
inline bool MarkUserNameResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkUserNameResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkUserNameResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkUserNameResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& MarkUserNameResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserNameResponse.fail_text)
  return *fail_text_;
}
inline void MarkUserNameResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserNameResponse.fail_text)
}
inline void MarkUserNameResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.MarkUserNameResponse.fail_text)
}
inline void MarkUserNameResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.MarkUserNameResponse.fail_text)
}
inline ::std::string* MarkUserNameResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.MarkUserNameResponse.fail_text)
  return fail_text_;
}
inline ::std::string* MarkUserNameResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarkUserNameResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.MarkUserNameResponse.fail_text)
}

// -------------------------------------------------------------------

// MarkUserStarRequest

// required int64 user_id = 1;
inline bool MarkUserStarRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkUserStarRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkUserStarRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkUserStarRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 MarkUserStarRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserStarRequest.user_id)
  return user_id_;
}
inline void MarkUserStarRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserStarRequest.user_id)
}

// required bool is_star = 2;
inline bool MarkUserStarRequest::has_is_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkUserStarRequest::set_has_is_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkUserStarRequest::clear_has_is_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkUserStarRequest::clear_is_star() {
  is_star_ = false;
  clear_has_is_star();
}
inline bool MarkUserStarRequest::is_star() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserStarRequest.is_star)
  return is_star_;
}
inline void MarkUserStarRequest::set_is_star(bool value) {
  set_has_is_star();
  is_star_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserStarRequest.is_star)
}

// -------------------------------------------------------------------

// MarkUserStarResponse

// optional .weizhu.user.MarkUserStarResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool MarkUserStarResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkUserStarResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkUserStarResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkUserStarResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::MarkUserStarResponse_Result MarkUserStarResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserStarResponse.result)
  return static_cast< ::weizhu::user::MarkUserStarResponse_Result >(result_);
}
inline void MarkUserStarResponse::set_result(::weizhu::user::MarkUserStarResponse_Result value) {
  assert(::weizhu::user::MarkUserStarResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserStarResponse.result)
}

// optional string fail_text = 2;
inline bool MarkUserStarResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkUserStarResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkUserStarResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkUserStarResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& MarkUserStarResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.MarkUserStarResponse.fail_text)
  return *fail_text_;
}
inline void MarkUserStarResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.MarkUserStarResponse.fail_text)
}
inline void MarkUserStarResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.MarkUserStarResponse.fail_text)
}
inline void MarkUserStarResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.MarkUserStarResponse.fail_text)
}
inline ::std::string* MarkUserStarResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.MarkUserStarResponse.fail_text)
  return fail_text_;
}
inline ::std::string* MarkUserStarResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarkUserStarResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.MarkUserStarResponse.fail_text)
}

// -------------------------------------------------------------------

// GetMarkStarUserRequest

// -------------------------------------------------------------------

// GetMarkStarUserResponse

// repeated .weizhu.user.User user = 1;
inline int GetMarkStarUserResponse::user_size() const {
  return user_.size();
}
inline void GetMarkStarUserResponse::clear_user() {
  user_.Clear();
}
inline const ::weizhu::user::User& GetMarkStarUserResponse::user(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetMarkStarUserResponse.user)
  return user_.Get(index);
}
inline ::weizhu::user::User* GetMarkStarUserResponse::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetMarkStarUserResponse.user)
  return user_.Mutable(index);
}
inline ::weizhu::user::User* GetMarkStarUserResponse::add_user() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetMarkStarUserResponse.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
GetMarkStarUserResponse::user() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetMarkStarUserResponse.user)
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
GetMarkStarUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetMarkStarUserResponse.user)
  return &user_;
}

// repeated .weizhu.user.Team ref_team = 2;
inline int GetMarkStarUserResponse::ref_team_size() const {
  return ref_team_.size();
}
inline void GetMarkStarUserResponse::clear_ref_team() {
  ref_team_.Clear();
}
inline const ::weizhu::user::Team& GetMarkStarUserResponse::ref_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetMarkStarUserResponse.ref_team)
  return ref_team_.Get(index);
}
inline ::weizhu::user::Team* GetMarkStarUserResponse::mutable_ref_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetMarkStarUserResponse.ref_team)
  return ref_team_.Mutable(index);
}
inline ::weizhu::user::Team* GetMarkStarUserResponse::add_ref_team() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetMarkStarUserResponse.ref_team)
  return ref_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
GetMarkStarUserResponse::ref_team() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetMarkStarUserResponse.ref_team)
  return ref_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
GetMarkStarUserResponse::mutable_ref_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetMarkStarUserResponse.ref_team)
  return &ref_team_;
}

// repeated .weizhu.user.Position ref_position = 3;
inline int GetMarkStarUserResponse::ref_position_size() const {
  return ref_position_.size();
}
inline void GetMarkStarUserResponse::clear_ref_position() {
  ref_position_.Clear();
}
inline const ::weizhu::user::Position& GetMarkStarUserResponse::ref_position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetMarkStarUserResponse.ref_position)
  return ref_position_.Get(index);
}
inline ::weizhu::user::Position* GetMarkStarUserResponse::mutable_ref_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetMarkStarUserResponse.ref_position)
  return ref_position_.Mutable(index);
}
inline ::weizhu::user::Position* GetMarkStarUserResponse::add_ref_position() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetMarkStarUserResponse.ref_position)
  return ref_position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
GetMarkStarUserResponse::ref_position() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetMarkStarUserResponse.ref_position)
  return ref_position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
GetMarkStarUserResponse::mutable_ref_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetMarkStarUserResponse.ref_position)
  return &ref_position_;
}

// repeated .weizhu.user.Level ref_level = 4;
inline int GetMarkStarUserResponse::ref_level_size() const {
  return ref_level_.size();
}
inline void GetMarkStarUserResponse::clear_ref_level() {
  ref_level_.Clear();
}
inline const ::weizhu::user::Level& GetMarkStarUserResponse::ref_level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetMarkStarUserResponse.ref_level)
  return ref_level_.Get(index);
}
inline ::weizhu::user::Level* GetMarkStarUserResponse::mutable_ref_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetMarkStarUserResponse.ref_level)
  return ref_level_.Mutable(index);
}
inline ::weizhu::user::Level* GetMarkStarUserResponse::add_ref_level() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetMarkStarUserResponse.ref_level)
  return ref_level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
GetMarkStarUserResponse::ref_level() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetMarkStarUserResponse.ref_level)
  return ref_level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
GetMarkStarUserResponse::mutable_ref_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetMarkStarUserResponse.ref_level)
  return &ref_level_;
}

// -------------------------------------------------------------------

// GetUserAbilityTagRequest

// required int64 user_id = 1;
inline bool GetUserAbilityTagRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserAbilityTagRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserAbilityTagRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserAbilityTagRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 GetUserAbilityTagRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserAbilityTagRequest.user_id)
  return user_id_;
}
inline void GetUserAbilityTagRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.GetUserAbilityTagRequest.user_id)
}

// -------------------------------------------------------------------

// GetUserAbilityTagResponse

// repeated .weizhu.user.UserAbilityTag ability_tag = 1;
inline int GetUserAbilityTagResponse::ability_tag_size() const {
  return ability_tag_.size();
}
inline void GetUserAbilityTagResponse::clear_ability_tag() {
  ability_tag_.Clear();
}
inline const ::weizhu::user::UserAbilityTag& GetUserAbilityTagResponse::ability_tag(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetUserAbilityTagResponse.ability_tag)
  return ability_tag_.Get(index);
}
inline ::weizhu::user::UserAbilityTag* GetUserAbilityTagResponse::mutable_ability_tag(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetUserAbilityTagResponse.ability_tag)
  return ability_tag_.Mutable(index);
}
inline ::weizhu::user::UserAbilityTag* GetUserAbilityTagResponse::add_ability_tag() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetUserAbilityTagResponse.ability_tag)
  return ability_tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >&
GetUserAbilityTagResponse::ability_tag() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetUserAbilityTagResponse.ability_tag)
  return ability_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >*
GetUserAbilityTagResponse::mutable_ability_tag() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetUserAbilityTagResponse.ability_tag)
  return &ability_tag_;
}

// -------------------------------------------------------------------

// TagUserAbilityRequest

// required int64 user_id = 1;
inline bool TagUserAbilityRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TagUserAbilityRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TagUserAbilityRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TagUserAbilityRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 TagUserAbilityRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.TagUserAbilityRequest.user_id)
  return user_id_;
}
inline void TagUserAbilityRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.TagUserAbilityRequest.user_id)
}

// required string tag_name = 2;
inline bool TagUserAbilityRequest::has_tag_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TagUserAbilityRequest::set_has_tag_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TagUserAbilityRequest::clear_has_tag_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TagUserAbilityRequest::clear_tag_name() {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_->clear();
  }
  clear_has_tag_name();
}
inline const ::std::string& TagUserAbilityRequest::tag_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.TagUserAbilityRequest.tag_name)
  return *tag_name_;
}
inline void TagUserAbilityRequest::set_tag_name(const ::std::string& value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.TagUserAbilityRequest.tag_name)
}
inline void TagUserAbilityRequest::set_tag_name(const char* value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.TagUserAbilityRequest.tag_name)
}
inline void TagUserAbilityRequest::set_tag_name(const char* value, size_t size) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.TagUserAbilityRequest.tag_name)
}
inline ::std::string* TagUserAbilityRequest::mutable_tag_name() {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.TagUserAbilityRequest.tag_name)
  return tag_name_;
}
inline ::std::string* TagUserAbilityRequest::release_tag_name() {
  clear_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_name_;
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TagUserAbilityRequest::set_allocated_tag_name(::std::string* tag_name) {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_name_;
  }
  if (tag_name) {
    set_has_tag_name();
    tag_name_ = tag_name;
  } else {
    clear_has_tag_name();
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.TagUserAbilityRequest.tag_name)
}

// required bool is_tag = 3;
inline bool TagUserAbilityRequest::has_is_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TagUserAbilityRequest::set_has_is_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TagUserAbilityRequest::clear_has_is_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TagUserAbilityRequest::clear_is_tag() {
  is_tag_ = false;
  clear_has_is_tag();
}
inline bool TagUserAbilityRequest::is_tag() const {
  // @@protoc_insertion_point(field_get:weizhu.user.TagUserAbilityRequest.is_tag)
  return is_tag_;
}
inline void TagUserAbilityRequest::set_is_tag(bool value) {
  set_has_is_tag();
  is_tag_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.TagUserAbilityRequest.is_tag)
}

// -------------------------------------------------------------------

// TagUserAbilityResponse

// optional .weizhu.user.TagUserAbilityResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool TagUserAbilityResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TagUserAbilityResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TagUserAbilityResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TagUserAbilityResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::TagUserAbilityResponse_Result TagUserAbilityResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.TagUserAbilityResponse.result)
  return static_cast< ::weizhu::user::TagUserAbilityResponse_Result >(result_);
}
inline void TagUserAbilityResponse::set_result(::weizhu::user::TagUserAbilityResponse_Result value) {
  assert(::weizhu::user::TagUserAbilityResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.TagUserAbilityResponse.result)
}

// optional string fail_text = 2;
inline bool TagUserAbilityResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TagUserAbilityResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TagUserAbilityResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TagUserAbilityResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& TagUserAbilityResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.TagUserAbilityResponse.fail_text)
  return *fail_text_;
}
inline void TagUserAbilityResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.TagUserAbilityResponse.fail_text)
}
inline void TagUserAbilityResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.TagUserAbilityResponse.fail_text)
}
inline void TagUserAbilityResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.TagUserAbilityResponse.fail_text)
}
inline ::std::string* TagUserAbilityResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.TagUserAbilityResponse.fail_text)
  return fail_text_;
}
inline ::std::string* TagUserAbilityResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TagUserAbilityResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.TagUserAbilityResponse.fail_text)
}

// -------------------------------------------------------------------

// CreateAbilityTagRequest

// required int64 user_id = 1;
inline bool CreateAbilityTagRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAbilityTagRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAbilityTagRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAbilityTagRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 CreateAbilityTagRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateAbilityTagRequest.user_id)
  return user_id_;
}
inline void CreateAbilityTagRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.CreateAbilityTagRequest.user_id)
}

// required string tag_name = 2;
inline bool CreateAbilityTagRequest::has_tag_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateAbilityTagRequest::set_has_tag_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateAbilityTagRequest::clear_has_tag_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateAbilityTagRequest::clear_tag_name() {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_->clear();
  }
  clear_has_tag_name();
}
inline const ::std::string& CreateAbilityTagRequest::tag_name() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateAbilityTagRequest.tag_name)
  return *tag_name_;
}
inline void CreateAbilityTagRequest::set_tag_name(const ::std::string& value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.CreateAbilityTagRequest.tag_name)
}
inline void CreateAbilityTagRequest::set_tag_name(const char* value) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.CreateAbilityTagRequest.tag_name)
}
inline void CreateAbilityTagRequest::set_tag_name(const char* value, size_t size) {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  tag_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.CreateAbilityTagRequest.tag_name)
}
inline ::std::string* CreateAbilityTagRequest::mutable_tag_name() {
  set_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.CreateAbilityTagRequest.tag_name)
  return tag_name_;
}
inline ::std::string* CreateAbilityTagRequest::release_tag_name() {
  clear_has_tag_name();
  if (tag_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_name_;
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateAbilityTagRequest::set_allocated_tag_name(::std::string* tag_name) {
  if (tag_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_name_;
  }
  if (tag_name) {
    set_has_tag_name();
    tag_name_ = tag_name;
  } else {
    clear_has_tag_name();
    tag_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.CreateAbilityTagRequest.tag_name)
}

// -------------------------------------------------------------------

// CreateAbilityTagResponse

// optional .weizhu.user.CreateAbilityTagResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool CreateAbilityTagResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAbilityTagResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAbilityTagResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAbilityTagResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::user::CreateAbilityTagResponse_Result CreateAbilityTagResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateAbilityTagResponse.result)
  return static_cast< ::weizhu::user::CreateAbilityTagResponse_Result >(result_);
}
inline void CreateAbilityTagResponse::set_result(::weizhu::user::CreateAbilityTagResponse_Result value) {
  assert(::weizhu::user::CreateAbilityTagResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.CreateAbilityTagResponse.result)
}

// optional string fail_text = 2;
inline bool CreateAbilityTagResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateAbilityTagResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateAbilityTagResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateAbilityTagResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& CreateAbilityTagResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.user.CreateAbilityTagResponse.fail_text)
  return *fail_text_;
}
inline void CreateAbilityTagResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.CreateAbilityTagResponse.fail_text)
}
inline void CreateAbilityTagResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.CreateAbilityTagResponse.fail_text)
}
inline void CreateAbilityTagResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.CreateAbilityTagResponse.fail_text)
}
inline ::std::string* CreateAbilityTagResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.CreateAbilityTagResponse.fail_text)
  return fail_text_;
}
inline ::std::string* CreateAbilityTagResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateAbilityTagResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.CreateAbilityTagResponse.fail_text)
}

// -------------------------------------------------------------------

// DeleteAbilityTagRequest

// repeated string tag_name = 1;
inline int DeleteAbilityTagRequest::tag_name_size() const {
  return tag_name_.size();
}
inline void DeleteAbilityTagRequest::clear_tag_name() {
  tag_name_.Clear();
}
inline const ::std::string& DeleteAbilityTagRequest::tag_name(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.DeleteAbilityTagRequest.tag_name)
  return tag_name_.Get(index);
}
inline ::std::string* DeleteAbilityTagRequest::mutable_tag_name(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.DeleteAbilityTagRequest.tag_name)
  return tag_name_.Mutable(index);
}
inline void DeleteAbilityTagRequest::set_tag_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.user.DeleteAbilityTagRequest.tag_name)
  tag_name_.Mutable(index)->assign(value);
}
inline void DeleteAbilityTagRequest::set_tag_name(int index, const char* value) {
  tag_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.DeleteAbilityTagRequest.tag_name)
}
inline void DeleteAbilityTagRequest::set_tag_name(int index, const char* value, size_t size) {
  tag_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.DeleteAbilityTagRequest.tag_name)
}
inline ::std::string* DeleteAbilityTagRequest::add_tag_name() {
  return tag_name_.Add();
}
inline void DeleteAbilityTagRequest::add_tag_name(const ::std::string& value) {
  tag_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.user.DeleteAbilityTagRequest.tag_name)
}
inline void DeleteAbilityTagRequest::add_tag_name(const char* value) {
  tag_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.user.DeleteAbilityTagRequest.tag_name)
}
inline void DeleteAbilityTagRequest::add_tag_name(const char* value, size_t size) {
  tag_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.user.DeleteAbilityTagRequest.tag_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteAbilityTagRequest::tag_name() const {
  // @@protoc_insertion_point(field_list:weizhu.user.DeleteAbilityTagRequest.tag_name)
  return tag_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteAbilityTagRequest::mutable_tag_name() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.DeleteAbilityTagRequest.tag_name)
  return &tag_name_;
}

// -------------------------------------------------------------------

// GetRandomAbilityTagUserRequest

// repeated string tag_name = 1;
inline int GetRandomAbilityTagUserRequest::tag_name_size() const {
  return tag_name_.size();
}
inline void GetRandomAbilityTagUserRequest::clear_tag_name() {
  tag_name_.Clear();
}
inline const ::std::string& GetRandomAbilityTagUserRequest::tag_name(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
  return tag_name_.Get(index);
}
inline ::std::string* GetRandomAbilityTagUserRequest::mutable_tag_name(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
  return tag_name_.Mutable(index);
}
inline void GetRandomAbilityTagUserRequest::set_tag_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
  tag_name_.Mutable(index)->assign(value);
}
inline void GetRandomAbilityTagUserRequest::set_tag_name(int index, const char* value) {
  tag_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
}
inline void GetRandomAbilityTagUserRequest::set_tag_name(int index, const char* value, size_t size) {
  tag_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
}
inline ::std::string* GetRandomAbilityTagUserRequest::add_tag_name() {
  return tag_name_.Add();
}
inline void GetRandomAbilityTagUserRequest::add_tag_name(const ::std::string& value) {
  tag_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
}
inline void GetRandomAbilityTagUserRequest::add_tag_name(const char* value) {
  tag_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
}
inline void GetRandomAbilityTagUserRequest::add_tag_name(const char* value, size_t size) {
  tag_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetRandomAbilityTagUserRequest::tag_name() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
  return tag_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetRandomAbilityTagUserRequest::mutable_tag_name() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetRandomAbilityTagUserRequest.tag_name)
  return &tag_name_;
}

// optional bool is_expert = 2;
inline bool GetRandomAbilityTagUserRequest::has_is_expert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRandomAbilityTagUserRequest::set_has_is_expert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetRandomAbilityTagUserRequest::clear_has_is_expert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetRandomAbilityTagUserRequest::clear_is_expert() {
  is_expert_ = false;
  clear_has_is_expert();
}
inline bool GetRandomAbilityTagUserRequest::is_expert() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserRequest.is_expert)
  return is_expert_;
}
inline void GetRandomAbilityTagUserRequest::set_is_expert(bool value) {
  set_has_is_expert();
  is_expert_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.GetRandomAbilityTagUserRequest.is_expert)
}

// required int32 size = 3;
inline bool GetRandomAbilityTagUserRequest::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetRandomAbilityTagUserRequest::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetRandomAbilityTagUserRequest::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetRandomAbilityTagUserRequest::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 GetRandomAbilityTagUserRequest::size() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserRequest.size)
  return size_;
}
inline void GetRandomAbilityTagUserRequest::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.GetRandomAbilityTagUserRequest.size)
}

// -------------------------------------------------------------------

// GetRandomAbilityTagUserResponse

// repeated .weizhu.user.User user = 1;
inline int GetRandomAbilityTagUserResponse::user_size() const {
  return user_.size();
}
inline void GetRandomAbilityTagUserResponse::clear_user() {
  user_.Clear();
}
inline const ::weizhu::user::User& GetRandomAbilityTagUserResponse::user(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserResponse.user)
  return user_.Get(index);
}
inline ::weizhu::user::User* GetRandomAbilityTagUserResponse::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetRandomAbilityTagUserResponse.user)
  return user_.Mutable(index);
}
inline ::weizhu::user::User* GetRandomAbilityTagUserResponse::add_user() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetRandomAbilityTagUserResponse.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
GetRandomAbilityTagUserResponse::user() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetRandomAbilityTagUserResponse.user)
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
GetRandomAbilityTagUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetRandomAbilityTagUserResponse.user)
  return &user_;
}

// repeated .weizhu.user.Team ref_team = 2;
inline int GetRandomAbilityTagUserResponse::ref_team_size() const {
  return ref_team_.size();
}
inline void GetRandomAbilityTagUserResponse::clear_ref_team() {
  ref_team_.Clear();
}
inline const ::weizhu::user::Team& GetRandomAbilityTagUserResponse::ref_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserResponse.ref_team)
  return ref_team_.Get(index);
}
inline ::weizhu::user::Team* GetRandomAbilityTagUserResponse::mutable_ref_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetRandomAbilityTagUserResponse.ref_team)
  return ref_team_.Mutable(index);
}
inline ::weizhu::user::Team* GetRandomAbilityTagUserResponse::add_ref_team() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetRandomAbilityTagUserResponse.ref_team)
  return ref_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
GetRandomAbilityTagUserResponse::ref_team() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_team)
  return ref_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
GetRandomAbilityTagUserResponse::mutable_ref_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_team)
  return &ref_team_;
}

// repeated .weizhu.user.Position ref_position = 3;
inline int GetRandomAbilityTagUserResponse::ref_position_size() const {
  return ref_position_.size();
}
inline void GetRandomAbilityTagUserResponse::clear_ref_position() {
  ref_position_.Clear();
}
inline const ::weizhu::user::Position& GetRandomAbilityTagUserResponse::ref_position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserResponse.ref_position)
  return ref_position_.Get(index);
}
inline ::weizhu::user::Position* GetRandomAbilityTagUserResponse::mutable_ref_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetRandomAbilityTagUserResponse.ref_position)
  return ref_position_.Mutable(index);
}
inline ::weizhu::user::Position* GetRandomAbilityTagUserResponse::add_ref_position() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetRandomAbilityTagUserResponse.ref_position)
  return ref_position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
GetRandomAbilityTagUserResponse::ref_position() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_position)
  return ref_position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
GetRandomAbilityTagUserResponse::mutable_ref_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_position)
  return &ref_position_;
}

// repeated .weizhu.user.Level ref_level = 4;
inline int GetRandomAbilityTagUserResponse::ref_level_size() const {
  return ref_level_.size();
}
inline void GetRandomAbilityTagUserResponse::clear_ref_level() {
  ref_level_.Clear();
}
inline const ::weizhu::user::Level& GetRandomAbilityTagUserResponse::ref_level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserResponse.ref_level)
  return ref_level_.Get(index);
}
inline ::weizhu::user::Level* GetRandomAbilityTagUserResponse::mutable_ref_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetRandomAbilityTagUserResponse.ref_level)
  return ref_level_.Mutable(index);
}
inline ::weizhu::user::Level* GetRandomAbilityTagUserResponse::add_ref_level() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetRandomAbilityTagUserResponse.ref_level)
  return ref_level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
GetRandomAbilityTagUserResponse::ref_level() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_level)
  return ref_level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
GetRandomAbilityTagUserResponse::mutable_ref_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_level)
  return &ref_level_;
}

// repeated .weizhu.user.UserAbilityTag ref_ability_tag = 5;
inline int GetRandomAbilityTagUserResponse::ref_ability_tag_size() const {
  return ref_ability_tag_.size();
}
inline void GetRandomAbilityTagUserResponse::clear_ref_ability_tag() {
  ref_ability_tag_.Clear();
}
inline const ::weizhu::user::UserAbilityTag& GetRandomAbilityTagUserResponse::ref_ability_tag(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetRandomAbilityTagUserResponse.ref_ability_tag)
  return ref_ability_tag_.Get(index);
}
inline ::weizhu::user::UserAbilityTag* GetRandomAbilityTagUserResponse::mutable_ref_ability_tag(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetRandomAbilityTagUserResponse.ref_ability_tag)
  return ref_ability_tag_.Mutable(index);
}
inline ::weizhu::user::UserAbilityTag* GetRandomAbilityTagUserResponse::add_ref_ability_tag() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetRandomAbilityTagUserResponse.ref_ability_tag)
  return ref_ability_tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >&
GetRandomAbilityTagUserResponse::ref_ability_tag() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_ability_tag)
  return ref_ability_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::UserAbilityTag >*
GetRandomAbilityTagUserResponse::mutable_ref_ability_tag() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetRandomAbilityTagUserResponse.ref_ability_tag)
  return &ref_ability_tag_;
}

// -------------------------------------------------------------------

// GetAbilityTagUserIdRequest

// repeated string tag_name = 1;
inline int GetAbilityTagUserIdRequest::tag_name_size() const {
  return tag_name_.size();
}
inline void GetAbilityTagUserIdRequest::clear_tag_name() {
  tag_name_.Clear();
}
inline const ::std::string& GetAbilityTagUserIdRequest::tag_name(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
  return tag_name_.Get(index);
}
inline ::std::string* GetAbilityTagUserIdRequest::mutable_tag_name(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
  return tag_name_.Mutable(index);
}
inline void GetAbilityTagUserIdRequest::set_tag_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
  tag_name_.Mutable(index)->assign(value);
}
inline void GetAbilityTagUserIdRequest::set_tag_name(int index, const char* value) {
  tag_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
}
inline void GetAbilityTagUserIdRequest::set_tag_name(int index, const char* value, size_t size) {
  tag_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
}
inline ::std::string* GetAbilityTagUserIdRequest::add_tag_name() {
  return tag_name_.Add();
}
inline void GetAbilityTagUserIdRequest::add_tag_name(const ::std::string& value) {
  tag_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
}
inline void GetAbilityTagUserIdRequest::add_tag_name(const char* value) {
  tag_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
}
inline void GetAbilityTagUserIdRequest::add_tag_name(const char* value, size_t size) {
  tag_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetAbilityTagUserIdRequest::tag_name() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
  return tag_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetAbilityTagUserIdRequest::mutable_tag_name() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetAbilityTagUserIdRequest.tag_name)
  return &tag_name_;
}

// optional bool is_expert = 2;
inline bool GetAbilityTagUserIdRequest::has_is_expert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAbilityTagUserIdRequest::set_has_is_expert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAbilityTagUserIdRequest::clear_has_is_expert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAbilityTagUserIdRequest::clear_is_expert() {
  is_expert_ = false;
  clear_has_is_expert();
}
inline bool GetAbilityTagUserIdRequest::is_expert() const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetAbilityTagUserIdRequest.is_expert)
  return is_expert_;
}
inline void GetAbilityTagUserIdRequest::set_is_expert(bool value) {
  set_has_is_expert();
  is_expert_ = value;
  // @@protoc_insertion_point(field_set:weizhu.user.GetAbilityTagUserIdRequest.is_expert)
}

// -------------------------------------------------------------------

// GetAbilityTagUserIdResponse

// repeated int64 user_id = 1;
inline int GetAbilityTagUserIdResponse::user_id_size() const {
  return user_id_.size();
}
inline void GetAbilityTagUserIdResponse::clear_user_id() {
  user_id_.Clear();
}
inline ::google::protobuf::int64 GetAbilityTagUserIdResponse::user_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetAbilityTagUserIdResponse.user_id)
  return user_id_.Get(index);
}
inline void GetAbilityTagUserIdResponse::set_user_id(int index, ::google::protobuf::int64 value) {
  user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.user.GetAbilityTagUserIdResponse.user_id)
}
inline void GetAbilityTagUserIdResponse::add_user_id(::google::protobuf::int64 value) {
  user_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.user.GetAbilityTagUserIdResponse.user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetAbilityTagUserIdResponse::user_id() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetAbilityTagUserIdResponse.user_id)
  return user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetAbilityTagUserIdResponse::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetAbilityTagUserIdResponse.user_id)
  return &user_id_;
}

// -------------------------------------------------------------------

// GetAllPositionRequest

// -------------------------------------------------------------------

// GetAllPositionResponse

// repeated .weizhu.user.Position position = 1;
inline int GetAllPositionResponse::position_size() const {
  return position_.size();
}
inline void GetAllPositionResponse::clear_position() {
  position_.Clear();
}
inline const ::weizhu::user::Position& GetAllPositionResponse::position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetAllPositionResponse.position)
  return position_.Get(index);
}
inline ::weizhu::user::Position* GetAllPositionResponse::mutable_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetAllPositionResponse.position)
  return position_.Mutable(index);
}
inline ::weizhu::user::Position* GetAllPositionResponse::add_position() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetAllPositionResponse.position)
  return position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
GetAllPositionResponse::position() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetAllPositionResponse.position)
  return position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
GetAllPositionResponse::mutable_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetAllPositionResponse.position)
  return &position_;
}

// -------------------------------------------------------------------

// GetAllLevelRequest

// -------------------------------------------------------------------

// GetAllLevelResponse

// repeated .weizhu.user.Level level = 1;
inline int GetAllLevelResponse::level_size() const {
  return level_.size();
}
inline void GetAllLevelResponse::clear_level() {
  level_.Clear();
}
inline const ::weizhu::user::Level& GetAllLevelResponse::level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.GetAllLevelResponse.level)
  return level_.Get(index);
}
inline ::weizhu::user::Level* GetAllLevelResponse::mutable_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.GetAllLevelResponse.level)
  return level_.Mutable(index);
}
inline ::weizhu::user::Level* GetAllLevelResponse::add_level() {
  // @@protoc_insertion_point(field_add:weizhu.user.GetAllLevelResponse.level)
  return level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
GetAllLevelResponse::level() const {
  // @@protoc_insertion_point(field_list:weizhu.user.GetAllLevelResponse.level)
  return level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
GetAllLevelResponse::mutable_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.GetAllLevelResponse.level)
  return &level_;
}

// -------------------------------------------------------------------

// SearchUserRequest

// required string keyword = 1;
inline bool SearchUserRequest::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchUserRequest::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchUserRequest::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchUserRequest::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& SearchUserRequest::keyword() const {
  // @@protoc_insertion_point(field_get:weizhu.user.SearchUserRequest.keyword)
  return *keyword_;
}
inline void SearchUserRequest::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.user.SearchUserRequest.keyword)
}
inline void SearchUserRequest::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.user.SearchUserRequest.keyword)
}
inline void SearchUserRequest::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.user.SearchUserRequest.keyword)
}
inline ::std::string* SearchUserRequest::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyword_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.user.SearchUserRequest.keyword)
  return keyword_;
}
inline ::std::string* SearchUserRequest::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SearchUserRequest::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.user.SearchUserRequest.keyword)
}

// -------------------------------------------------------------------

// SearchUserResponse

// repeated .weizhu.user.User user = 1;
inline int SearchUserResponse::user_size() const {
  return user_.size();
}
inline void SearchUserResponse::clear_user() {
  user_.Clear();
}
inline const ::weizhu::user::User& SearchUserResponse::user(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.SearchUserResponse.user)
  return user_.Get(index);
}
inline ::weizhu::user::User* SearchUserResponse::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.SearchUserResponse.user)
  return user_.Mutable(index);
}
inline ::weizhu::user::User* SearchUserResponse::add_user() {
  // @@protoc_insertion_point(field_add:weizhu.user.SearchUserResponse.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >&
SearchUserResponse::user() const {
  // @@protoc_insertion_point(field_list:weizhu.user.SearchUserResponse.user)
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::User >*
SearchUserResponse::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.SearchUserResponse.user)
  return &user_;
}

// repeated .weizhu.user.Team ref_team = 2;
inline int SearchUserResponse::ref_team_size() const {
  return ref_team_.size();
}
inline void SearchUserResponse::clear_ref_team() {
  ref_team_.Clear();
}
inline const ::weizhu::user::Team& SearchUserResponse::ref_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.SearchUserResponse.ref_team)
  return ref_team_.Get(index);
}
inline ::weizhu::user::Team* SearchUserResponse::mutable_ref_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.SearchUserResponse.ref_team)
  return ref_team_.Mutable(index);
}
inline ::weizhu::user::Team* SearchUserResponse::add_ref_team() {
  // @@protoc_insertion_point(field_add:weizhu.user.SearchUserResponse.ref_team)
  return ref_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
SearchUserResponse::ref_team() const {
  // @@protoc_insertion_point(field_list:weizhu.user.SearchUserResponse.ref_team)
  return ref_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
SearchUserResponse::mutable_ref_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.SearchUserResponse.ref_team)
  return &ref_team_;
}

// repeated .weizhu.user.Position ref_position = 3;
inline int SearchUserResponse::ref_position_size() const {
  return ref_position_.size();
}
inline void SearchUserResponse::clear_ref_position() {
  ref_position_.Clear();
}
inline const ::weizhu::user::Position& SearchUserResponse::ref_position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.SearchUserResponse.ref_position)
  return ref_position_.Get(index);
}
inline ::weizhu::user::Position* SearchUserResponse::mutable_ref_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.SearchUserResponse.ref_position)
  return ref_position_.Mutable(index);
}
inline ::weizhu::user::Position* SearchUserResponse::add_ref_position() {
  // @@protoc_insertion_point(field_add:weizhu.user.SearchUserResponse.ref_position)
  return ref_position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
SearchUserResponse::ref_position() const {
  // @@protoc_insertion_point(field_list:weizhu.user.SearchUserResponse.ref_position)
  return ref_position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
SearchUserResponse::mutable_ref_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.SearchUserResponse.ref_position)
  return &ref_position_;
}

// repeated .weizhu.user.Level ref_level = 4;
inline int SearchUserResponse::ref_level_size() const {
  return ref_level_.size();
}
inline void SearchUserResponse::clear_ref_level() {
  ref_level_.Clear();
}
inline const ::weizhu::user::Level& SearchUserResponse::ref_level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.user.SearchUserResponse.ref_level)
  return ref_level_.Get(index);
}
inline ::weizhu::user::Level* SearchUserResponse::mutable_ref_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.user.SearchUserResponse.ref_level)
  return ref_level_.Mutable(index);
}
inline ::weizhu::user::Level* SearchUserResponse::add_ref_level() {
  // @@protoc_insertion_point(field_add:weizhu.user.SearchUserResponse.ref_level)
  return ref_level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
SearchUserResponse::ref_level() const {
  // @@protoc_insertion_point(field_list:weizhu.user.SearchUserResponse.ref_level)
  return ref_level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
SearchUserResponse::mutable_ref_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.user.SearchUserResponse.ref_level)
  return &ref_level_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace user
}  // namespace weizhu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
