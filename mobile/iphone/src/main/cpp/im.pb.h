// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#ifndef PROTOBUF_im_2eproto__INCLUDED
#define PROTOBUF_im_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace weizhu {
namespace im {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_im_2eproto();
void protobuf_AssignDesc_im_2eproto();
void protobuf_ShutdownFile_im_2eproto();

class InstantMessage;
class InstantMessage_Text;
class InstantMessage_Voice;
class InstantMessage_Image;
class InstantMessage_User;
class InstantMessage_Video;
class InstantMessage_File;
class InstantMessage_Group;
class InstantMessage_DiscoverItem;
class P2PChat;
class GroupChat;
class GroupChat_Member;
class IMP2PMessagePush;
class IMP2PStatePush;
class IMGroupStatePush;
class GetP2PMessageRequest;
class GetGroupMessageRequest;
class GetMessageResponse;
class SendP2PMessageRequest;
class SendP2PMessageResponse;
class GetP2PChatListRequest;
class GetP2PChatListResponse;
class GetGroupChatByIdRequest;
class GetGroupChatByIdResponse;
class CreateGroupChatRequest;
class CreateGroupChatResponse;
class SetGroupNameRequest;
class SetGroupNameResponse;
class JoinGroupChatRequest;
class JoinGroupChatResponse;
class LeaveGroupChatRequest;
class LeaveGroupChatResponse;
class SendGroupMessageRequest;
class SendGroupMessageResponse;
class GetGroupChatListRequest;
class GetGroupChatListResponse;

enum SendP2PMessageResponse_Result {
  SendP2PMessageResponse_Result_SUCC = 0,
  SendP2PMessageResponse_Result_FAIL_USER_NOT_EXIST = 1,
  SendP2PMessageResponse_Result_FAIL_MSG_INVALID = 2,
  SendP2PMessageResponse_Result_FAIL_UNKNOWN = 99
};
bool SendP2PMessageResponse_Result_IsValid(int value);
const SendP2PMessageResponse_Result SendP2PMessageResponse_Result_Result_MIN = SendP2PMessageResponse_Result_SUCC;
const SendP2PMessageResponse_Result SendP2PMessageResponse_Result_Result_MAX = SendP2PMessageResponse_Result_FAIL_UNKNOWN;
const int SendP2PMessageResponse_Result_Result_ARRAYSIZE = SendP2PMessageResponse_Result_Result_MAX + 1;

enum CreateGroupChatResponse_Result {
  CreateGroupChatResponse_Result_SUCC = 0,
  CreateGroupChatResponse_Result_FAIL_NAME_INVALID = 1,
  CreateGroupChatResponse_Result_FAIL_MEMBER_EMPTY = 2,
  CreateGroupChatResponse_Result_FAIL_MEMBER_INVALID = 3,
  CreateGroupChatResponse_Result_FAIL_MEMBER_NUM_LIMITED = 4,
  CreateGroupChatResponse_Result_FAIL_UNKNOWN = 99
};
bool CreateGroupChatResponse_Result_IsValid(int value);
const CreateGroupChatResponse_Result CreateGroupChatResponse_Result_Result_MIN = CreateGroupChatResponse_Result_SUCC;
const CreateGroupChatResponse_Result CreateGroupChatResponse_Result_Result_MAX = CreateGroupChatResponse_Result_FAIL_UNKNOWN;
const int CreateGroupChatResponse_Result_Result_ARRAYSIZE = CreateGroupChatResponse_Result_Result_MAX + 1;

enum SetGroupNameResponse_Result {
  SetGroupNameResponse_Result_SUCC = 0,
  SetGroupNameResponse_Result_FAIL_GROUP_NOT_EXIST = 1,
  SetGroupNameResponse_Result_FAIL_GROUP_NOT_JOIN = 2,
  SetGroupNameResponse_Result_FAIL_NAME_INVALID = 3,
  SetGroupNameResponse_Result_FAIL_UNKNOWN = 99
};
bool SetGroupNameResponse_Result_IsValid(int value);
const SetGroupNameResponse_Result SetGroupNameResponse_Result_Result_MIN = SetGroupNameResponse_Result_SUCC;
const SetGroupNameResponse_Result SetGroupNameResponse_Result_Result_MAX = SetGroupNameResponse_Result_FAIL_UNKNOWN;
const int SetGroupNameResponse_Result_Result_ARRAYSIZE = SetGroupNameResponse_Result_Result_MAX + 1;

enum JoinGroupChatResponse_Result {
  JoinGroupChatResponse_Result_SUCC = 0,
  JoinGroupChatResponse_Result_FAIL_GROUP_NOT_EXIST = 1,
  JoinGroupChatResponse_Result_FAIL_GROUP_NOT_JOIN = 2,
  JoinGroupChatResponse_Result_FAIL_USER_EMPTY = 3,
  JoinGroupChatResponse_Result_FAIL_USER_INVALID = 4,
  JoinGroupChatResponse_Result_FAIL_MEMBER_NUM_LIMITED = 5,
  JoinGroupChatResponse_Result_FAIL_UNKNOWN = 99
};
bool JoinGroupChatResponse_Result_IsValid(int value);
const JoinGroupChatResponse_Result JoinGroupChatResponse_Result_Result_MIN = JoinGroupChatResponse_Result_SUCC;
const JoinGroupChatResponse_Result JoinGroupChatResponse_Result_Result_MAX = JoinGroupChatResponse_Result_FAIL_UNKNOWN;
const int JoinGroupChatResponse_Result_Result_ARRAYSIZE = JoinGroupChatResponse_Result_Result_MAX + 1;

enum LeaveGroupChatResponse_Result {
  LeaveGroupChatResponse_Result_SUCC = 0,
  LeaveGroupChatResponse_Result_FAIL_GROUP_NOT_EXIST = 1,
  LeaveGroupChatResponse_Result_FAIL_GROUP_NOT_JOIN = 2,
  LeaveGroupChatResponse_Result_FAIL_UNKNOWN = 99
};
bool LeaveGroupChatResponse_Result_IsValid(int value);
const LeaveGroupChatResponse_Result LeaveGroupChatResponse_Result_Result_MIN = LeaveGroupChatResponse_Result_SUCC;
const LeaveGroupChatResponse_Result LeaveGroupChatResponse_Result_Result_MAX = LeaveGroupChatResponse_Result_FAIL_UNKNOWN;
const int LeaveGroupChatResponse_Result_Result_ARRAYSIZE = LeaveGroupChatResponse_Result_Result_MAX + 1;

enum SendGroupMessageResponse_Result {
  SendGroupMessageResponse_Result_SUCC = 0,
  SendGroupMessageResponse_Result_FAIL_GROUP_NOT_EXIST = 1,
  SendGroupMessageResponse_Result_FAIL_GROUP_NOT_JOIN = 2,
  SendGroupMessageResponse_Result_FAIL_MSG_INVALID = 3,
  SendGroupMessageResponse_Result_FAIL_UNKNOWN = 99
};
bool SendGroupMessageResponse_Result_IsValid(int value);
const SendGroupMessageResponse_Result SendGroupMessageResponse_Result_Result_MIN = SendGroupMessageResponse_Result_SUCC;
const SendGroupMessageResponse_Result SendGroupMessageResponse_Result_Result_MAX = SendGroupMessageResponse_Result_FAIL_UNKNOWN;
const int SendGroupMessageResponse_Result_Result_ARRAYSIZE = SendGroupMessageResponse_Result_Result_MAX + 1;

// ===================================================================

class InstantMessage_Text : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_Text();
  virtual ~InstantMessage_Text();

  InstantMessage_Text(const InstantMessage_Text& from);

  inline InstantMessage_Text& operator=(const InstantMessage_Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_Text& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_Text* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_Text* other);

  // implements Message ----------------------------------------------

  InstantMessage_Text* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_Text& from);
  void MergeFrom(const InstantMessage_Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.Text)
 private:
  inline void set_has_content();
  inline void clear_has_content();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* content_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_Text* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage_Voice : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_Voice();
  virtual ~InstantMessage_Voice();

  InstantMessage_Voice(const InstantMessage_Voice& from);

  inline InstantMessage_Voice& operator=(const InstantMessage_Voice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_Voice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_Voice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_Voice* other);

  // implements Message ----------------------------------------------

  InstantMessage_Voice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_Voice& from);
  void MergeFrom(const InstantMessage_Voice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.Voice)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::google::protobuf::int32 duration_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_Voice* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage_Image : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_Image();
  virtual ~InstantMessage_Image();

  InstantMessage_Image(const InstantMessage_Image& from);

  inline InstantMessage_Image& operator=(const InstantMessage_Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_Image& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_Image* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_Image* other);

  // implements Message ----------------------------------------------

  InstantMessage_Image* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_Image& from);
  void MergeFrom(const InstantMessage_Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.Image)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_Image* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage_User : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_User();
  virtual ~InstantMessage_User();

  InstantMessage_User(const InstantMessage_User& from);

  inline InstantMessage_User& operator=(const InstantMessage_User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_User& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_User* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_User* other);

  // implements Message ----------------------------------------------

  InstantMessage_User* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_User& from);
  void MergeFrom(const InstantMessage_User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.User)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_User* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage_Video : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_Video();
  virtual ~InstantMessage_Video();

  InstantMessage_Video(const InstantMessage_Video& from);

  inline InstantMessage_Video& operator=(const InstantMessage_Video& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_Video& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_Video* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_Video* other);

  // implements Message ----------------------------------------------

  InstantMessage_Video* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_Video& from);
  void MergeFrom(const InstantMessage_Video& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // required int32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // required string image_name = 5;
  inline bool has_image_name() const;
  inline void clear_image_name();
  static const int kImageNameFieldNumber = 5;
  inline const ::std::string& image_name() const;
  inline void set_image_name(const ::std::string& value);
  inline void set_image_name(const char* value);
  inline void set_image_name(const char* value, size_t size);
  inline ::std::string* mutable_image_name();
  inline ::std::string* release_image_name();
  inline void set_allocated_image_name(::std::string* image_name);

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.Video)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_image_name();
  inline void clear_has_image_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 time_;
  ::std::string* image_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_Video* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage_File : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_File();
  virtual ~InstantMessage_File();

  InstantMessage_File(const InstantMessage_File& from);

  inline InstantMessage_File& operator=(const InstantMessage_File& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_File& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_File* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_File* other);

  // implements Message ----------------------------------------------

  InstantMessage_File* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_File& from);
  void MergeFrom(const InstantMessage_File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string orginal_name = 2;
  inline bool has_orginal_name() const;
  inline void clear_orginal_name();
  static const int kOrginalNameFieldNumber = 2;
  inline const ::std::string& orginal_name() const;
  inline void set_orginal_name(const ::std::string& value);
  inline void set_orginal_name(const char* value);
  inline void set_orginal_name(const char* value, size_t size);
  inline ::std::string* mutable_orginal_name();
  inline ::std::string* release_orginal_name();
  inline void set_allocated_orginal_name(::std::string* orginal_name);

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.File)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_orginal_name();
  inline void clear_has_orginal_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* orginal_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_File* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage_Group : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_Group();
  virtual ~InstantMessage_Group();

  InstantMessage_Group(const InstantMessage_Group& from);

  inline InstantMessage_Group& operator=(const InstantMessage_Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_Group& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_Group* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_Group* other);

  // implements Message ----------------------------------------------

  InstantMessage_Group* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_Group& from);
  void MergeFrom(const InstantMessage_Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string group_name = 1;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // repeated int64 join_user_id = 2;
  inline int join_user_id_size() const;
  inline void clear_join_user_id();
  static const int kJoinUserIdFieldNumber = 2;
  inline ::google::protobuf::int64 join_user_id(int index) const;
  inline void set_join_user_id(int index, ::google::protobuf::int64 value);
  inline void add_join_user_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      join_user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_join_user_id();

  // repeated int64 leave_user_id = 3;
  inline int leave_user_id_size() const;
  inline void clear_leave_user_id();
  static const int kLeaveUserIdFieldNumber = 3;
  inline ::google::protobuf::int64 leave_user_id(int index) const;
  inline void set_leave_user_id(int index, ::google::protobuf::int64 value);
  inline void add_leave_user_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      leave_user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_leave_user_id();

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.Group)
 private:
  inline void set_has_group_name();
  inline void clear_has_group_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* group_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > join_user_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > leave_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_Group* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage_DiscoverItem : public ::google::protobuf::MessageLite {
 public:
  InstantMessage_DiscoverItem();
  virtual ~InstantMessage_DiscoverItem();

  InstantMessage_DiscoverItem(const InstantMessage_DiscoverItem& from);

  inline InstantMessage_DiscoverItem& operator=(const InstantMessage_DiscoverItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage_DiscoverItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage_DiscoverItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage_DiscoverItem* other);

  // implements Message ----------------------------------------------

  InstantMessage_DiscoverItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage_DiscoverItem& from);
  void MergeFrom(const InstantMessage_DiscoverItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int64 item_id() const;
  inline void set_item_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage.DiscoverItem)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 item_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage_DiscoverItem* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage : public ::google::protobuf::MessageLite {
 public:
  InstantMessage();
  virtual ~InstantMessage();

  InstantMessage(const InstantMessage& from);

  inline InstantMessage& operator=(const InstantMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const InstantMessage& default_instance();

  enum MsgTypeCase {
    kText = 5,
    kVoice = 6,
    kImage = 7,
    kUser = 8,
    kVideo = 9,
    kFile = 10,
    kGroup = 11,
    kDiscoverItem = 12,
    MSG_TYPE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstantMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstantMessage* other);

  // implements Message ----------------------------------------------

  InstantMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstantMessage& from);
  void MergeFrom(const InstantMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InstantMessage_Text Text;
  typedef InstantMessage_Voice Voice;
  typedef InstantMessage_Image Image;
  typedef InstantMessage_User User;
  typedef InstantMessage_Video Video;
  typedef InstantMessage_File File;
  typedef InstantMessage_Group Group;
  typedef InstantMessage_DiscoverItem DiscoverItem;

  // accessors -------------------------------------------------------

  // required int64 msg_seq = 1;
  inline bool has_msg_seq() const;
  inline void clear_msg_seq();
  static const int kMsgSeqFieldNumber = 1;
  inline ::google::protobuf::int64 msg_seq() const;
  inline void set_msg_seq(::google::protobuf::int64 value);

  // required int32 msg_time = 2;
  inline bool has_msg_time() const;
  inline void clear_msg_time();
  static const int kMsgTimeFieldNumber = 2;
  inline ::google::protobuf::int32 msg_time() const;
  inline void set_msg_time(::google::protobuf::int32 value);

  // required int64 from_user_id = 3;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 3;
  inline ::google::protobuf::int64 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::int64 value);

  // optional .weizhu.im.InstantMessage.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::weizhu::im::InstantMessage_Text& text() const;
  inline ::weizhu::im::InstantMessage_Text* mutable_text();
  inline ::weizhu::im::InstantMessage_Text* release_text();
  inline void set_allocated_text(::weizhu::im::InstantMessage_Text* text);

  // optional .weizhu.im.InstantMessage.Voice voice = 6;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 6;
  inline const ::weizhu::im::InstantMessage_Voice& voice() const;
  inline ::weizhu::im::InstantMessage_Voice* mutable_voice();
  inline ::weizhu::im::InstantMessage_Voice* release_voice();
  inline void set_allocated_voice(::weizhu::im::InstantMessage_Voice* voice);

  // optional .weizhu.im.InstantMessage.Image image = 7;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 7;
  inline const ::weizhu::im::InstantMessage_Image& image() const;
  inline ::weizhu::im::InstantMessage_Image* mutable_image();
  inline ::weizhu::im::InstantMessage_Image* release_image();
  inline void set_allocated_image(::weizhu::im::InstantMessage_Image* image);

  // optional .weizhu.im.InstantMessage.User user = 8;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 8;
  inline const ::weizhu::im::InstantMessage_User& user() const;
  inline ::weizhu::im::InstantMessage_User* mutable_user();
  inline ::weizhu::im::InstantMessage_User* release_user();
  inline void set_allocated_user(::weizhu::im::InstantMessage_User* user);

  // optional .weizhu.im.InstantMessage.Video video = 9;
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 9;
  inline const ::weizhu::im::InstantMessage_Video& video() const;
  inline ::weizhu::im::InstantMessage_Video* mutable_video();
  inline ::weizhu::im::InstantMessage_Video* release_video();
  inline void set_allocated_video(::weizhu::im::InstantMessage_Video* video);

  // optional .weizhu.im.InstantMessage.File file = 10;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 10;
  inline const ::weizhu::im::InstantMessage_File& file() const;
  inline ::weizhu::im::InstantMessage_File* mutable_file();
  inline ::weizhu::im::InstantMessage_File* release_file();
  inline void set_allocated_file(::weizhu::im::InstantMessage_File* file);

  // optional .weizhu.im.InstantMessage.Group group = 11;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 11;
  inline const ::weizhu::im::InstantMessage_Group& group() const;
  inline ::weizhu::im::InstantMessage_Group* mutable_group();
  inline ::weizhu::im::InstantMessage_Group* release_group();
  inline void set_allocated_group(::weizhu::im::InstantMessage_Group* group);

  // optional .weizhu.im.InstantMessage.DiscoverItem discover_item = 12;
  inline bool has_discover_item() const;
  inline void clear_discover_item();
  static const int kDiscoverItemFieldNumber = 12;
  inline const ::weizhu::im::InstantMessage_DiscoverItem& discover_item() const;
  inline ::weizhu::im::InstantMessage_DiscoverItem* mutable_discover_item();
  inline ::weizhu::im::InstantMessage_DiscoverItem* release_discover_item();
  inline void set_allocated_discover_item(::weizhu::im::InstantMessage_DiscoverItem* discover_item);

  inline MsgTypeCase msg_type_case() const;
  // @@protoc_insertion_point(class_scope:weizhu.im.InstantMessage)
 private:
  inline void set_has_msg_seq();
  inline void clear_has_msg_seq();
  inline void set_has_msg_time();
  inline void clear_has_msg_time();
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_text();
  inline void set_has_voice();
  inline void set_has_image();
  inline void set_has_user();
  inline void set_has_video();
  inline void set_has_file();
  inline void set_has_group();
  inline void set_has_discover_item();

  inline bool has_msg_type();
  void clear_msg_type();
  inline void clear_has_msg_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 msg_seq_;
  ::google::protobuf::int64 from_user_id_;
  ::google::protobuf::int32 msg_time_;
  union MsgTypeUnion {
    ::weizhu::im::InstantMessage_Text* text_;
    ::weizhu::im::InstantMessage_Voice* voice_;
    ::weizhu::im::InstantMessage_Image* image_;
    ::weizhu::im::InstantMessage_User* user_;
    ::weizhu::im::InstantMessage_Video* video_;
    ::weizhu::im::InstantMessage_File* file_;
    ::weizhu::im::InstantMessage_Group* group_;
    ::weizhu::im::InstantMessage_DiscoverItem* discover_item_;
  } msg_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static InstantMessage* default_instance_;
};
// -------------------------------------------------------------------

class P2PChat : public ::google::protobuf::MessageLite {
 public:
  P2PChat();
  virtual ~P2PChat();

  P2PChat(const P2PChat& from);

  inline P2PChat& operator=(const P2PChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const P2PChat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const P2PChat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(P2PChat* other);

  // implements Message ----------------------------------------------

  P2PChat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const P2PChat& from);
  void MergeFrom(const P2PChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required .weizhu.im.InstantMessage latest_msg = 2;
  inline bool has_latest_msg() const;
  inline void clear_latest_msg();
  static const int kLatestMsgFieldNumber = 2;
  inline const ::weizhu::im::InstantMessage& latest_msg() const;
  inline ::weizhu::im::InstantMessage* mutable_latest_msg();
  inline ::weizhu::im::InstantMessage* release_latest_msg();
  inline void set_allocated_latest_msg(::weizhu::im::InstantMessage* latest_msg);

  // @@protoc_insertion_point(class_scope:weizhu.im.P2PChat)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_msg();
  inline void clear_has_latest_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::weizhu::im::InstantMessage* latest_msg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static P2PChat* default_instance_;
};
// -------------------------------------------------------------------

class GroupChat_Member : public ::google::protobuf::MessageLite {
 public:
  GroupChat_Member();
  virtual ~GroupChat_Member();

  GroupChat_Member(const GroupChat_Member& from);

  inline GroupChat_Member& operator=(const GroupChat_Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupChat_Member& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupChat_Member* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupChat_Member* other);

  // implements Message ----------------------------------------------

  GroupChat_Member* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupChat_Member& from);
  void MergeFrom(const GroupChat_Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required int64 join_msg_seq = 2;
  inline bool has_join_msg_seq() const;
  inline void clear_join_msg_seq();
  static const int kJoinMsgSeqFieldNumber = 2;
  inline ::google::protobuf::int64 join_msg_seq() const;
  inline void set_join_msg_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GroupChat.Member)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_join_msg_seq();
  inline void clear_has_join_msg_seq();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::google::protobuf::int64 join_msg_seq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GroupChat_Member* default_instance_;
};
// -------------------------------------------------------------------

class GroupChat : public ::google::protobuf::MessageLite {
 public:
  GroupChat();
  virtual ~GroupChat();

  GroupChat(const GroupChat& from);

  inline GroupChat& operator=(const GroupChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupChat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupChat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupChat* other);

  // implements Message ----------------------------------------------

  GroupChat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupChat& from);
  void MergeFrom(const GroupChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GroupChat_Member Member;

  // accessors -------------------------------------------------------

  // required int64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // optional string group_name = 2;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // repeated .weizhu.im.GroupChat.Member member = 3;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 3;
  inline const ::weizhu::im::GroupChat_Member& member(int index) const;
  inline ::weizhu::im::GroupChat_Member* mutable_member(int index);
  inline ::weizhu::im::GroupChat_Member* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat_Member >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat_Member >*
      mutable_member();

  // optional .weizhu.im.InstantMessage latest_msg = 4;
  inline bool has_latest_msg() const;
  inline void clear_latest_msg();
  static const int kLatestMsgFieldNumber = 4;
  inline const ::weizhu::im::InstantMessage& latest_msg() const;
  inline ::weizhu::im::InstantMessage* mutable_latest_msg();
  inline ::weizhu::im::InstantMessage* release_latest_msg();
  inline void set_allocated_latest_msg(::weizhu::im::InstantMessage* latest_msg);

  // @@protoc_insertion_point(class_scope:weizhu.im.GroupChat)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_latest_msg();
  inline void clear_has_latest_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 group_id_;
  ::std::string* group_name_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat_Member > member_;
  ::weizhu::im::InstantMessage* latest_msg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GroupChat* default_instance_;
};
// -------------------------------------------------------------------

class IMP2PMessagePush : public ::google::protobuf::MessageLite {
 public:
  IMP2PMessagePush();
  virtual ~IMP2PMessagePush();

  IMP2PMessagePush(const IMP2PMessagePush& from);

  inline IMP2PMessagePush& operator=(const IMP2PMessagePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMP2PMessagePush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMP2PMessagePush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMP2PMessagePush* other);

  // implements Message ----------------------------------------------

  IMP2PMessagePush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMP2PMessagePush& from);
  void MergeFrom(const IMP2PMessagePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required .weizhu.im.InstantMessage msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::weizhu::im::InstantMessage& msg() const;
  inline ::weizhu::im::InstantMessage* mutable_msg();
  inline ::weizhu::im::InstantMessage* release_msg();
  inline void set_allocated_msg(::weizhu::im::InstantMessage* msg);

  // @@protoc_insertion_point(class_scope:weizhu.im.IMP2PMessagePush)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::weizhu::im::InstantMessage* msg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static IMP2PMessagePush* default_instance_;
};
// -------------------------------------------------------------------

class IMP2PStatePush : public ::google::protobuf::MessageLite {
 public:
  IMP2PStatePush();
  virtual ~IMP2PStatePush();

  IMP2PStatePush(const IMP2PStatePush& from);

  inline IMP2PStatePush& operator=(const IMP2PStatePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMP2PStatePush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMP2PStatePush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMP2PStatePush* other);

  // implements Message ----------------------------------------------

  IMP2PStatePush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMP2PStatePush& from);
  void MergeFrom(const IMP2PStatePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.IMP2PStatePush)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static IMP2PStatePush* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupStatePush : public ::google::protobuf::MessageLite {
 public:
  IMGroupStatePush();
  virtual ~IMGroupStatePush();

  IMGroupStatePush(const IMGroupStatePush& from);

  inline IMGroupStatePush& operator=(const IMGroupStatePush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGroupStatePush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupStatePush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupStatePush* other);

  // implements Message ----------------------------------------------

  IMGroupStatePush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupStatePush& from);
  void MergeFrom(const IMGroupStatePush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.IMGroupStatePush)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 group_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static IMGroupStatePush* default_instance_;
};
// -------------------------------------------------------------------

class GetP2PMessageRequest : public ::google::protobuf::MessageLite {
 public:
  GetP2PMessageRequest();
  virtual ~GetP2PMessageRequest();

  GetP2PMessageRequest(const GetP2PMessageRequest& from);

  inline GetP2PMessageRequest& operator=(const GetP2PMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetP2PMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetP2PMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetP2PMessageRequest* other);

  // implements Message ----------------------------------------------

  GetP2PMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetP2PMessageRequest& from);
  void MergeFrom(const GetP2PMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // optional int64 msg_seq_begin = 2;
  inline bool has_msg_seq_begin() const;
  inline void clear_msg_seq_begin();
  static const int kMsgSeqBeginFieldNumber = 2;
  inline ::google::protobuf::int64 msg_seq_begin() const;
  inline void set_msg_seq_begin(::google::protobuf::int64 value);

  // optional int64 msg_seq_end = 3;
  inline bool has_msg_seq_end() const;
  inline void clear_msg_seq_end();
  static const int kMsgSeqEndFieldNumber = 3;
  inline ::google::protobuf::int64 msg_seq_end() const;
  inline void set_msg_seq_end(::google::protobuf::int64 value);

  // required int32 msg_size = 4;
  inline bool has_msg_size() const;
  inline void clear_msg_size();
  static const int kMsgSizeFieldNumber = 4;
  inline ::google::protobuf::int32 msg_size() const;
  inline void set_msg_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GetP2PMessageRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_msg_seq_begin();
  inline void clear_has_msg_seq_begin();
  inline void set_has_msg_seq_end();
  inline void clear_has_msg_seq_end();
  inline void set_has_msg_size();
  inline void clear_has_msg_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::google::protobuf::int64 msg_seq_begin_;
  ::google::protobuf::int64 msg_seq_end_;
  ::google::protobuf::int32 msg_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetP2PMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetGroupMessageRequest : public ::google::protobuf::MessageLite {
 public:
  GetGroupMessageRequest();
  virtual ~GetGroupMessageRequest();

  GetGroupMessageRequest(const GetGroupMessageRequest& from);

  inline GetGroupMessageRequest& operator=(const GetGroupMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetGroupMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGroupMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGroupMessageRequest* other);

  // implements Message ----------------------------------------------

  GetGroupMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGroupMessageRequest& from);
  void MergeFrom(const GetGroupMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // optional int64 msg_seq_begin = 2;
  inline bool has_msg_seq_begin() const;
  inline void clear_msg_seq_begin();
  static const int kMsgSeqBeginFieldNumber = 2;
  inline ::google::protobuf::int64 msg_seq_begin() const;
  inline void set_msg_seq_begin(::google::protobuf::int64 value);

  // optional int64 msg_seq_end = 3;
  inline bool has_msg_seq_end() const;
  inline void clear_msg_seq_end();
  static const int kMsgSeqEndFieldNumber = 3;
  inline ::google::protobuf::int64 msg_seq_end() const;
  inline void set_msg_seq_end(::google::protobuf::int64 value);

  // required int32 msg_size = 4;
  inline bool has_msg_size() const;
  inline void clear_msg_size();
  static const int kMsgSizeFieldNumber = 4;
  inline ::google::protobuf::int32 msg_size() const;
  inline void set_msg_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GetGroupMessageRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_msg_seq_begin();
  inline void clear_has_msg_seq_begin();
  inline void set_has_msg_seq_end();
  inline void clear_has_msg_seq_end();
  inline void set_has_msg_size();
  inline void clear_has_msg_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 group_id_;
  ::google::protobuf::int64 msg_seq_begin_;
  ::google::protobuf::int64 msg_seq_end_;
  ::google::protobuf::int32 msg_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetGroupMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetMessageResponse : public ::google::protobuf::MessageLite {
 public:
  GetMessageResponse();
  virtual ~GetMessageResponse();

  GetMessageResponse(const GetMessageResponse& from);

  inline GetMessageResponse& operator=(const GetMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetMessageResponse* other);

  // implements Message ----------------------------------------------

  GetMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMessageResponse& from);
  void MergeFrom(const GetMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.im.InstantMessage msg = 1;
  inline int msg_size() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::weizhu::im::InstantMessage& msg(int index) const;
  inline ::weizhu::im::InstantMessage* mutable_msg(int index);
  inline ::weizhu::im::InstantMessage* add_msg();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::InstantMessage >&
      msg() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::InstantMessage >*
      mutable_msg();

  // required bool has_more = 2;
  inline bool has_has_more() const;
  inline void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  inline bool has_more() const;
  inline void set_has_more(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GetMessageResponse)
 private:
  inline void set_has_has_more();
  inline void clear_has_has_more();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::im::InstantMessage > msg_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class SendP2PMessageRequest : public ::google::protobuf::MessageLite {
 public:
  SendP2PMessageRequest();
  virtual ~SendP2PMessageRequest();

  SendP2PMessageRequest(const SendP2PMessageRequest& from);

  inline SendP2PMessageRequest& operator=(const SendP2PMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendP2PMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendP2PMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendP2PMessageRequest* other);

  // implements Message ----------------------------------------------

  SendP2PMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendP2PMessageRequest& from);
  void MergeFrom(const SendP2PMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 to_user_id = 1;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::int64 value);

  // required .weizhu.im.InstantMessage msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::weizhu::im::InstantMessage& msg() const;
  inline ::weizhu::im::InstantMessage* mutable_msg();
  inline ::weizhu::im::InstantMessage* release_msg();
  inline void set_allocated_msg(::weizhu::im::InstantMessage* msg);

  // @@protoc_insertion_point(class_scope:weizhu.im.SendP2PMessageRequest)
 private:
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 to_user_id_;
  ::weizhu::im::InstantMessage* msg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static SendP2PMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendP2PMessageResponse : public ::google::protobuf::MessageLite {
 public:
  SendP2PMessageResponse();
  virtual ~SendP2PMessageResponse();

  SendP2PMessageResponse(const SendP2PMessageResponse& from);

  inline SendP2PMessageResponse& operator=(const SendP2PMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendP2PMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendP2PMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendP2PMessageResponse* other);

  // implements Message ----------------------------------------------

  SendP2PMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendP2PMessageResponse& from);
  void MergeFrom(const SendP2PMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SendP2PMessageResponse_Result Result;
  static const Result SUCC = SendP2PMessageResponse_Result_SUCC;
  static const Result FAIL_USER_NOT_EXIST = SendP2PMessageResponse_Result_FAIL_USER_NOT_EXIST;
  static const Result FAIL_MSG_INVALID = SendP2PMessageResponse_Result_FAIL_MSG_INVALID;
  static const Result FAIL_UNKNOWN = SendP2PMessageResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return SendP2PMessageResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    SendP2PMessageResponse_Result_Result_MIN;
  static const Result Result_MAX =
    SendP2PMessageResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    SendP2PMessageResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.im.SendP2PMessageResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::im::SendP2PMessageResponse_Result result() const;
  inline void set_result(::weizhu::im::SendP2PMessageResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional int64 msg_seq = 3;
  inline bool has_msg_seq() const;
  inline void clear_msg_seq();
  static const int kMsgSeqFieldNumber = 3;
  inline ::google::protobuf::int64 msg_seq() const;
  inline void set_msg_seq(::google::protobuf::int64 value);

  // optional int32 msg_time = 4;
  inline bool has_msg_time() const;
  inline void clear_msg_time();
  static const int kMsgTimeFieldNumber = 4;
  inline ::google::protobuf::int32 msg_time() const;
  inline void set_msg_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.SendP2PMessageResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_msg_seq();
  inline void clear_has_msg_seq();
  inline void set_has_msg_time();
  inline void clear_has_msg_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  ::google::protobuf::int32 msg_time_;
  ::google::protobuf::int64 msg_seq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static SendP2PMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetP2PChatListRequest : public ::google::protobuf::MessageLite {
 public:
  GetP2PChatListRequest();
  virtual ~GetP2PChatListRequest();

  GetP2PChatListRequest(const GetP2PChatListRequest& from);

  inline GetP2PChatListRequest& operator=(const GetP2PChatListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetP2PChatListRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetP2PChatListRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetP2PChatListRequest* other);

  // implements Message ----------------------------------------------

  GetP2PChatListRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetP2PChatListRequest& from);
  void MergeFrom(const GetP2PChatListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 last_user_id = 1;
  inline bool has_last_user_id() const;
  inline void clear_last_user_id();
  static const int kLastUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 last_user_id() const;
  inline void set_last_user_id(::google::protobuf::int64 value);

  // optional int32 last_msg_time = 2;
  inline bool has_last_msg_time() const;
  inline void clear_last_msg_time();
  static const int kLastMsgTimeFieldNumber = 2;
  inline ::google::protobuf::int32 last_msg_time() const;
  inline void set_last_msg_time(::google::protobuf::int32 value);

  // required int32 chat_size = 3;
  inline bool has_chat_size() const;
  inline void clear_chat_size();
  static const int kChatSizeFieldNumber = 3;
  inline ::google::protobuf::int32 chat_size() const;
  inline void set_chat_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GetP2PChatListRequest)
 private:
  inline void set_has_last_user_id();
  inline void clear_has_last_user_id();
  inline void set_has_last_msg_time();
  inline void clear_has_last_msg_time();
  inline void set_has_chat_size();
  inline void clear_has_chat_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 last_user_id_;
  ::google::protobuf::int32 last_msg_time_;
  ::google::protobuf::int32 chat_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetP2PChatListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetP2PChatListResponse : public ::google::protobuf::MessageLite {
 public:
  GetP2PChatListResponse();
  virtual ~GetP2PChatListResponse();

  GetP2PChatListResponse(const GetP2PChatListResponse& from);

  inline GetP2PChatListResponse& operator=(const GetP2PChatListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetP2PChatListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetP2PChatListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetP2PChatListResponse* other);

  // implements Message ----------------------------------------------

  GetP2PChatListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetP2PChatListResponse& from);
  void MergeFrom(const GetP2PChatListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.im.P2PChat chat = 1;
  inline int chat_size() const;
  inline void clear_chat();
  static const int kChatFieldNumber = 1;
  inline const ::weizhu::im::P2PChat& chat(int index) const;
  inline ::weizhu::im::P2PChat* mutable_chat(int index);
  inline ::weizhu::im::P2PChat* add_chat();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::P2PChat >&
      chat() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::P2PChat >*
      mutable_chat();

  // required bool has_more = 2;
  inline bool has_has_more() const;
  inline void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  inline bool has_more() const;
  inline void set_has_more(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GetP2PChatListResponse)
 private:
  inline void set_has_has_more();
  inline void clear_has_has_more();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::im::P2PChat > chat_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetP2PChatListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetGroupChatByIdRequest : public ::google::protobuf::MessageLite {
 public:
  GetGroupChatByIdRequest();
  virtual ~GetGroupChatByIdRequest();

  GetGroupChatByIdRequest(const GetGroupChatByIdRequest& from);

  inline GetGroupChatByIdRequest& operator=(const GetGroupChatByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetGroupChatByIdRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGroupChatByIdRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGroupChatByIdRequest* other);

  // implements Message ----------------------------------------------

  GetGroupChatByIdRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGroupChatByIdRequest& from);
  void MergeFrom(const GetGroupChatByIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 group_id = 1;
  inline int group_id_size() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id(int index) const;
  inline void set_group_id(int index, ::google::protobuf::int64 value);
  inline void add_group_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      group_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_group_id();

  // @@protoc_insertion_point(class_scope:weizhu.im.GetGroupChatByIdRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > group_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetGroupChatByIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetGroupChatByIdResponse : public ::google::protobuf::MessageLite {
 public:
  GetGroupChatByIdResponse();
  virtual ~GetGroupChatByIdResponse();

  GetGroupChatByIdResponse(const GetGroupChatByIdResponse& from);

  inline GetGroupChatByIdResponse& operator=(const GetGroupChatByIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetGroupChatByIdResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGroupChatByIdResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGroupChatByIdResponse* other);

  // implements Message ----------------------------------------------

  GetGroupChatByIdResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGroupChatByIdResponse& from);
  void MergeFrom(const GetGroupChatByIdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.im.GroupChat group_chat = 1;
  inline int group_chat_size() const;
  inline void clear_group_chat();
  static const int kGroupChatFieldNumber = 1;
  inline const ::weizhu::im::GroupChat& group_chat(int index) const;
  inline ::weizhu::im::GroupChat* mutable_group_chat(int index);
  inline ::weizhu::im::GroupChat* add_group_chat();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >&
      group_chat() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >*
      mutable_group_chat();

  // @@protoc_insertion_point(class_scope:weizhu.im.GetGroupChatByIdResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat > group_chat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetGroupChatByIdResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateGroupChatRequest : public ::google::protobuf::MessageLite {
 public:
  CreateGroupChatRequest();
  virtual ~CreateGroupChatRequest();

  CreateGroupChatRequest(const CreateGroupChatRequest& from);

  inline CreateGroupChatRequest& operator=(const CreateGroupChatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateGroupChatRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateGroupChatRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateGroupChatRequest* other);

  // implements Message ----------------------------------------------

  CreateGroupChatRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateGroupChatRequest& from);
  void MergeFrom(const CreateGroupChatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string group_name = 1;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // repeated int64 member_user_id = 2;
  inline int member_user_id_size() const;
  inline void clear_member_user_id();
  static const int kMemberUserIdFieldNumber = 2;
  inline ::google::protobuf::int64 member_user_id(int index) const;
  inline void set_member_user_id(int index, ::google::protobuf::int64 value);
  inline void add_member_user_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      member_user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_member_user_id();

  // @@protoc_insertion_point(class_scope:weizhu.im.CreateGroupChatRequest)
 private:
  inline void set_has_group_name();
  inline void clear_has_group_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* group_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > member_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static CreateGroupChatRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateGroupChatResponse : public ::google::protobuf::MessageLite {
 public:
  CreateGroupChatResponse();
  virtual ~CreateGroupChatResponse();

  CreateGroupChatResponse(const CreateGroupChatResponse& from);

  inline CreateGroupChatResponse& operator=(const CreateGroupChatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateGroupChatResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateGroupChatResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateGroupChatResponse* other);

  // implements Message ----------------------------------------------

  CreateGroupChatResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateGroupChatResponse& from);
  void MergeFrom(const CreateGroupChatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CreateGroupChatResponse_Result Result;
  static const Result SUCC = CreateGroupChatResponse_Result_SUCC;
  static const Result FAIL_NAME_INVALID = CreateGroupChatResponse_Result_FAIL_NAME_INVALID;
  static const Result FAIL_MEMBER_EMPTY = CreateGroupChatResponse_Result_FAIL_MEMBER_EMPTY;
  static const Result FAIL_MEMBER_INVALID = CreateGroupChatResponse_Result_FAIL_MEMBER_INVALID;
  static const Result FAIL_MEMBER_NUM_LIMITED = CreateGroupChatResponse_Result_FAIL_MEMBER_NUM_LIMITED;
  static const Result FAIL_UNKNOWN = CreateGroupChatResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return CreateGroupChatResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CreateGroupChatResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CreateGroupChatResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CreateGroupChatResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.im.CreateGroupChatResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::im::CreateGroupChatResponse_Result result() const;
  inline void set_result(::weizhu::im::CreateGroupChatResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional .weizhu.im.GroupChat group_chat = 3;
  inline bool has_group_chat() const;
  inline void clear_group_chat();
  static const int kGroupChatFieldNumber = 3;
  inline const ::weizhu::im::GroupChat& group_chat() const;
  inline ::weizhu::im::GroupChat* mutable_group_chat();
  inline ::weizhu::im::GroupChat* release_group_chat();
  inline void set_allocated_group_chat(::weizhu::im::GroupChat* group_chat);

  // @@protoc_insertion_point(class_scope:weizhu.im.CreateGroupChatResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_group_chat();
  inline void clear_has_group_chat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::weizhu::im::GroupChat* group_chat_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static CreateGroupChatResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetGroupNameRequest : public ::google::protobuf::MessageLite {
 public:
  SetGroupNameRequest();
  virtual ~SetGroupNameRequest();

  SetGroupNameRequest(const SetGroupNameRequest& from);

  inline SetGroupNameRequest& operator=(const SetGroupNameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SetGroupNameRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetGroupNameRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetGroupNameRequest* other);

  // implements Message ----------------------------------------------

  SetGroupNameRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetGroupNameRequest& from);
  void MergeFrom(const SetGroupNameRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // required string group_name = 2;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 2;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // @@protoc_insertion_point(class_scope:weizhu.im.SetGroupNameRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 group_id_;
  ::std::string* group_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static SetGroupNameRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetGroupNameResponse : public ::google::protobuf::MessageLite {
 public:
  SetGroupNameResponse();
  virtual ~SetGroupNameResponse();

  SetGroupNameResponse(const SetGroupNameResponse& from);

  inline SetGroupNameResponse& operator=(const SetGroupNameResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SetGroupNameResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetGroupNameResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetGroupNameResponse* other);

  // implements Message ----------------------------------------------

  SetGroupNameResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetGroupNameResponse& from);
  void MergeFrom(const SetGroupNameResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SetGroupNameResponse_Result Result;
  static const Result SUCC = SetGroupNameResponse_Result_SUCC;
  static const Result FAIL_GROUP_NOT_EXIST = SetGroupNameResponse_Result_FAIL_GROUP_NOT_EXIST;
  static const Result FAIL_GROUP_NOT_JOIN = SetGroupNameResponse_Result_FAIL_GROUP_NOT_JOIN;
  static const Result FAIL_NAME_INVALID = SetGroupNameResponse_Result_FAIL_NAME_INVALID;
  static const Result FAIL_UNKNOWN = SetGroupNameResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return SetGroupNameResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    SetGroupNameResponse_Result_Result_MIN;
  static const Result Result_MAX =
    SetGroupNameResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    SetGroupNameResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.im.SetGroupNameResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::im::SetGroupNameResponse_Result result() const;
  inline void set_result(::weizhu::im::SetGroupNameResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional .weizhu.im.InstantMessage group_msg = 3;
  inline bool has_group_msg() const;
  inline void clear_group_msg();
  static const int kGroupMsgFieldNumber = 3;
  inline const ::weizhu::im::InstantMessage& group_msg() const;
  inline ::weizhu::im::InstantMessage* mutable_group_msg();
  inline ::weizhu::im::InstantMessage* release_group_msg();
  inline void set_allocated_group_msg(::weizhu::im::InstantMessage* group_msg);

  // optional .weizhu.im.GroupChat group_chat = 4;
  inline bool has_group_chat() const;
  inline void clear_group_chat();
  static const int kGroupChatFieldNumber = 4;
  inline const ::weizhu::im::GroupChat& group_chat() const;
  inline ::weizhu::im::GroupChat* mutable_group_chat();
  inline ::weizhu::im::GroupChat* release_group_chat();
  inline void set_allocated_group_chat(::weizhu::im::GroupChat* group_chat);

  // @@protoc_insertion_point(class_scope:weizhu.im.SetGroupNameResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_group_msg();
  inline void clear_has_group_msg();
  inline void set_has_group_chat();
  inline void clear_has_group_chat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::weizhu::im::InstantMessage* group_msg_;
  ::weizhu::im::GroupChat* group_chat_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static SetGroupNameResponse* default_instance_;
};
// -------------------------------------------------------------------

class JoinGroupChatRequest : public ::google::protobuf::MessageLite {
 public:
  JoinGroupChatRequest();
  virtual ~JoinGroupChatRequest();

  JoinGroupChatRequest(const JoinGroupChatRequest& from);

  inline JoinGroupChatRequest& operator=(const JoinGroupChatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const JoinGroupChatRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinGroupChatRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinGroupChatRequest* other);

  // implements Message ----------------------------------------------

  JoinGroupChatRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinGroupChatRequest& from);
  void MergeFrom(const JoinGroupChatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // repeated int64 join_user_id = 2;
  inline int join_user_id_size() const;
  inline void clear_join_user_id();
  static const int kJoinUserIdFieldNumber = 2;
  inline ::google::protobuf::int64 join_user_id(int index) const;
  inline void set_join_user_id(int index, ::google::protobuf::int64 value);
  inline void add_join_user_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      join_user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_join_user_id();

  // @@protoc_insertion_point(class_scope:weizhu.im.JoinGroupChatRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 group_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > join_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static JoinGroupChatRequest* default_instance_;
};
// -------------------------------------------------------------------

class JoinGroupChatResponse : public ::google::protobuf::MessageLite {
 public:
  JoinGroupChatResponse();
  virtual ~JoinGroupChatResponse();

  JoinGroupChatResponse(const JoinGroupChatResponse& from);

  inline JoinGroupChatResponse& operator=(const JoinGroupChatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const JoinGroupChatResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinGroupChatResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinGroupChatResponse* other);

  // implements Message ----------------------------------------------

  JoinGroupChatResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinGroupChatResponse& from);
  void MergeFrom(const JoinGroupChatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef JoinGroupChatResponse_Result Result;
  static const Result SUCC = JoinGroupChatResponse_Result_SUCC;
  static const Result FAIL_GROUP_NOT_EXIST = JoinGroupChatResponse_Result_FAIL_GROUP_NOT_EXIST;
  static const Result FAIL_GROUP_NOT_JOIN = JoinGroupChatResponse_Result_FAIL_GROUP_NOT_JOIN;
  static const Result FAIL_USER_EMPTY = JoinGroupChatResponse_Result_FAIL_USER_EMPTY;
  static const Result FAIL_USER_INVALID = JoinGroupChatResponse_Result_FAIL_USER_INVALID;
  static const Result FAIL_MEMBER_NUM_LIMITED = JoinGroupChatResponse_Result_FAIL_MEMBER_NUM_LIMITED;
  static const Result FAIL_UNKNOWN = JoinGroupChatResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return JoinGroupChatResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    JoinGroupChatResponse_Result_Result_MIN;
  static const Result Result_MAX =
    JoinGroupChatResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    JoinGroupChatResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.im.JoinGroupChatResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::im::JoinGroupChatResponse_Result result() const;
  inline void set_result(::weizhu::im::JoinGroupChatResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional .weizhu.im.InstantMessage group_msg = 3;
  inline bool has_group_msg() const;
  inline void clear_group_msg();
  static const int kGroupMsgFieldNumber = 3;
  inline const ::weizhu::im::InstantMessage& group_msg() const;
  inline ::weizhu::im::InstantMessage* mutable_group_msg();
  inline ::weizhu::im::InstantMessage* release_group_msg();
  inline void set_allocated_group_msg(::weizhu::im::InstantMessage* group_msg);

  // optional .weizhu.im.GroupChat group_chat = 4;
  inline bool has_group_chat() const;
  inline void clear_group_chat();
  static const int kGroupChatFieldNumber = 4;
  inline const ::weizhu::im::GroupChat& group_chat() const;
  inline ::weizhu::im::GroupChat* mutable_group_chat();
  inline ::weizhu::im::GroupChat* release_group_chat();
  inline void set_allocated_group_chat(::weizhu::im::GroupChat* group_chat);

  // @@protoc_insertion_point(class_scope:weizhu.im.JoinGroupChatResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_group_msg();
  inline void clear_has_group_msg();
  inline void set_has_group_chat();
  inline void clear_has_group_chat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::weizhu::im::InstantMessage* group_msg_;
  ::weizhu::im::GroupChat* group_chat_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static JoinGroupChatResponse* default_instance_;
};
// -------------------------------------------------------------------

class LeaveGroupChatRequest : public ::google::protobuf::MessageLite {
 public:
  LeaveGroupChatRequest();
  virtual ~LeaveGroupChatRequest();

  LeaveGroupChatRequest(const LeaveGroupChatRequest& from);

  inline LeaveGroupChatRequest& operator=(const LeaveGroupChatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LeaveGroupChatRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LeaveGroupChatRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LeaveGroupChatRequest* other);

  // implements Message ----------------------------------------------

  LeaveGroupChatRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LeaveGroupChatRequest& from);
  void MergeFrom(const LeaveGroupChatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.LeaveGroupChatRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 group_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static LeaveGroupChatRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaveGroupChatResponse : public ::google::protobuf::MessageLite {
 public:
  LeaveGroupChatResponse();
  virtual ~LeaveGroupChatResponse();

  LeaveGroupChatResponse(const LeaveGroupChatResponse& from);

  inline LeaveGroupChatResponse& operator=(const LeaveGroupChatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LeaveGroupChatResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LeaveGroupChatResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LeaveGroupChatResponse* other);

  // implements Message ----------------------------------------------

  LeaveGroupChatResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LeaveGroupChatResponse& from);
  void MergeFrom(const LeaveGroupChatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LeaveGroupChatResponse_Result Result;
  static const Result SUCC = LeaveGroupChatResponse_Result_SUCC;
  static const Result FAIL_GROUP_NOT_EXIST = LeaveGroupChatResponse_Result_FAIL_GROUP_NOT_EXIST;
  static const Result FAIL_GROUP_NOT_JOIN = LeaveGroupChatResponse_Result_FAIL_GROUP_NOT_JOIN;
  static const Result FAIL_UNKNOWN = LeaveGroupChatResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return LeaveGroupChatResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    LeaveGroupChatResponse_Result_Result_MIN;
  static const Result Result_MAX =
    LeaveGroupChatResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    LeaveGroupChatResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.im.LeaveGroupChatResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::im::LeaveGroupChatResponse_Result result() const;
  inline void set_result(::weizhu::im::LeaveGroupChatResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional .weizhu.im.InstantMessage group_msg = 3;
  inline bool has_group_msg() const;
  inline void clear_group_msg();
  static const int kGroupMsgFieldNumber = 3;
  inline const ::weizhu::im::InstantMessage& group_msg() const;
  inline ::weizhu::im::InstantMessage* mutable_group_msg();
  inline ::weizhu::im::InstantMessage* release_group_msg();
  inline void set_allocated_group_msg(::weizhu::im::InstantMessage* group_msg);

  // optional .weizhu.im.GroupChat group_chat = 4;
  inline bool has_group_chat() const;
  inline void clear_group_chat();
  static const int kGroupChatFieldNumber = 4;
  inline const ::weizhu::im::GroupChat& group_chat() const;
  inline ::weizhu::im::GroupChat* mutable_group_chat();
  inline ::weizhu::im::GroupChat* release_group_chat();
  inline void set_allocated_group_chat(::weizhu::im::GroupChat* group_chat);

  // @@protoc_insertion_point(class_scope:weizhu.im.LeaveGroupChatResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_group_msg();
  inline void clear_has_group_msg();
  inline void set_has_group_chat();
  inline void clear_has_group_chat();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::weizhu::im::InstantMessage* group_msg_;
  ::weizhu::im::GroupChat* group_chat_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static LeaveGroupChatResponse* default_instance_;
};
// -------------------------------------------------------------------

class SendGroupMessageRequest : public ::google::protobuf::MessageLite {
 public:
  SendGroupMessageRequest();
  virtual ~SendGroupMessageRequest();

  SendGroupMessageRequest(const SendGroupMessageRequest& from);

  inline SendGroupMessageRequest& operator=(const SendGroupMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendGroupMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendGroupMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendGroupMessageRequest* other);

  // implements Message ----------------------------------------------

  SendGroupMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendGroupMessageRequest& from);
  void MergeFrom(const SendGroupMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // required .weizhu.im.InstantMessage msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::weizhu::im::InstantMessage& msg() const;
  inline ::weizhu::im::InstantMessage* mutable_msg();
  inline ::weizhu::im::InstantMessage* release_msg();
  inline void set_allocated_msg(::weizhu::im::InstantMessage* msg);

  // @@protoc_insertion_point(class_scope:weizhu.im.SendGroupMessageRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 group_id_;
  ::weizhu::im::InstantMessage* msg_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static SendGroupMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendGroupMessageResponse : public ::google::protobuf::MessageLite {
 public:
  SendGroupMessageResponse();
  virtual ~SendGroupMessageResponse();

  SendGroupMessageResponse(const SendGroupMessageResponse& from);

  inline SendGroupMessageResponse& operator=(const SendGroupMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendGroupMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendGroupMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendGroupMessageResponse* other);

  // implements Message ----------------------------------------------

  SendGroupMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendGroupMessageResponse& from);
  void MergeFrom(const SendGroupMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SendGroupMessageResponse_Result Result;
  static const Result SUCC = SendGroupMessageResponse_Result_SUCC;
  static const Result FAIL_GROUP_NOT_EXIST = SendGroupMessageResponse_Result_FAIL_GROUP_NOT_EXIST;
  static const Result FAIL_GROUP_NOT_JOIN = SendGroupMessageResponse_Result_FAIL_GROUP_NOT_JOIN;
  static const Result FAIL_MSG_INVALID = SendGroupMessageResponse_Result_FAIL_MSG_INVALID;
  static const Result FAIL_UNKNOWN = SendGroupMessageResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return SendGroupMessageResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    SendGroupMessageResponse_Result_Result_MIN;
  static const Result Result_MAX =
    SendGroupMessageResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    SendGroupMessageResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.im.SendGroupMessageResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::im::SendGroupMessageResponse_Result result() const;
  inline void set_result(::weizhu::im::SendGroupMessageResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional int64 msg_seq = 3;
  inline bool has_msg_seq() const;
  inline void clear_msg_seq();
  static const int kMsgSeqFieldNumber = 3;
  inline ::google::protobuf::int64 msg_seq() const;
  inline void set_msg_seq(::google::protobuf::int64 value);

  // optional int32 msg_time = 4;
  inline bool has_msg_time() const;
  inline void clear_msg_time();
  static const int kMsgTimeFieldNumber = 4;
  inline ::google::protobuf::int32 msg_time() const;
  inline void set_msg_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.SendGroupMessageResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_msg_seq();
  inline void clear_has_msg_seq();
  inline void set_has_msg_time();
  inline void clear_has_msg_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  ::google::protobuf::int32 msg_time_;
  ::google::protobuf::int64 msg_seq_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static SendGroupMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetGroupChatListRequest : public ::google::protobuf::MessageLite {
 public:
  GetGroupChatListRequest();
  virtual ~GetGroupChatListRequest();

  GetGroupChatListRequest(const GetGroupChatListRequest& from);

  inline GetGroupChatListRequest& operator=(const GetGroupChatListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetGroupChatListRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGroupChatListRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGroupChatListRequest* other);

  // implements Message ----------------------------------------------

  GetGroupChatListRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGroupChatListRequest& from);
  void MergeFrom(const GetGroupChatListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 last_group_id = 1;
  inline bool has_last_group_id() const;
  inline void clear_last_group_id();
  static const int kLastGroupIdFieldNumber = 1;
  inline ::google::protobuf::int64 last_group_id() const;
  inline void set_last_group_id(::google::protobuf::int64 value);

  // optional int32 last_msg_time = 2;
  inline bool has_last_msg_time() const;
  inline void clear_last_msg_time();
  static const int kLastMsgTimeFieldNumber = 2;
  inline ::google::protobuf::int32 last_msg_time() const;
  inline void set_last_msg_time(::google::protobuf::int32 value);

  // required int32 chat_size = 3;
  inline bool has_chat_size() const;
  inline void clear_chat_size();
  static const int kChatSizeFieldNumber = 3;
  inline ::google::protobuf::int32 chat_size() const;
  inline void set_chat_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GetGroupChatListRequest)
 private:
  inline void set_has_last_group_id();
  inline void clear_has_last_group_id();
  inline void set_has_last_msg_time();
  inline void clear_has_last_msg_time();
  inline void set_has_chat_size();
  inline void clear_has_chat_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 last_group_id_;
  ::google::protobuf::int32 last_msg_time_;
  ::google::protobuf::int32 chat_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetGroupChatListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetGroupChatListResponse : public ::google::protobuf::MessageLite {
 public:
  GetGroupChatListResponse();
  virtual ~GetGroupChatListResponse();

  GetGroupChatListResponse(const GetGroupChatListResponse& from);

  inline GetGroupChatListResponse& operator=(const GetGroupChatListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetGroupChatListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGroupChatListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGroupChatListResponse* other);

  // implements Message ----------------------------------------------

  GetGroupChatListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGroupChatListResponse& from);
  void MergeFrom(const GetGroupChatListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.im.GroupChat chat = 1;
  inline int chat_size() const;
  inline void clear_chat();
  static const int kChatFieldNumber = 1;
  inline const ::weizhu::im::GroupChat& chat(int index) const;
  inline ::weizhu::im::GroupChat* mutable_chat(int index);
  inline ::weizhu::im::GroupChat* add_chat();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >&
      chat() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >*
      mutable_chat();

  // required bool has_more = 2;
  inline bool has_has_more() const;
  inline void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  inline bool has_more() const;
  inline void set_has_more(bool value);

  // @@protoc_insertion_point(class_scope:weizhu.im.GetGroupChatListResponse)
 private:
  inline void set_has_has_more();
  inline void clear_has_has_more();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat > chat_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_im_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_im_2eproto();
  #endif
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static GetGroupChatListResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// InstantMessage_Text

// required string content = 1;
inline bool InstantMessage_Text::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_Text::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_Text::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_Text::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& InstantMessage_Text::content() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Text.content)
  return *content_;
}
inline void InstantMessage_Text::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Text.content)
}
inline void InstantMessage_Text::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.Text.content)
}
inline void InstantMessage_Text::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.Text.content)
}
inline ::std::string* InstantMessage_Text::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.Text.content)
  return content_;
}
inline ::std::string* InstantMessage_Text::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_Text::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.Text.content)
}

// -------------------------------------------------------------------

// InstantMessage_Voice

// required bytes data = 1;
inline bool InstantMessage_Voice::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_Voice::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_Voice::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_Voice::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& InstantMessage_Voice::data() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Voice.data)
  return *data_;
}
inline void InstantMessage_Voice::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Voice.data)
}
inline void InstantMessage_Voice::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.Voice.data)
}
inline void InstantMessage_Voice::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.Voice.data)
}
inline ::std::string* InstantMessage_Voice::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.Voice.data)
  return data_;
}
inline ::std::string* InstantMessage_Voice::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_Voice::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.Voice.data)
}

// optional int32 duration = 2;
inline bool InstantMessage_Voice::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstantMessage_Voice::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstantMessage_Voice::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstantMessage_Voice::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 InstantMessage_Voice::duration() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Voice.duration)
  return duration_;
}
inline void InstantMessage_Voice::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Voice.duration)
}

// -------------------------------------------------------------------

// InstantMessage_Image

// required string name = 1;
inline bool InstantMessage_Image::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_Image::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_Image::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_Image::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InstantMessage_Image::name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Image.name)
  return *name_;
}
inline void InstantMessage_Image::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Image.name)
}
inline void InstantMessage_Image::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.Image.name)
}
inline void InstantMessage_Image::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.Image.name)
}
inline ::std::string* InstantMessage_Image::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.Image.name)
  return name_;
}
inline ::std::string* InstantMessage_Image::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_Image::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.Image.name)
}

// -------------------------------------------------------------------

// InstantMessage_User

// required int64 user_id = 1;
inline bool InstantMessage_User::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_User::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_User::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_User::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 InstantMessage_User::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.User.user_id)
  return user_id_;
}
inline void InstantMessage_User::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.User.user_id)
}

// -------------------------------------------------------------------

// InstantMessage_Video

// required string name = 1;
inline bool InstantMessage_Video::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_Video::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_Video::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_Video::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InstantMessage_Video::name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Video.name)
  return *name_;
}
inline void InstantMessage_Video::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Video.name)
}
inline void InstantMessage_Video::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.Video.name)
}
inline void InstantMessage_Video::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.Video.name)
}
inline ::std::string* InstantMessage_Video::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.Video.name)
  return name_;
}
inline ::std::string* InstantMessage_Video::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_Video::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.Video.name)
}

// required string type = 2;
inline bool InstantMessage_Video::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstantMessage_Video::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstantMessage_Video::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstantMessage_Video::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& InstantMessage_Video::type() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Video.type)
  return *type_;
}
inline void InstantMessage_Video::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Video.type)
}
inline void InstantMessage_Video::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.Video.type)
}
inline void InstantMessage_Video::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.Video.type)
}
inline ::std::string* InstantMessage_Video::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.Video.type)
  return type_;
}
inline ::std::string* InstantMessage_Video::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_Video::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.Video.type)
}

// required int32 size = 3;
inline bool InstantMessage_Video::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstantMessage_Video::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstantMessage_Video::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstantMessage_Video::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 InstantMessage_Video::size() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Video.size)
  return size_;
}
inline void InstantMessage_Video::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Video.size)
}

// required int32 time = 4;
inline bool InstantMessage_Video::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstantMessage_Video::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstantMessage_Video::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstantMessage_Video::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 InstantMessage_Video::time() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Video.time)
  return time_;
}
inline void InstantMessage_Video::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Video.time)
}

// required string image_name = 5;
inline bool InstantMessage_Video::has_image_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstantMessage_Video::set_has_image_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstantMessage_Video::clear_has_image_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstantMessage_Video::clear_image_name() {
  if (image_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_name_->clear();
  }
  clear_has_image_name();
}
inline const ::std::string& InstantMessage_Video::image_name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Video.image_name)
  return *image_name_;
}
inline void InstantMessage_Video::set_image_name(const ::std::string& value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Video.image_name)
}
inline void InstantMessage_Video::set_image_name(const char* value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.Video.image_name)
}
inline void InstantMessage_Video::set_image_name(const char* value, size_t size) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.Video.image_name)
}
inline ::std::string* InstantMessage_Video::mutable_image_name() {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.Video.image_name)
  return image_name_;
}
inline ::std::string* InstantMessage_Video::release_image_name() {
  clear_has_image_name();
  if (image_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_name_;
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_Video::set_allocated_image_name(::std::string* image_name) {
  if (image_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_name_;
  }
  if (image_name) {
    set_has_image_name();
    image_name_ = image_name;
  } else {
    clear_has_image_name();
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.Video.image_name)
}

// -------------------------------------------------------------------

// InstantMessage_File

// required string name = 1;
inline bool InstantMessage_File::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_File::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_File::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_File::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InstantMessage_File::name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.File.name)
  return *name_;
}
inline void InstantMessage_File::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.File.name)
}
inline void InstantMessage_File::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.File.name)
}
inline void InstantMessage_File::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.File.name)
}
inline ::std::string* InstantMessage_File::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.File.name)
  return name_;
}
inline ::std::string* InstantMessage_File::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_File::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.File.name)
}

// required string orginal_name = 2;
inline bool InstantMessage_File::has_orginal_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstantMessage_File::set_has_orginal_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstantMessage_File::clear_has_orginal_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstantMessage_File::clear_orginal_name() {
  if (orginal_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginal_name_->clear();
  }
  clear_has_orginal_name();
}
inline const ::std::string& InstantMessage_File::orginal_name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.File.orginal_name)
  return *orginal_name_;
}
inline void InstantMessage_File::set_orginal_name(const ::std::string& value) {
  set_has_orginal_name();
  if (orginal_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginal_name_ = new ::std::string;
  }
  orginal_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.File.orginal_name)
}
inline void InstantMessage_File::set_orginal_name(const char* value) {
  set_has_orginal_name();
  if (orginal_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginal_name_ = new ::std::string;
  }
  orginal_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.File.orginal_name)
}
inline void InstantMessage_File::set_orginal_name(const char* value, size_t size) {
  set_has_orginal_name();
  if (orginal_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginal_name_ = new ::std::string;
  }
  orginal_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.File.orginal_name)
}
inline ::std::string* InstantMessage_File::mutable_orginal_name() {
  set_has_orginal_name();
  if (orginal_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    orginal_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.File.orginal_name)
  return orginal_name_;
}
inline ::std::string* InstantMessage_File::release_orginal_name() {
  clear_has_orginal_name();
  if (orginal_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = orginal_name_;
    orginal_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_File::set_allocated_orginal_name(::std::string* orginal_name) {
  if (orginal_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete orginal_name_;
  }
  if (orginal_name) {
    set_has_orginal_name();
    orginal_name_ = orginal_name;
  } else {
    clear_has_orginal_name();
    orginal_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.File.orginal_name)
}

// -------------------------------------------------------------------

// InstantMessage_Group

// optional string group_name = 1;
inline bool InstantMessage_Group::has_group_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_Group::set_has_group_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_Group::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_Group::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& InstantMessage_Group::group_name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Group.group_name)
  return *group_name_;
}
inline void InstantMessage_Group::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Group.group_name)
}
inline void InstantMessage_Group::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.InstantMessage.Group.group_name)
}
inline void InstantMessage_Group::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.InstantMessage.Group.group_name)
}
inline ::std::string* InstantMessage_Group::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.InstantMessage.Group.group_name)
  return group_name_;
}
inline ::std::string* InstantMessage_Group::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InstantMessage_Group::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.InstantMessage.Group.group_name)
}

// repeated int64 join_user_id = 2;
inline int InstantMessage_Group::join_user_id_size() const {
  return join_user_id_.size();
}
inline void InstantMessage_Group::clear_join_user_id() {
  join_user_id_.Clear();
}
inline ::google::protobuf::int64 InstantMessage_Group::join_user_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Group.join_user_id)
  return join_user_id_.Get(index);
}
inline void InstantMessage_Group::set_join_user_id(int index, ::google::protobuf::int64 value) {
  join_user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Group.join_user_id)
}
inline void InstantMessage_Group::add_join_user_id(::google::protobuf::int64 value) {
  join_user_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.im.InstantMessage.Group.join_user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
InstantMessage_Group::join_user_id() const {
  // @@protoc_insertion_point(field_list:weizhu.im.InstantMessage.Group.join_user_id)
  return join_user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
InstantMessage_Group::mutable_join_user_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.InstantMessage.Group.join_user_id)
  return &join_user_id_;
}

// repeated int64 leave_user_id = 3;
inline int InstantMessage_Group::leave_user_id_size() const {
  return leave_user_id_.size();
}
inline void InstantMessage_Group::clear_leave_user_id() {
  leave_user_id_.Clear();
}
inline ::google::protobuf::int64 InstantMessage_Group::leave_user_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.Group.leave_user_id)
  return leave_user_id_.Get(index);
}
inline void InstantMessage_Group::set_leave_user_id(int index, ::google::protobuf::int64 value) {
  leave_user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.Group.leave_user_id)
}
inline void InstantMessage_Group::add_leave_user_id(::google::protobuf::int64 value) {
  leave_user_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.im.InstantMessage.Group.leave_user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
InstantMessage_Group::leave_user_id() const {
  // @@protoc_insertion_point(field_list:weizhu.im.InstantMessage.Group.leave_user_id)
  return leave_user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
InstantMessage_Group::mutable_leave_user_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.InstantMessage.Group.leave_user_id)
  return &leave_user_id_;
}

// -------------------------------------------------------------------

// InstantMessage_DiscoverItem

// required int64 item_id = 1;
inline bool InstantMessage_DiscoverItem::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage_DiscoverItem::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage_DiscoverItem::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage_DiscoverItem::clear_item_id() {
  item_id_ = GOOGLE_LONGLONG(0);
  clear_has_item_id();
}
inline ::google::protobuf::int64 InstantMessage_DiscoverItem::item_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.DiscoverItem.item_id)
  return item_id_;
}
inline void InstantMessage_DiscoverItem::set_item_id(::google::protobuf::int64 value) {
  set_has_item_id();
  item_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.DiscoverItem.item_id)
}

// -------------------------------------------------------------------

// InstantMessage

// required int64 msg_seq = 1;
inline bool InstantMessage::has_msg_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstantMessage::set_has_msg_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstantMessage::clear_has_msg_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstantMessage::clear_msg_seq() {
  msg_seq_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq();
}
inline ::google::protobuf::int64 InstantMessage::msg_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.msg_seq)
  return msg_seq_;
}
inline void InstantMessage::set_msg_seq(::google::protobuf::int64 value) {
  set_has_msg_seq();
  msg_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.msg_seq)
}

// required int32 msg_time = 2;
inline bool InstantMessage::has_msg_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstantMessage::set_has_msg_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstantMessage::clear_has_msg_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstantMessage::clear_msg_time() {
  msg_time_ = 0;
  clear_has_msg_time();
}
inline ::google::protobuf::int32 InstantMessage::msg_time() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.msg_time)
  return msg_time_;
}
inline void InstantMessage::set_msg_time(::google::protobuf::int32 value) {
  set_has_msg_time();
  msg_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.msg_time)
}

// required int64 from_user_id = 3;
inline bool InstantMessage::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstantMessage::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstantMessage::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstantMessage::clear_from_user_id() {
  from_user_id_ = GOOGLE_LONGLONG(0);
  clear_has_from_user_id();
}
inline ::google::protobuf::int64 InstantMessage::from_user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.InstantMessage.from_user_id)
  return from_user_id_;
}
inline void InstantMessage::set_from_user_id(::google::protobuf::int64 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.InstantMessage.from_user_id)
}

// optional .weizhu.im.InstantMessage.Text text = 5;
inline bool InstantMessage::has_text() const {
  return msg_type_case() == kText;
}
inline void InstantMessage::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void InstantMessage::clear_text() {
  if (has_text()) {
    delete msg_type_.text_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_Text& InstantMessage::text() const {
  return has_text() ? *msg_type_.text_
                      : ::weizhu::im::InstantMessage_Text::default_instance();
}
inline ::weizhu::im::InstantMessage_Text* InstantMessage::mutable_text() {
  if (!has_text()) {
    clear_msg_type();
    set_has_text();
    msg_type_.text_ = new ::weizhu::im::InstantMessage_Text;
  }
  return msg_type_.text_;
}
inline ::weizhu::im::InstantMessage_Text* InstantMessage::release_text() {
  if (has_text()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_Text* temp = msg_type_.text_;
    msg_type_.text_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_text(::weizhu::im::InstantMessage_Text* text) {
  clear_msg_type();
  if (text) {
    set_has_text();
    msg_type_.text_ = text;
  }
}

// optional .weizhu.im.InstantMessage.Voice voice = 6;
inline bool InstantMessage::has_voice() const {
  return msg_type_case() == kVoice;
}
inline void InstantMessage::set_has_voice() {
  _oneof_case_[0] = kVoice;
}
inline void InstantMessage::clear_voice() {
  if (has_voice()) {
    delete msg_type_.voice_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_Voice& InstantMessage::voice() const {
  return has_voice() ? *msg_type_.voice_
                      : ::weizhu::im::InstantMessage_Voice::default_instance();
}
inline ::weizhu::im::InstantMessage_Voice* InstantMessage::mutable_voice() {
  if (!has_voice()) {
    clear_msg_type();
    set_has_voice();
    msg_type_.voice_ = new ::weizhu::im::InstantMessage_Voice;
  }
  return msg_type_.voice_;
}
inline ::weizhu::im::InstantMessage_Voice* InstantMessage::release_voice() {
  if (has_voice()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_Voice* temp = msg_type_.voice_;
    msg_type_.voice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_voice(::weizhu::im::InstantMessage_Voice* voice) {
  clear_msg_type();
  if (voice) {
    set_has_voice();
    msg_type_.voice_ = voice;
  }
}

// optional .weizhu.im.InstantMessage.Image image = 7;
inline bool InstantMessage::has_image() const {
  return msg_type_case() == kImage;
}
inline void InstantMessage::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void InstantMessage::clear_image() {
  if (has_image()) {
    delete msg_type_.image_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_Image& InstantMessage::image() const {
  return has_image() ? *msg_type_.image_
                      : ::weizhu::im::InstantMessage_Image::default_instance();
}
inline ::weizhu::im::InstantMessage_Image* InstantMessage::mutable_image() {
  if (!has_image()) {
    clear_msg_type();
    set_has_image();
    msg_type_.image_ = new ::weizhu::im::InstantMessage_Image;
  }
  return msg_type_.image_;
}
inline ::weizhu::im::InstantMessage_Image* InstantMessage::release_image() {
  if (has_image()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_Image* temp = msg_type_.image_;
    msg_type_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_image(::weizhu::im::InstantMessage_Image* image) {
  clear_msg_type();
  if (image) {
    set_has_image();
    msg_type_.image_ = image;
  }
}

// optional .weizhu.im.InstantMessage.User user = 8;
inline bool InstantMessage::has_user() const {
  return msg_type_case() == kUser;
}
inline void InstantMessage::set_has_user() {
  _oneof_case_[0] = kUser;
}
inline void InstantMessage::clear_user() {
  if (has_user()) {
    delete msg_type_.user_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_User& InstantMessage::user() const {
  return has_user() ? *msg_type_.user_
                      : ::weizhu::im::InstantMessage_User::default_instance();
}
inline ::weizhu::im::InstantMessage_User* InstantMessage::mutable_user() {
  if (!has_user()) {
    clear_msg_type();
    set_has_user();
    msg_type_.user_ = new ::weizhu::im::InstantMessage_User;
  }
  return msg_type_.user_;
}
inline ::weizhu::im::InstantMessage_User* InstantMessage::release_user() {
  if (has_user()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_User* temp = msg_type_.user_;
    msg_type_.user_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_user(::weizhu::im::InstantMessage_User* user) {
  clear_msg_type();
  if (user) {
    set_has_user();
    msg_type_.user_ = user;
  }
}

// optional .weizhu.im.InstantMessage.Video video = 9;
inline bool InstantMessage::has_video() const {
  return msg_type_case() == kVideo;
}
inline void InstantMessage::set_has_video() {
  _oneof_case_[0] = kVideo;
}
inline void InstantMessage::clear_video() {
  if (has_video()) {
    delete msg_type_.video_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_Video& InstantMessage::video() const {
  return has_video() ? *msg_type_.video_
                      : ::weizhu::im::InstantMessage_Video::default_instance();
}
inline ::weizhu::im::InstantMessage_Video* InstantMessage::mutable_video() {
  if (!has_video()) {
    clear_msg_type();
    set_has_video();
    msg_type_.video_ = new ::weizhu::im::InstantMessage_Video;
  }
  return msg_type_.video_;
}
inline ::weizhu::im::InstantMessage_Video* InstantMessage::release_video() {
  if (has_video()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_Video* temp = msg_type_.video_;
    msg_type_.video_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_video(::weizhu::im::InstantMessage_Video* video) {
  clear_msg_type();
  if (video) {
    set_has_video();
    msg_type_.video_ = video;
  }
}

// optional .weizhu.im.InstantMessage.File file = 10;
inline bool InstantMessage::has_file() const {
  return msg_type_case() == kFile;
}
inline void InstantMessage::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline void InstantMessage::clear_file() {
  if (has_file()) {
    delete msg_type_.file_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_File& InstantMessage::file() const {
  return has_file() ? *msg_type_.file_
                      : ::weizhu::im::InstantMessage_File::default_instance();
}
inline ::weizhu::im::InstantMessage_File* InstantMessage::mutable_file() {
  if (!has_file()) {
    clear_msg_type();
    set_has_file();
    msg_type_.file_ = new ::weizhu::im::InstantMessage_File;
  }
  return msg_type_.file_;
}
inline ::weizhu::im::InstantMessage_File* InstantMessage::release_file() {
  if (has_file()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_File* temp = msg_type_.file_;
    msg_type_.file_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_file(::weizhu::im::InstantMessage_File* file) {
  clear_msg_type();
  if (file) {
    set_has_file();
    msg_type_.file_ = file;
  }
}

// optional .weizhu.im.InstantMessage.Group group = 11;
inline bool InstantMessage::has_group() const {
  return msg_type_case() == kGroup;
}
inline void InstantMessage::set_has_group() {
  _oneof_case_[0] = kGroup;
}
inline void InstantMessage::clear_group() {
  if (has_group()) {
    delete msg_type_.group_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_Group& InstantMessage::group() const {
  return has_group() ? *msg_type_.group_
                      : ::weizhu::im::InstantMessage_Group::default_instance();
}
inline ::weizhu::im::InstantMessage_Group* InstantMessage::mutable_group() {
  if (!has_group()) {
    clear_msg_type();
    set_has_group();
    msg_type_.group_ = new ::weizhu::im::InstantMessage_Group;
  }
  return msg_type_.group_;
}
inline ::weizhu::im::InstantMessage_Group* InstantMessage::release_group() {
  if (has_group()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_Group* temp = msg_type_.group_;
    msg_type_.group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_group(::weizhu::im::InstantMessage_Group* group) {
  clear_msg_type();
  if (group) {
    set_has_group();
    msg_type_.group_ = group;
  }
}

// optional .weizhu.im.InstantMessage.DiscoverItem discover_item = 12;
inline bool InstantMessage::has_discover_item() const {
  return msg_type_case() == kDiscoverItem;
}
inline void InstantMessage::set_has_discover_item() {
  _oneof_case_[0] = kDiscoverItem;
}
inline void InstantMessage::clear_discover_item() {
  if (has_discover_item()) {
    delete msg_type_.discover_item_;
    clear_has_msg_type();
  }
}
inline const ::weizhu::im::InstantMessage_DiscoverItem& InstantMessage::discover_item() const {
  return has_discover_item() ? *msg_type_.discover_item_
                      : ::weizhu::im::InstantMessage_DiscoverItem::default_instance();
}
inline ::weizhu::im::InstantMessage_DiscoverItem* InstantMessage::mutable_discover_item() {
  if (!has_discover_item()) {
    clear_msg_type();
    set_has_discover_item();
    msg_type_.discover_item_ = new ::weizhu::im::InstantMessage_DiscoverItem;
  }
  return msg_type_.discover_item_;
}
inline ::weizhu::im::InstantMessage_DiscoverItem* InstantMessage::release_discover_item() {
  if (has_discover_item()) {
    clear_has_msg_type();
    ::weizhu::im::InstantMessage_DiscoverItem* temp = msg_type_.discover_item_;
    msg_type_.discover_item_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InstantMessage::set_allocated_discover_item(::weizhu::im::InstantMessage_DiscoverItem* discover_item) {
  clear_msg_type();
  if (discover_item) {
    set_has_discover_item();
    msg_type_.discover_item_ = discover_item;
  }
}

inline bool InstantMessage::has_msg_type() {
  return msg_type_case() != MSG_TYPE_NOT_SET;
}
inline void InstantMessage::clear_has_msg_type() {
  _oneof_case_[0] = MSG_TYPE_NOT_SET;
}
inline InstantMessage::MsgTypeCase InstantMessage::msg_type_case() const {
  return InstantMessage::MsgTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// P2PChat

// required int64 user_id = 1;
inline bool P2PChat::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P2PChat::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P2PChat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P2PChat::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 P2PChat::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.P2PChat.user_id)
  return user_id_;
}
inline void P2PChat::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.P2PChat.user_id)
}

// required .weizhu.im.InstantMessage latest_msg = 2;
inline bool P2PChat::has_latest_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void P2PChat::set_has_latest_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void P2PChat::clear_has_latest_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void P2PChat::clear_latest_msg() {
  if (latest_msg_ != NULL) latest_msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_latest_msg();
}
inline const ::weizhu::im::InstantMessage& P2PChat::latest_msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.P2PChat.latest_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return latest_msg_ != NULL ? *latest_msg_ : *default_instance().latest_msg_;
#else
  return latest_msg_ != NULL ? *latest_msg_ : *default_instance_->latest_msg_;
#endif
}
inline ::weizhu::im::InstantMessage* P2PChat::mutable_latest_msg() {
  set_has_latest_msg();
  if (latest_msg_ == NULL) latest_msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.P2PChat.latest_msg)
  return latest_msg_;
}
inline ::weizhu::im::InstantMessage* P2PChat::release_latest_msg() {
  clear_has_latest_msg();
  ::weizhu::im::InstantMessage* temp = latest_msg_;
  latest_msg_ = NULL;
  return temp;
}
inline void P2PChat::set_allocated_latest_msg(::weizhu::im::InstantMessage* latest_msg) {
  delete latest_msg_;
  latest_msg_ = latest_msg;
  if (latest_msg) {
    set_has_latest_msg();
  } else {
    clear_has_latest_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.P2PChat.latest_msg)
}

// -------------------------------------------------------------------

// GroupChat_Member

// required int64 user_id = 1;
inline bool GroupChat_Member::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChat_Member::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChat_Member::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChat_Member::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 GroupChat_Member::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GroupChat.Member.user_id)
  return user_id_;
}
inline void GroupChat_Member::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GroupChat.Member.user_id)
}

// required int64 join_msg_seq = 2;
inline bool GroupChat_Member::has_join_msg_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChat_Member::set_has_join_msg_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChat_Member::clear_has_join_msg_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChat_Member::clear_join_msg_seq() {
  join_msg_seq_ = GOOGLE_LONGLONG(0);
  clear_has_join_msg_seq();
}
inline ::google::protobuf::int64 GroupChat_Member::join_msg_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GroupChat.Member.join_msg_seq)
  return join_msg_seq_;
}
inline void GroupChat_Member::set_join_msg_seq(::google::protobuf::int64 value) {
  set_has_join_msg_seq();
  join_msg_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GroupChat.Member.join_msg_seq)
}

// -------------------------------------------------------------------

// GroupChat

// required int64 group_id = 1;
inline bool GroupChat::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChat::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChat::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChat::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 GroupChat::group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GroupChat.group_id)
  return group_id_;
}
inline void GroupChat::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GroupChat.group_id)
}

// optional string group_name = 2;
inline bool GroupChat::has_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChat::set_has_group_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChat::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChat::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupChat::group_name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GroupChat.group_name)
  return *group_name_;
}
inline void GroupChat::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.GroupChat.group_name)
}
inline void GroupChat::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.GroupChat.group_name)
}
inline void GroupChat::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.GroupChat.group_name)
}
inline ::std::string* GroupChat::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.GroupChat.group_name)
  return group_name_;
}
inline ::std::string* GroupChat::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupChat::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.GroupChat.group_name)
}

// repeated .weizhu.im.GroupChat.Member member = 3;
inline int GroupChat::member_size() const {
  return member_.size();
}
inline void GroupChat::clear_member() {
  member_.Clear();
}
inline const ::weizhu::im::GroupChat_Member& GroupChat::member(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.GroupChat.member)
  return member_.Get(index);
}
inline ::weizhu::im::GroupChat_Member* GroupChat::mutable_member(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.im.GroupChat.member)
  return member_.Mutable(index);
}
inline ::weizhu::im::GroupChat_Member* GroupChat::add_member() {
  // @@protoc_insertion_point(field_add:weizhu.im.GroupChat.member)
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat_Member >&
GroupChat::member() const {
  // @@protoc_insertion_point(field_list:weizhu.im.GroupChat.member)
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat_Member >*
GroupChat::mutable_member() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.GroupChat.member)
  return &member_;
}

// optional .weizhu.im.InstantMessage latest_msg = 4;
inline bool GroupChat::has_latest_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupChat::set_has_latest_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupChat::clear_has_latest_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupChat::clear_latest_msg() {
  if (latest_msg_ != NULL) latest_msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_latest_msg();
}
inline const ::weizhu::im::InstantMessage& GroupChat::latest_msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GroupChat.latest_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return latest_msg_ != NULL ? *latest_msg_ : *default_instance().latest_msg_;
#else
  return latest_msg_ != NULL ? *latest_msg_ : *default_instance_->latest_msg_;
#endif
}
inline ::weizhu::im::InstantMessage* GroupChat::mutable_latest_msg() {
  set_has_latest_msg();
  if (latest_msg_ == NULL) latest_msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.GroupChat.latest_msg)
  return latest_msg_;
}
inline ::weizhu::im::InstantMessage* GroupChat::release_latest_msg() {
  clear_has_latest_msg();
  ::weizhu::im::InstantMessage* temp = latest_msg_;
  latest_msg_ = NULL;
  return temp;
}
inline void GroupChat::set_allocated_latest_msg(::weizhu::im::InstantMessage* latest_msg) {
  delete latest_msg_;
  latest_msg_ = latest_msg;
  if (latest_msg) {
    set_has_latest_msg();
  } else {
    clear_has_latest_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.GroupChat.latest_msg)
}

// -------------------------------------------------------------------

// IMP2PMessagePush

// required int64 user_id = 1;
inline bool IMP2PMessagePush::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMP2PMessagePush::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMP2PMessagePush::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMP2PMessagePush::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 IMP2PMessagePush::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.IMP2PMessagePush.user_id)
  return user_id_;
}
inline void IMP2PMessagePush::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.IMP2PMessagePush.user_id)
}

// required .weizhu.im.InstantMessage msg = 2;
inline bool IMP2PMessagePush::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMP2PMessagePush::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMP2PMessagePush::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMP2PMessagePush::clear_msg() {
  if (msg_ != NULL) msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_msg();
}
inline const ::weizhu::im::InstantMessage& IMP2PMessagePush::msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.IMP2PMessagePush.msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_ != NULL ? *msg_ : *default_instance().msg_;
#else
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
#endif
}
inline ::weizhu::im::InstantMessage* IMP2PMessagePush::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.IMP2PMessagePush.msg)
  return msg_;
}
inline ::weizhu::im::InstantMessage* IMP2PMessagePush::release_msg() {
  clear_has_msg();
  ::weizhu::im::InstantMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void IMP2PMessagePush::set_allocated_msg(::weizhu::im::InstantMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.IMP2PMessagePush.msg)
}

// -------------------------------------------------------------------

// IMP2PStatePush

// required int64 user_id = 1;
inline bool IMP2PStatePush::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMP2PStatePush::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMP2PStatePush::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMP2PStatePush::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 IMP2PStatePush::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.IMP2PStatePush.user_id)
  return user_id_;
}
inline void IMP2PStatePush::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.IMP2PStatePush.user_id)
}

// -------------------------------------------------------------------

// IMGroupStatePush

// required int64 group_id = 1;
inline bool IMGroupStatePush::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupStatePush::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupStatePush::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupStatePush::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 IMGroupStatePush::group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.IMGroupStatePush.group_id)
  return group_id_;
}
inline void IMGroupStatePush::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.IMGroupStatePush.group_id)
}

// -------------------------------------------------------------------

// GetP2PMessageRequest

// required int64 user_id = 1;
inline bool GetP2PMessageRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetP2PMessageRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetP2PMessageRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetP2PMessageRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 GetP2PMessageRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PMessageRequest.user_id)
  return user_id_;
}
inline void GetP2PMessageRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PMessageRequest.user_id)
}

// optional int64 msg_seq_begin = 2;
inline bool GetP2PMessageRequest::has_msg_seq_begin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetP2PMessageRequest::set_has_msg_seq_begin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetP2PMessageRequest::clear_has_msg_seq_begin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetP2PMessageRequest::clear_msg_seq_begin() {
  msg_seq_begin_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq_begin();
}
inline ::google::protobuf::int64 GetP2PMessageRequest::msg_seq_begin() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PMessageRequest.msg_seq_begin)
  return msg_seq_begin_;
}
inline void GetP2PMessageRequest::set_msg_seq_begin(::google::protobuf::int64 value) {
  set_has_msg_seq_begin();
  msg_seq_begin_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PMessageRequest.msg_seq_begin)
}

// optional int64 msg_seq_end = 3;
inline bool GetP2PMessageRequest::has_msg_seq_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetP2PMessageRequest::set_has_msg_seq_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetP2PMessageRequest::clear_has_msg_seq_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetP2PMessageRequest::clear_msg_seq_end() {
  msg_seq_end_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq_end();
}
inline ::google::protobuf::int64 GetP2PMessageRequest::msg_seq_end() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PMessageRequest.msg_seq_end)
  return msg_seq_end_;
}
inline void GetP2PMessageRequest::set_msg_seq_end(::google::protobuf::int64 value) {
  set_has_msg_seq_end();
  msg_seq_end_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PMessageRequest.msg_seq_end)
}

// required int32 msg_size = 4;
inline bool GetP2PMessageRequest::has_msg_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetP2PMessageRequest::set_has_msg_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetP2PMessageRequest::clear_has_msg_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetP2PMessageRequest::clear_msg_size() {
  msg_size_ = 0;
  clear_has_msg_size();
}
inline ::google::protobuf::int32 GetP2PMessageRequest::msg_size() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PMessageRequest.msg_size)
  return msg_size_;
}
inline void GetP2PMessageRequest::set_msg_size(::google::protobuf::int32 value) {
  set_has_msg_size();
  msg_size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PMessageRequest.msg_size)
}

// -------------------------------------------------------------------

// GetGroupMessageRequest

// required int64 group_id = 1;
inline bool GetGroupMessageRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroupMessageRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroupMessageRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroupMessageRequest::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 GetGroupMessageRequest::group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupMessageRequest.group_id)
  return group_id_;
}
inline void GetGroupMessageRequest::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupMessageRequest.group_id)
}

// optional int64 msg_seq_begin = 2;
inline bool GetGroupMessageRequest::has_msg_seq_begin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGroupMessageRequest::set_has_msg_seq_begin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGroupMessageRequest::clear_has_msg_seq_begin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGroupMessageRequest::clear_msg_seq_begin() {
  msg_seq_begin_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq_begin();
}
inline ::google::protobuf::int64 GetGroupMessageRequest::msg_seq_begin() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupMessageRequest.msg_seq_begin)
  return msg_seq_begin_;
}
inline void GetGroupMessageRequest::set_msg_seq_begin(::google::protobuf::int64 value) {
  set_has_msg_seq_begin();
  msg_seq_begin_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupMessageRequest.msg_seq_begin)
}

// optional int64 msg_seq_end = 3;
inline bool GetGroupMessageRequest::has_msg_seq_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetGroupMessageRequest::set_has_msg_seq_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetGroupMessageRequest::clear_has_msg_seq_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetGroupMessageRequest::clear_msg_seq_end() {
  msg_seq_end_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq_end();
}
inline ::google::protobuf::int64 GetGroupMessageRequest::msg_seq_end() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupMessageRequest.msg_seq_end)
  return msg_seq_end_;
}
inline void GetGroupMessageRequest::set_msg_seq_end(::google::protobuf::int64 value) {
  set_has_msg_seq_end();
  msg_seq_end_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupMessageRequest.msg_seq_end)
}

// required int32 msg_size = 4;
inline bool GetGroupMessageRequest::has_msg_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetGroupMessageRequest::set_has_msg_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetGroupMessageRequest::clear_has_msg_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetGroupMessageRequest::clear_msg_size() {
  msg_size_ = 0;
  clear_has_msg_size();
}
inline ::google::protobuf::int32 GetGroupMessageRequest::msg_size() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupMessageRequest.msg_size)
  return msg_size_;
}
inline void GetGroupMessageRequest::set_msg_size(::google::protobuf::int32 value) {
  set_has_msg_size();
  msg_size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupMessageRequest.msg_size)
}

// -------------------------------------------------------------------

// GetMessageResponse

// repeated .weizhu.im.InstantMessage msg = 1;
inline int GetMessageResponse::msg_size() const {
  return msg_.size();
}
inline void GetMessageResponse::clear_msg() {
  msg_.Clear();
}
inline const ::weizhu::im::InstantMessage& GetMessageResponse::msg(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetMessageResponse.msg)
  return msg_.Get(index);
}
inline ::weizhu::im::InstantMessage* GetMessageResponse::mutable_msg(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.im.GetMessageResponse.msg)
  return msg_.Mutable(index);
}
inline ::weizhu::im::InstantMessage* GetMessageResponse::add_msg() {
  // @@protoc_insertion_point(field_add:weizhu.im.GetMessageResponse.msg)
  return msg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::InstantMessage >&
GetMessageResponse::msg() const {
  // @@protoc_insertion_point(field_list:weizhu.im.GetMessageResponse.msg)
  return msg_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::InstantMessage >*
GetMessageResponse::mutable_msg() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.GetMessageResponse.msg)
  return &msg_;
}

// required bool has_more = 2;
inline bool GetMessageResponse::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMessageResponse::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMessageResponse::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMessageResponse::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool GetMessageResponse::has_more() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetMessageResponse.has_more)
  return has_more_;
}
inline void GetMessageResponse::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetMessageResponse.has_more)
}

// -------------------------------------------------------------------

// SendP2PMessageRequest

// required int64 to_user_id = 1;
inline bool SendP2PMessageRequest::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendP2PMessageRequest::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendP2PMessageRequest::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendP2PMessageRequest::clear_to_user_id() {
  to_user_id_ = GOOGLE_LONGLONG(0);
  clear_has_to_user_id();
}
inline ::google::protobuf::int64 SendP2PMessageRequest::to_user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendP2PMessageRequest.to_user_id)
  return to_user_id_;
}
inline void SendP2PMessageRequest::set_to_user_id(::google::protobuf::int64 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendP2PMessageRequest.to_user_id)
}

// required .weizhu.im.InstantMessage msg = 2;
inline bool SendP2PMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendP2PMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendP2PMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendP2PMessageRequest::clear_msg() {
  if (msg_ != NULL) msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_msg();
}
inline const ::weizhu::im::InstantMessage& SendP2PMessageRequest::msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendP2PMessageRequest.msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_ != NULL ? *msg_ : *default_instance().msg_;
#else
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
#endif
}
inline ::weizhu::im::InstantMessage* SendP2PMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.SendP2PMessageRequest.msg)
  return msg_;
}
inline ::weizhu::im::InstantMessage* SendP2PMessageRequest::release_msg() {
  clear_has_msg();
  ::weizhu::im::InstantMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void SendP2PMessageRequest::set_allocated_msg(::weizhu::im::InstantMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SendP2PMessageRequest.msg)
}

// -------------------------------------------------------------------

// SendP2PMessageResponse

// optional .weizhu.im.SendP2PMessageResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool SendP2PMessageResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendP2PMessageResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendP2PMessageResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendP2PMessageResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::im::SendP2PMessageResponse_Result SendP2PMessageResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendP2PMessageResponse.result)
  return static_cast< ::weizhu::im::SendP2PMessageResponse_Result >(result_);
}
inline void SendP2PMessageResponse::set_result(::weizhu::im::SendP2PMessageResponse_Result value) {
  assert(::weizhu::im::SendP2PMessageResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendP2PMessageResponse.result)
}

// optional string fail_text = 2;
inline bool SendP2PMessageResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendP2PMessageResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendP2PMessageResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendP2PMessageResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& SendP2PMessageResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendP2PMessageResponse.fail_text)
  return *fail_text_;
}
inline void SendP2PMessageResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.SendP2PMessageResponse.fail_text)
}
inline void SendP2PMessageResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.SendP2PMessageResponse.fail_text)
}
inline void SendP2PMessageResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.SendP2PMessageResponse.fail_text)
}
inline ::std::string* SendP2PMessageResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.SendP2PMessageResponse.fail_text)
  return fail_text_;
}
inline ::std::string* SendP2PMessageResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendP2PMessageResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SendP2PMessageResponse.fail_text)
}

// optional int64 msg_seq = 3;
inline bool SendP2PMessageResponse::has_msg_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendP2PMessageResponse::set_has_msg_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendP2PMessageResponse::clear_has_msg_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendP2PMessageResponse::clear_msg_seq() {
  msg_seq_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq();
}
inline ::google::protobuf::int64 SendP2PMessageResponse::msg_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendP2PMessageResponse.msg_seq)
  return msg_seq_;
}
inline void SendP2PMessageResponse::set_msg_seq(::google::protobuf::int64 value) {
  set_has_msg_seq();
  msg_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendP2PMessageResponse.msg_seq)
}

// optional int32 msg_time = 4;
inline bool SendP2PMessageResponse::has_msg_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendP2PMessageResponse::set_has_msg_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendP2PMessageResponse::clear_has_msg_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendP2PMessageResponse::clear_msg_time() {
  msg_time_ = 0;
  clear_has_msg_time();
}
inline ::google::protobuf::int32 SendP2PMessageResponse::msg_time() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendP2PMessageResponse.msg_time)
  return msg_time_;
}
inline void SendP2PMessageResponse::set_msg_time(::google::protobuf::int32 value) {
  set_has_msg_time();
  msg_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendP2PMessageResponse.msg_time)
}

// -------------------------------------------------------------------

// GetP2PChatListRequest

// optional int64 last_user_id = 1;
inline bool GetP2PChatListRequest::has_last_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetP2PChatListRequest::set_has_last_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetP2PChatListRequest::clear_has_last_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetP2PChatListRequest::clear_last_user_id() {
  last_user_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_user_id();
}
inline ::google::protobuf::int64 GetP2PChatListRequest::last_user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PChatListRequest.last_user_id)
  return last_user_id_;
}
inline void GetP2PChatListRequest::set_last_user_id(::google::protobuf::int64 value) {
  set_has_last_user_id();
  last_user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PChatListRequest.last_user_id)
}

// optional int32 last_msg_time = 2;
inline bool GetP2PChatListRequest::has_last_msg_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetP2PChatListRequest::set_has_last_msg_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetP2PChatListRequest::clear_has_last_msg_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetP2PChatListRequest::clear_last_msg_time() {
  last_msg_time_ = 0;
  clear_has_last_msg_time();
}
inline ::google::protobuf::int32 GetP2PChatListRequest::last_msg_time() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PChatListRequest.last_msg_time)
  return last_msg_time_;
}
inline void GetP2PChatListRequest::set_last_msg_time(::google::protobuf::int32 value) {
  set_has_last_msg_time();
  last_msg_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PChatListRequest.last_msg_time)
}

// required int32 chat_size = 3;
inline bool GetP2PChatListRequest::has_chat_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetP2PChatListRequest::set_has_chat_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetP2PChatListRequest::clear_has_chat_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetP2PChatListRequest::clear_chat_size() {
  chat_size_ = 0;
  clear_has_chat_size();
}
inline ::google::protobuf::int32 GetP2PChatListRequest::chat_size() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PChatListRequest.chat_size)
  return chat_size_;
}
inline void GetP2PChatListRequest::set_chat_size(::google::protobuf::int32 value) {
  set_has_chat_size();
  chat_size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PChatListRequest.chat_size)
}

// -------------------------------------------------------------------

// GetP2PChatListResponse

// repeated .weizhu.im.P2PChat chat = 1;
inline int GetP2PChatListResponse::chat_size() const {
  return chat_.size();
}
inline void GetP2PChatListResponse::clear_chat() {
  chat_.Clear();
}
inline const ::weizhu::im::P2PChat& GetP2PChatListResponse::chat(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PChatListResponse.chat)
  return chat_.Get(index);
}
inline ::weizhu::im::P2PChat* GetP2PChatListResponse::mutable_chat(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.im.GetP2PChatListResponse.chat)
  return chat_.Mutable(index);
}
inline ::weizhu::im::P2PChat* GetP2PChatListResponse::add_chat() {
  // @@protoc_insertion_point(field_add:weizhu.im.GetP2PChatListResponse.chat)
  return chat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::P2PChat >&
GetP2PChatListResponse::chat() const {
  // @@protoc_insertion_point(field_list:weizhu.im.GetP2PChatListResponse.chat)
  return chat_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::P2PChat >*
GetP2PChatListResponse::mutable_chat() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.GetP2PChatListResponse.chat)
  return &chat_;
}

// required bool has_more = 2;
inline bool GetP2PChatListResponse::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetP2PChatListResponse::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetP2PChatListResponse::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetP2PChatListResponse::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool GetP2PChatListResponse::has_more() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetP2PChatListResponse.has_more)
  return has_more_;
}
inline void GetP2PChatListResponse::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetP2PChatListResponse.has_more)
}

// -------------------------------------------------------------------

// GetGroupChatByIdRequest

// repeated int64 group_id = 1;
inline int GetGroupChatByIdRequest::group_id_size() const {
  return group_id_.size();
}
inline void GetGroupChatByIdRequest::clear_group_id() {
  group_id_.Clear();
}
inline ::google::protobuf::int64 GetGroupChatByIdRequest::group_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupChatByIdRequest.group_id)
  return group_id_.Get(index);
}
inline void GetGroupChatByIdRequest::set_group_id(int index, ::google::protobuf::int64 value) {
  group_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupChatByIdRequest.group_id)
}
inline void GetGroupChatByIdRequest::add_group_id(::google::protobuf::int64 value) {
  group_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.im.GetGroupChatByIdRequest.group_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetGroupChatByIdRequest::group_id() const {
  // @@protoc_insertion_point(field_list:weizhu.im.GetGroupChatByIdRequest.group_id)
  return group_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetGroupChatByIdRequest::mutable_group_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.GetGroupChatByIdRequest.group_id)
  return &group_id_;
}

// -------------------------------------------------------------------

// GetGroupChatByIdResponse

// repeated .weizhu.im.GroupChat group_chat = 1;
inline int GetGroupChatByIdResponse::group_chat_size() const {
  return group_chat_.size();
}
inline void GetGroupChatByIdResponse::clear_group_chat() {
  group_chat_.Clear();
}
inline const ::weizhu::im::GroupChat& GetGroupChatByIdResponse::group_chat(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupChatByIdResponse.group_chat)
  return group_chat_.Get(index);
}
inline ::weizhu::im::GroupChat* GetGroupChatByIdResponse::mutable_group_chat(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.im.GetGroupChatByIdResponse.group_chat)
  return group_chat_.Mutable(index);
}
inline ::weizhu::im::GroupChat* GetGroupChatByIdResponse::add_group_chat() {
  // @@protoc_insertion_point(field_add:weizhu.im.GetGroupChatByIdResponse.group_chat)
  return group_chat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >&
GetGroupChatByIdResponse::group_chat() const {
  // @@protoc_insertion_point(field_list:weizhu.im.GetGroupChatByIdResponse.group_chat)
  return group_chat_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >*
GetGroupChatByIdResponse::mutable_group_chat() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.GetGroupChatByIdResponse.group_chat)
  return &group_chat_;
}

// -------------------------------------------------------------------

// CreateGroupChatRequest

// required string group_name = 1;
inline bool CreateGroupChatRequest::has_group_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateGroupChatRequest::set_has_group_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateGroupChatRequest::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateGroupChatRequest::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& CreateGroupChatRequest::group_name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.CreateGroupChatRequest.group_name)
  return *group_name_;
}
inline void CreateGroupChatRequest::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.CreateGroupChatRequest.group_name)
}
inline void CreateGroupChatRequest::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.CreateGroupChatRequest.group_name)
}
inline void CreateGroupChatRequest::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.CreateGroupChatRequest.group_name)
}
inline ::std::string* CreateGroupChatRequest::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.CreateGroupChatRequest.group_name)
  return group_name_;
}
inline ::std::string* CreateGroupChatRequest::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateGroupChatRequest::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.CreateGroupChatRequest.group_name)
}

// repeated int64 member_user_id = 2;
inline int CreateGroupChatRequest::member_user_id_size() const {
  return member_user_id_.size();
}
inline void CreateGroupChatRequest::clear_member_user_id() {
  member_user_id_.Clear();
}
inline ::google::protobuf::int64 CreateGroupChatRequest::member_user_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.CreateGroupChatRequest.member_user_id)
  return member_user_id_.Get(index);
}
inline void CreateGroupChatRequest::set_member_user_id(int index, ::google::protobuf::int64 value) {
  member_user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.im.CreateGroupChatRequest.member_user_id)
}
inline void CreateGroupChatRequest::add_member_user_id(::google::protobuf::int64 value) {
  member_user_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.im.CreateGroupChatRequest.member_user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CreateGroupChatRequest::member_user_id() const {
  // @@protoc_insertion_point(field_list:weizhu.im.CreateGroupChatRequest.member_user_id)
  return member_user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CreateGroupChatRequest::mutable_member_user_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.CreateGroupChatRequest.member_user_id)
  return &member_user_id_;
}

// -------------------------------------------------------------------

// CreateGroupChatResponse

// optional .weizhu.im.CreateGroupChatResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool CreateGroupChatResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateGroupChatResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateGroupChatResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateGroupChatResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::im::CreateGroupChatResponse_Result CreateGroupChatResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.im.CreateGroupChatResponse.result)
  return static_cast< ::weizhu::im::CreateGroupChatResponse_Result >(result_);
}
inline void CreateGroupChatResponse::set_result(::weizhu::im::CreateGroupChatResponse_Result value) {
  assert(::weizhu::im::CreateGroupChatResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.CreateGroupChatResponse.result)
}

// optional string fail_text = 2;
inline bool CreateGroupChatResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateGroupChatResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateGroupChatResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateGroupChatResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& CreateGroupChatResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.im.CreateGroupChatResponse.fail_text)
  return *fail_text_;
}
inline void CreateGroupChatResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.CreateGroupChatResponse.fail_text)
}
inline void CreateGroupChatResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.CreateGroupChatResponse.fail_text)
}
inline void CreateGroupChatResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.CreateGroupChatResponse.fail_text)
}
inline ::std::string* CreateGroupChatResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.CreateGroupChatResponse.fail_text)
  return fail_text_;
}
inline ::std::string* CreateGroupChatResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateGroupChatResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.CreateGroupChatResponse.fail_text)
}

// optional .weizhu.im.GroupChat group_chat = 3;
inline bool CreateGroupChatResponse::has_group_chat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateGroupChatResponse::set_has_group_chat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateGroupChatResponse::clear_has_group_chat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateGroupChatResponse::clear_group_chat() {
  if (group_chat_ != NULL) group_chat_->::weizhu::im::GroupChat::Clear();
  clear_has_group_chat();
}
inline const ::weizhu::im::GroupChat& CreateGroupChatResponse::group_chat() const {
  // @@protoc_insertion_point(field_get:weizhu.im.CreateGroupChatResponse.group_chat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_chat_ != NULL ? *group_chat_ : *default_instance().group_chat_;
#else
  return group_chat_ != NULL ? *group_chat_ : *default_instance_->group_chat_;
#endif
}
inline ::weizhu::im::GroupChat* CreateGroupChatResponse::mutable_group_chat() {
  set_has_group_chat();
  if (group_chat_ == NULL) group_chat_ = new ::weizhu::im::GroupChat;
  // @@protoc_insertion_point(field_mutable:weizhu.im.CreateGroupChatResponse.group_chat)
  return group_chat_;
}
inline ::weizhu::im::GroupChat* CreateGroupChatResponse::release_group_chat() {
  clear_has_group_chat();
  ::weizhu::im::GroupChat* temp = group_chat_;
  group_chat_ = NULL;
  return temp;
}
inline void CreateGroupChatResponse::set_allocated_group_chat(::weizhu::im::GroupChat* group_chat) {
  delete group_chat_;
  group_chat_ = group_chat;
  if (group_chat) {
    set_has_group_chat();
  } else {
    clear_has_group_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.CreateGroupChatResponse.group_chat)
}

// -------------------------------------------------------------------

// SetGroupNameRequest

// required int64 group_id = 1;
inline bool SetGroupNameRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetGroupNameRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetGroupNameRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetGroupNameRequest::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 SetGroupNameRequest::group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SetGroupNameRequest.group_id)
  return group_id_;
}
inline void SetGroupNameRequest::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SetGroupNameRequest.group_id)
}

// required string group_name = 2;
inline bool SetGroupNameRequest::has_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetGroupNameRequest::set_has_group_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetGroupNameRequest::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetGroupNameRequest::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& SetGroupNameRequest::group_name() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SetGroupNameRequest.group_name)
  return *group_name_;
}
inline void SetGroupNameRequest::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.SetGroupNameRequest.group_name)
}
inline void SetGroupNameRequest::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.SetGroupNameRequest.group_name)
}
inline void SetGroupNameRequest::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.SetGroupNameRequest.group_name)
}
inline ::std::string* SetGroupNameRequest::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.SetGroupNameRequest.group_name)
  return group_name_;
}
inline ::std::string* SetGroupNameRequest::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetGroupNameRequest::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SetGroupNameRequest.group_name)
}

// -------------------------------------------------------------------

// SetGroupNameResponse

// optional .weizhu.im.SetGroupNameResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool SetGroupNameResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetGroupNameResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetGroupNameResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetGroupNameResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::im::SetGroupNameResponse_Result SetGroupNameResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SetGroupNameResponse.result)
  return static_cast< ::weizhu::im::SetGroupNameResponse_Result >(result_);
}
inline void SetGroupNameResponse::set_result(::weizhu::im::SetGroupNameResponse_Result value) {
  assert(::weizhu::im::SetGroupNameResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SetGroupNameResponse.result)
}

// optional string fail_text = 2;
inline bool SetGroupNameResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetGroupNameResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetGroupNameResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetGroupNameResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& SetGroupNameResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SetGroupNameResponse.fail_text)
  return *fail_text_;
}
inline void SetGroupNameResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.SetGroupNameResponse.fail_text)
}
inline void SetGroupNameResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.SetGroupNameResponse.fail_text)
}
inline void SetGroupNameResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.SetGroupNameResponse.fail_text)
}
inline ::std::string* SetGroupNameResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.SetGroupNameResponse.fail_text)
  return fail_text_;
}
inline ::std::string* SetGroupNameResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetGroupNameResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SetGroupNameResponse.fail_text)
}

// optional .weizhu.im.InstantMessage group_msg = 3;
inline bool SetGroupNameResponse::has_group_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetGroupNameResponse::set_has_group_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetGroupNameResponse::clear_has_group_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetGroupNameResponse::clear_group_msg() {
  if (group_msg_ != NULL) group_msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_group_msg();
}
inline const ::weizhu::im::InstantMessage& SetGroupNameResponse::group_msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SetGroupNameResponse.group_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_msg_ != NULL ? *group_msg_ : *default_instance().group_msg_;
#else
  return group_msg_ != NULL ? *group_msg_ : *default_instance_->group_msg_;
#endif
}
inline ::weizhu::im::InstantMessage* SetGroupNameResponse::mutable_group_msg() {
  set_has_group_msg();
  if (group_msg_ == NULL) group_msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.SetGroupNameResponse.group_msg)
  return group_msg_;
}
inline ::weizhu::im::InstantMessage* SetGroupNameResponse::release_group_msg() {
  clear_has_group_msg();
  ::weizhu::im::InstantMessage* temp = group_msg_;
  group_msg_ = NULL;
  return temp;
}
inline void SetGroupNameResponse::set_allocated_group_msg(::weizhu::im::InstantMessage* group_msg) {
  delete group_msg_;
  group_msg_ = group_msg;
  if (group_msg) {
    set_has_group_msg();
  } else {
    clear_has_group_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SetGroupNameResponse.group_msg)
}

// optional .weizhu.im.GroupChat group_chat = 4;
inline bool SetGroupNameResponse::has_group_chat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetGroupNameResponse::set_has_group_chat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetGroupNameResponse::clear_has_group_chat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetGroupNameResponse::clear_group_chat() {
  if (group_chat_ != NULL) group_chat_->::weizhu::im::GroupChat::Clear();
  clear_has_group_chat();
}
inline const ::weizhu::im::GroupChat& SetGroupNameResponse::group_chat() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SetGroupNameResponse.group_chat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_chat_ != NULL ? *group_chat_ : *default_instance().group_chat_;
#else
  return group_chat_ != NULL ? *group_chat_ : *default_instance_->group_chat_;
#endif
}
inline ::weizhu::im::GroupChat* SetGroupNameResponse::mutable_group_chat() {
  set_has_group_chat();
  if (group_chat_ == NULL) group_chat_ = new ::weizhu::im::GroupChat;
  // @@protoc_insertion_point(field_mutable:weizhu.im.SetGroupNameResponse.group_chat)
  return group_chat_;
}
inline ::weizhu::im::GroupChat* SetGroupNameResponse::release_group_chat() {
  clear_has_group_chat();
  ::weizhu::im::GroupChat* temp = group_chat_;
  group_chat_ = NULL;
  return temp;
}
inline void SetGroupNameResponse::set_allocated_group_chat(::weizhu::im::GroupChat* group_chat) {
  delete group_chat_;
  group_chat_ = group_chat;
  if (group_chat) {
    set_has_group_chat();
  } else {
    clear_has_group_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SetGroupNameResponse.group_chat)
}

// -------------------------------------------------------------------

// JoinGroupChatRequest

// required int64 group_id = 1;
inline bool JoinGroupChatRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGroupChatRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGroupChatRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGroupChatRequest::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 JoinGroupChatRequest::group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.JoinGroupChatRequest.group_id)
  return group_id_;
}
inline void JoinGroupChatRequest::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.JoinGroupChatRequest.group_id)
}

// repeated int64 join_user_id = 2;
inline int JoinGroupChatRequest::join_user_id_size() const {
  return join_user_id_.size();
}
inline void JoinGroupChatRequest::clear_join_user_id() {
  join_user_id_.Clear();
}
inline ::google::protobuf::int64 JoinGroupChatRequest::join_user_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.JoinGroupChatRequest.join_user_id)
  return join_user_id_.Get(index);
}
inline void JoinGroupChatRequest::set_join_user_id(int index, ::google::protobuf::int64 value) {
  join_user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.im.JoinGroupChatRequest.join_user_id)
}
inline void JoinGroupChatRequest::add_join_user_id(::google::protobuf::int64 value) {
  join_user_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.im.JoinGroupChatRequest.join_user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
JoinGroupChatRequest::join_user_id() const {
  // @@protoc_insertion_point(field_list:weizhu.im.JoinGroupChatRequest.join_user_id)
  return join_user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
JoinGroupChatRequest::mutable_join_user_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.JoinGroupChatRequest.join_user_id)
  return &join_user_id_;
}

// -------------------------------------------------------------------

// JoinGroupChatResponse

// optional .weizhu.im.JoinGroupChatResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool JoinGroupChatResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGroupChatResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGroupChatResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGroupChatResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::im::JoinGroupChatResponse_Result JoinGroupChatResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.im.JoinGroupChatResponse.result)
  return static_cast< ::weizhu::im::JoinGroupChatResponse_Result >(result_);
}
inline void JoinGroupChatResponse::set_result(::weizhu::im::JoinGroupChatResponse_Result value) {
  assert(::weizhu::im::JoinGroupChatResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.JoinGroupChatResponse.result)
}

// optional string fail_text = 2;
inline bool JoinGroupChatResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGroupChatResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGroupChatResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGroupChatResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& JoinGroupChatResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.im.JoinGroupChatResponse.fail_text)
  return *fail_text_;
}
inline void JoinGroupChatResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.JoinGroupChatResponse.fail_text)
}
inline void JoinGroupChatResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.JoinGroupChatResponse.fail_text)
}
inline void JoinGroupChatResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.JoinGroupChatResponse.fail_text)
}
inline ::std::string* JoinGroupChatResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.JoinGroupChatResponse.fail_text)
  return fail_text_;
}
inline ::std::string* JoinGroupChatResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JoinGroupChatResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.JoinGroupChatResponse.fail_text)
}

// optional .weizhu.im.InstantMessage group_msg = 3;
inline bool JoinGroupChatResponse::has_group_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinGroupChatResponse::set_has_group_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinGroupChatResponse::clear_has_group_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinGroupChatResponse::clear_group_msg() {
  if (group_msg_ != NULL) group_msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_group_msg();
}
inline const ::weizhu::im::InstantMessage& JoinGroupChatResponse::group_msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.JoinGroupChatResponse.group_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_msg_ != NULL ? *group_msg_ : *default_instance().group_msg_;
#else
  return group_msg_ != NULL ? *group_msg_ : *default_instance_->group_msg_;
#endif
}
inline ::weizhu::im::InstantMessage* JoinGroupChatResponse::mutable_group_msg() {
  set_has_group_msg();
  if (group_msg_ == NULL) group_msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.JoinGroupChatResponse.group_msg)
  return group_msg_;
}
inline ::weizhu::im::InstantMessage* JoinGroupChatResponse::release_group_msg() {
  clear_has_group_msg();
  ::weizhu::im::InstantMessage* temp = group_msg_;
  group_msg_ = NULL;
  return temp;
}
inline void JoinGroupChatResponse::set_allocated_group_msg(::weizhu::im::InstantMessage* group_msg) {
  delete group_msg_;
  group_msg_ = group_msg;
  if (group_msg) {
    set_has_group_msg();
  } else {
    clear_has_group_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.JoinGroupChatResponse.group_msg)
}

// optional .weizhu.im.GroupChat group_chat = 4;
inline bool JoinGroupChatResponse::has_group_chat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinGroupChatResponse::set_has_group_chat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinGroupChatResponse::clear_has_group_chat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinGroupChatResponse::clear_group_chat() {
  if (group_chat_ != NULL) group_chat_->::weizhu::im::GroupChat::Clear();
  clear_has_group_chat();
}
inline const ::weizhu::im::GroupChat& JoinGroupChatResponse::group_chat() const {
  // @@protoc_insertion_point(field_get:weizhu.im.JoinGroupChatResponse.group_chat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_chat_ != NULL ? *group_chat_ : *default_instance().group_chat_;
#else
  return group_chat_ != NULL ? *group_chat_ : *default_instance_->group_chat_;
#endif
}
inline ::weizhu::im::GroupChat* JoinGroupChatResponse::mutable_group_chat() {
  set_has_group_chat();
  if (group_chat_ == NULL) group_chat_ = new ::weizhu::im::GroupChat;
  // @@protoc_insertion_point(field_mutable:weizhu.im.JoinGroupChatResponse.group_chat)
  return group_chat_;
}
inline ::weizhu::im::GroupChat* JoinGroupChatResponse::release_group_chat() {
  clear_has_group_chat();
  ::weizhu::im::GroupChat* temp = group_chat_;
  group_chat_ = NULL;
  return temp;
}
inline void JoinGroupChatResponse::set_allocated_group_chat(::weizhu::im::GroupChat* group_chat) {
  delete group_chat_;
  group_chat_ = group_chat;
  if (group_chat) {
    set_has_group_chat();
  } else {
    clear_has_group_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.JoinGroupChatResponse.group_chat)
}

// -------------------------------------------------------------------

// LeaveGroupChatRequest

// required int64 group_id = 1;
inline bool LeaveGroupChatRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGroupChatRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGroupChatRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGroupChatRequest::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 LeaveGroupChatRequest::group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.LeaveGroupChatRequest.group_id)
  return group_id_;
}
inline void LeaveGroupChatRequest::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.LeaveGroupChatRequest.group_id)
}

// -------------------------------------------------------------------

// LeaveGroupChatResponse

// optional .weizhu.im.LeaveGroupChatResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool LeaveGroupChatResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGroupChatResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGroupChatResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGroupChatResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::im::LeaveGroupChatResponse_Result LeaveGroupChatResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.im.LeaveGroupChatResponse.result)
  return static_cast< ::weizhu::im::LeaveGroupChatResponse_Result >(result_);
}
inline void LeaveGroupChatResponse::set_result(::weizhu::im::LeaveGroupChatResponse_Result value) {
  assert(::weizhu::im::LeaveGroupChatResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.LeaveGroupChatResponse.result)
}

// optional string fail_text = 2;
inline bool LeaveGroupChatResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveGroupChatResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveGroupChatResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveGroupChatResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& LeaveGroupChatResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.im.LeaveGroupChatResponse.fail_text)
  return *fail_text_;
}
inline void LeaveGroupChatResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.LeaveGroupChatResponse.fail_text)
}
inline void LeaveGroupChatResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.LeaveGroupChatResponse.fail_text)
}
inline void LeaveGroupChatResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.LeaveGroupChatResponse.fail_text)
}
inline ::std::string* LeaveGroupChatResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.LeaveGroupChatResponse.fail_text)
  return fail_text_;
}
inline ::std::string* LeaveGroupChatResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LeaveGroupChatResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.LeaveGroupChatResponse.fail_text)
}

// optional .weizhu.im.InstantMessage group_msg = 3;
inline bool LeaveGroupChatResponse::has_group_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaveGroupChatResponse::set_has_group_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaveGroupChatResponse::clear_has_group_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaveGroupChatResponse::clear_group_msg() {
  if (group_msg_ != NULL) group_msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_group_msg();
}
inline const ::weizhu::im::InstantMessage& LeaveGroupChatResponse::group_msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.LeaveGroupChatResponse.group_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_msg_ != NULL ? *group_msg_ : *default_instance().group_msg_;
#else
  return group_msg_ != NULL ? *group_msg_ : *default_instance_->group_msg_;
#endif
}
inline ::weizhu::im::InstantMessage* LeaveGroupChatResponse::mutable_group_msg() {
  set_has_group_msg();
  if (group_msg_ == NULL) group_msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.LeaveGroupChatResponse.group_msg)
  return group_msg_;
}
inline ::weizhu::im::InstantMessage* LeaveGroupChatResponse::release_group_msg() {
  clear_has_group_msg();
  ::weizhu::im::InstantMessage* temp = group_msg_;
  group_msg_ = NULL;
  return temp;
}
inline void LeaveGroupChatResponse::set_allocated_group_msg(::weizhu::im::InstantMessage* group_msg) {
  delete group_msg_;
  group_msg_ = group_msg;
  if (group_msg) {
    set_has_group_msg();
  } else {
    clear_has_group_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.LeaveGroupChatResponse.group_msg)
}

// optional .weizhu.im.GroupChat group_chat = 4;
inline bool LeaveGroupChatResponse::has_group_chat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeaveGroupChatResponse::set_has_group_chat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeaveGroupChatResponse::clear_has_group_chat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeaveGroupChatResponse::clear_group_chat() {
  if (group_chat_ != NULL) group_chat_->::weizhu::im::GroupChat::Clear();
  clear_has_group_chat();
}
inline const ::weizhu::im::GroupChat& LeaveGroupChatResponse::group_chat() const {
  // @@protoc_insertion_point(field_get:weizhu.im.LeaveGroupChatResponse.group_chat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_chat_ != NULL ? *group_chat_ : *default_instance().group_chat_;
#else
  return group_chat_ != NULL ? *group_chat_ : *default_instance_->group_chat_;
#endif
}
inline ::weizhu::im::GroupChat* LeaveGroupChatResponse::mutable_group_chat() {
  set_has_group_chat();
  if (group_chat_ == NULL) group_chat_ = new ::weizhu::im::GroupChat;
  // @@protoc_insertion_point(field_mutable:weizhu.im.LeaveGroupChatResponse.group_chat)
  return group_chat_;
}
inline ::weizhu::im::GroupChat* LeaveGroupChatResponse::release_group_chat() {
  clear_has_group_chat();
  ::weizhu::im::GroupChat* temp = group_chat_;
  group_chat_ = NULL;
  return temp;
}
inline void LeaveGroupChatResponse::set_allocated_group_chat(::weizhu::im::GroupChat* group_chat) {
  delete group_chat_;
  group_chat_ = group_chat;
  if (group_chat) {
    set_has_group_chat();
  } else {
    clear_has_group_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.LeaveGroupChatResponse.group_chat)
}

// -------------------------------------------------------------------

// SendGroupMessageRequest

// required int64 group_id = 1;
inline bool SendGroupMessageRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendGroupMessageRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendGroupMessageRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendGroupMessageRequest::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 SendGroupMessageRequest::group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendGroupMessageRequest.group_id)
  return group_id_;
}
inline void SendGroupMessageRequest::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendGroupMessageRequest.group_id)
}

// required .weizhu.im.InstantMessage msg = 2;
inline bool SendGroupMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendGroupMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendGroupMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendGroupMessageRequest::clear_msg() {
  if (msg_ != NULL) msg_->::weizhu::im::InstantMessage::Clear();
  clear_has_msg();
}
inline const ::weizhu::im::InstantMessage& SendGroupMessageRequest::msg() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendGroupMessageRequest.msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_ != NULL ? *msg_ : *default_instance().msg_;
#else
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
#endif
}
inline ::weizhu::im::InstantMessage* SendGroupMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::weizhu::im::InstantMessage;
  // @@protoc_insertion_point(field_mutable:weizhu.im.SendGroupMessageRequest.msg)
  return msg_;
}
inline ::weizhu::im::InstantMessage* SendGroupMessageRequest::release_msg() {
  clear_has_msg();
  ::weizhu::im::InstantMessage* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void SendGroupMessageRequest::set_allocated_msg(::weizhu::im::InstantMessage* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SendGroupMessageRequest.msg)
}

// -------------------------------------------------------------------

// SendGroupMessageResponse

// optional .weizhu.im.SendGroupMessageResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool SendGroupMessageResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendGroupMessageResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendGroupMessageResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendGroupMessageResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::im::SendGroupMessageResponse_Result SendGroupMessageResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendGroupMessageResponse.result)
  return static_cast< ::weizhu::im::SendGroupMessageResponse_Result >(result_);
}
inline void SendGroupMessageResponse::set_result(::weizhu::im::SendGroupMessageResponse_Result value) {
  assert(::weizhu::im::SendGroupMessageResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendGroupMessageResponse.result)
}

// optional string fail_text = 2;
inline bool SendGroupMessageResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendGroupMessageResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendGroupMessageResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendGroupMessageResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& SendGroupMessageResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendGroupMessageResponse.fail_text)
  return *fail_text_;
}
inline void SendGroupMessageResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.im.SendGroupMessageResponse.fail_text)
}
inline void SendGroupMessageResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.im.SendGroupMessageResponse.fail_text)
}
inline void SendGroupMessageResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.im.SendGroupMessageResponse.fail_text)
}
inline ::std::string* SendGroupMessageResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.im.SendGroupMessageResponse.fail_text)
  return fail_text_;
}
inline ::std::string* SendGroupMessageResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendGroupMessageResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.im.SendGroupMessageResponse.fail_text)
}

// optional int64 msg_seq = 3;
inline bool SendGroupMessageResponse::has_msg_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendGroupMessageResponse::set_has_msg_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendGroupMessageResponse::clear_has_msg_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendGroupMessageResponse::clear_msg_seq() {
  msg_seq_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq();
}
inline ::google::protobuf::int64 SendGroupMessageResponse::msg_seq() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendGroupMessageResponse.msg_seq)
  return msg_seq_;
}
inline void SendGroupMessageResponse::set_msg_seq(::google::protobuf::int64 value) {
  set_has_msg_seq();
  msg_seq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendGroupMessageResponse.msg_seq)
}

// optional int32 msg_time = 4;
inline bool SendGroupMessageResponse::has_msg_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendGroupMessageResponse::set_has_msg_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendGroupMessageResponse::clear_has_msg_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendGroupMessageResponse::clear_msg_time() {
  msg_time_ = 0;
  clear_has_msg_time();
}
inline ::google::protobuf::int32 SendGroupMessageResponse::msg_time() const {
  // @@protoc_insertion_point(field_get:weizhu.im.SendGroupMessageResponse.msg_time)
  return msg_time_;
}
inline void SendGroupMessageResponse::set_msg_time(::google::protobuf::int32 value) {
  set_has_msg_time();
  msg_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.SendGroupMessageResponse.msg_time)
}

// -------------------------------------------------------------------

// GetGroupChatListRequest

// optional int64 last_group_id = 1;
inline bool GetGroupChatListRequest::has_last_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroupChatListRequest::set_has_last_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroupChatListRequest::clear_has_last_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroupChatListRequest::clear_last_group_id() {
  last_group_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_group_id();
}
inline ::google::protobuf::int64 GetGroupChatListRequest::last_group_id() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupChatListRequest.last_group_id)
  return last_group_id_;
}
inline void GetGroupChatListRequest::set_last_group_id(::google::protobuf::int64 value) {
  set_has_last_group_id();
  last_group_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupChatListRequest.last_group_id)
}

// optional int32 last_msg_time = 2;
inline bool GetGroupChatListRequest::has_last_msg_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGroupChatListRequest::set_has_last_msg_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGroupChatListRequest::clear_has_last_msg_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGroupChatListRequest::clear_last_msg_time() {
  last_msg_time_ = 0;
  clear_has_last_msg_time();
}
inline ::google::protobuf::int32 GetGroupChatListRequest::last_msg_time() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupChatListRequest.last_msg_time)
  return last_msg_time_;
}
inline void GetGroupChatListRequest::set_last_msg_time(::google::protobuf::int32 value) {
  set_has_last_msg_time();
  last_msg_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupChatListRequest.last_msg_time)
}

// required int32 chat_size = 3;
inline bool GetGroupChatListRequest::has_chat_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetGroupChatListRequest::set_has_chat_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetGroupChatListRequest::clear_has_chat_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetGroupChatListRequest::clear_chat_size() {
  chat_size_ = 0;
  clear_has_chat_size();
}
inline ::google::protobuf::int32 GetGroupChatListRequest::chat_size() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupChatListRequest.chat_size)
  return chat_size_;
}
inline void GetGroupChatListRequest::set_chat_size(::google::protobuf::int32 value) {
  set_has_chat_size();
  chat_size_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupChatListRequest.chat_size)
}

// -------------------------------------------------------------------

// GetGroupChatListResponse

// repeated .weizhu.im.GroupChat chat = 1;
inline int GetGroupChatListResponse::chat_size() const {
  return chat_.size();
}
inline void GetGroupChatListResponse::clear_chat() {
  chat_.Clear();
}
inline const ::weizhu::im::GroupChat& GetGroupChatListResponse::chat(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupChatListResponse.chat)
  return chat_.Get(index);
}
inline ::weizhu::im::GroupChat* GetGroupChatListResponse::mutable_chat(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.im.GetGroupChatListResponse.chat)
  return chat_.Mutable(index);
}
inline ::weizhu::im::GroupChat* GetGroupChatListResponse::add_chat() {
  // @@protoc_insertion_point(field_add:weizhu.im.GetGroupChatListResponse.chat)
  return chat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >&
GetGroupChatListResponse::chat() const {
  // @@protoc_insertion_point(field_list:weizhu.im.GetGroupChatListResponse.chat)
  return chat_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::im::GroupChat >*
GetGroupChatListResponse::mutable_chat() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.im.GetGroupChatListResponse.chat)
  return &chat_;
}

// required bool has_more = 2;
inline bool GetGroupChatListResponse::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGroupChatListResponse::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGroupChatListResponse::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGroupChatListResponse::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool GetGroupChatListResponse::has_more() const {
  // @@protoc_insertion_point(field_get:weizhu.im.GetGroupChatListResponse.has_more)
  return has_more_;
}
inline void GetGroupChatListResponse::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:weizhu.im.GetGroupChatListResponse.has_more)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace im
}  // namespace weizhu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_im_2eproto__INCLUDED
