// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login.proto

#ifndef PROTOBUF_login_2eproto__INCLUDED
#define PROTOBUF_login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "weizhu.pb.h"
#include "user.pb.h"
// @@protoc_insertion_point(includes)

namespace weizhu {
namespace login {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_login_2eproto();
void protobuf_AssignDesc_login_2eproto();
void protobuf_ShutdownFile_login_2eproto();

class SmsCode;
class SendSmsCodeRequest;
class SendSmsCodeResponse;
class LoginBySmsCodeRequest;
class LoginBySmsCodeResponse;
class LoginAutoRequest;
class LoginAutoResponse;
class GetLoginSmsCodeRequest;
class GetLoginSmsCodeResponse;
class SendRegisterSmsCodeRequest;
class SendRegisterSmsCodeResponse;
class RegisterBySmsCodeRequest;
class RegisterBySmsCodeResponse;

enum SendSmsCodeResponse_Result {
  SendSmsCodeResponse_Result_SUCC = 0,
  SendSmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID = 1,
  SendSmsCodeResponse_Result_FAIL_USER_NOT_EXSIT = 2,
  SendSmsCodeResponse_Result_FAIL_SEND_FAIL = 3,
  SendSmsCodeResponse_Result_FAIL_SEND_LIMIT_EXCEEDED = 4,
  SendSmsCodeResponse_Result_FAIL_UNKNOWN = 99
};
bool SendSmsCodeResponse_Result_IsValid(int value);
const SendSmsCodeResponse_Result SendSmsCodeResponse_Result_Result_MIN = SendSmsCodeResponse_Result_SUCC;
const SendSmsCodeResponse_Result SendSmsCodeResponse_Result_Result_MAX = SendSmsCodeResponse_Result_FAIL_UNKNOWN;
const int SendSmsCodeResponse_Result_Result_ARRAYSIZE = SendSmsCodeResponse_Result_Result_MAX + 1;

enum LoginBySmsCodeResponse_Result {
  LoginBySmsCodeResponse_Result_SUCC = 0,
  LoginBySmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID = 1,
  LoginBySmsCodeResponse_Result_FAIL_SMS_CODE_INVALID = 2,
  LoginBySmsCodeResponse_Result_FAIL_SMS_CODE_EXPIRED = 3,
  LoginBySmsCodeResponse_Result_FAIL_UNKNOWN = 99
};
bool LoginBySmsCodeResponse_Result_IsValid(int value);
const LoginBySmsCodeResponse_Result LoginBySmsCodeResponse_Result_Result_MIN = LoginBySmsCodeResponse_Result_SUCC;
const LoginBySmsCodeResponse_Result LoginBySmsCodeResponse_Result_Result_MAX = LoginBySmsCodeResponse_Result_FAIL_UNKNOWN;
const int LoginBySmsCodeResponse_Result_Result_ARRAYSIZE = LoginBySmsCodeResponse_Result_Result_MAX + 1;

enum LoginAutoResponse_Result {
  LoginAutoResponse_Result_SUCC = 0,
  LoginAutoResponse_Result_FAIL_AUTO_LOGIN_DISABLE = 1,
  LoginAutoResponse_Result_FAIL_MOBILE_NO_INVALID = 2,
  LoginAutoResponse_Result_FAIL_USER_NOT_FOUND = 3,
  LoginAutoResponse_Result_FAIL_USER_DISABLE = 4,
  LoginAutoResponse_Result_FAIL_UNKNOWN = 99
};
bool LoginAutoResponse_Result_IsValid(int value);
const LoginAutoResponse_Result LoginAutoResponse_Result_Result_MIN = LoginAutoResponse_Result_SUCC;
const LoginAutoResponse_Result LoginAutoResponse_Result_Result_MAX = LoginAutoResponse_Result_FAIL_UNKNOWN;
const int LoginAutoResponse_Result_Result_ARRAYSIZE = LoginAutoResponse_Result_Result_MAX + 1;

enum SendRegisterSmsCodeResponse_Result {
  SendRegisterSmsCodeResponse_Result_SUCC = 0,
  SendRegisterSmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID = 1,
  SendRegisterSmsCodeResponse_Result_FAIL_SEND_FAIL = 2,
  SendRegisterSmsCodeResponse_Result_FAIL_SEND_LIMIT_EXCEEDED = 3,
  SendRegisterSmsCodeResponse_Result_FAIL_UNKNOWN = 99
};
bool SendRegisterSmsCodeResponse_Result_IsValid(int value);
const SendRegisterSmsCodeResponse_Result SendRegisterSmsCodeResponse_Result_Result_MIN = SendRegisterSmsCodeResponse_Result_SUCC;
const SendRegisterSmsCodeResponse_Result SendRegisterSmsCodeResponse_Result_Result_MAX = SendRegisterSmsCodeResponse_Result_FAIL_UNKNOWN;
const int SendRegisterSmsCodeResponse_Result_Result_ARRAYSIZE = SendRegisterSmsCodeResponse_Result_Result_MAX + 1;

enum RegisterBySmsCodeResponse_Result {
  RegisterBySmsCodeResponse_Result_SUCC = 0,
  RegisterBySmsCodeResponse_Result_FAIL_NAME_INVALID = 1,
  RegisterBySmsCodeResponse_Result_FAIL_EMAIL_INVALID = 2,
  RegisterBySmsCodeResponse_Result_FAIL_TEAM_INVALID = 3,
  RegisterBySmsCodeResponse_Result_FAIL_POSITION_INVALID = 4,
  RegisterBySmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID = 5,
  RegisterBySmsCodeResponse_Result_FAIL_SMS_CODE_INVALID = 6,
  RegisterBySmsCodeResponse_Result_FAIL_SMS_CODE_EXPIRED = 7,
  RegisterBySmsCodeResponse_Result_FAIL_LEVEL_INVALID = 8,
  RegisterBySmsCodeResponse_Result_FAIL_UNKNOWN = 99
};
bool RegisterBySmsCodeResponse_Result_IsValid(int value);
const RegisterBySmsCodeResponse_Result RegisterBySmsCodeResponse_Result_Result_MIN = RegisterBySmsCodeResponse_Result_SUCC;
const RegisterBySmsCodeResponse_Result RegisterBySmsCodeResponse_Result_Result_MAX = RegisterBySmsCodeResponse_Result_FAIL_UNKNOWN;
const int RegisterBySmsCodeResponse_Result_Result_ARRAYSIZE = RegisterBySmsCodeResponse_Result_Result_MAX + 1;

// ===================================================================

class SmsCode : public ::google::protobuf::MessageLite {
 public:
  SmsCode();
  virtual ~SmsCode();

  SmsCode(const SmsCode& from);

  inline SmsCode& operator=(const SmsCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SmsCode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SmsCode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SmsCode* other);

  // implements Message ----------------------------------------------

  SmsCode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SmsCode& from);
  void MergeFrom(const SmsCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mobile_no = 1;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 1;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // required int32 sms_code = 2;
  inline bool has_sms_code() const;
  inline void clear_sms_code();
  static const int kSmsCodeFieldNumber = 2;
  inline ::google::protobuf::int32 sms_code() const;
  inline void set_sms_code(::google::protobuf::int32 value);

  // required int32 create_time = 3;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::int32 create_time() const;
  inline void set_create_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.SmsCode)
 private:
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();
  inline void set_has_sms_code();
  inline void clear_has_sms_code();
  inline void set_has_create_time();
  inline void clear_has_create_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mobile_no_;
  ::google::protobuf::int32 sms_code_;
  ::google::protobuf::int32 create_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static SmsCode* default_instance_;
};
// -------------------------------------------------------------------

class SendSmsCodeRequest : public ::google::protobuf::MessageLite {
 public:
  SendSmsCodeRequest();
  virtual ~SendSmsCodeRequest();

  SendSmsCodeRequest(const SendSmsCodeRequest& from);

  inline SendSmsCodeRequest& operator=(const SendSmsCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendSmsCodeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendSmsCodeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendSmsCodeRequest* other);

  // implements Message ----------------------------------------------

  SendSmsCodeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendSmsCodeRequest& from);
  void MergeFrom(const SendSmsCodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string company_key = 1;
  inline bool has_company_key() const;
  inline void clear_company_key();
  static const int kCompanyKeyFieldNumber = 1;
  inline const ::std::string& company_key() const;
  inline void set_company_key(const ::std::string& value);
  inline void set_company_key(const char* value);
  inline void set_company_key(const char* value, size_t size);
  inline ::std::string* mutable_company_key();
  inline ::std::string* release_company_key();
  inline void set_allocated_company_key(::std::string* company_key);

  // required string mobile_no = 2;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 2;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // @@protoc_insertion_point(class_scope:weizhu.login.SendSmsCodeRequest)
 private:
  inline void set_has_company_key();
  inline void clear_has_company_key();
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* company_key_;
  ::std::string* mobile_no_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static SendSmsCodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendSmsCodeResponse : public ::google::protobuf::MessageLite {
 public:
  SendSmsCodeResponse();
  virtual ~SendSmsCodeResponse();

  SendSmsCodeResponse(const SendSmsCodeResponse& from);

  inline SendSmsCodeResponse& operator=(const SendSmsCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendSmsCodeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendSmsCodeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendSmsCodeResponse* other);

  // implements Message ----------------------------------------------

  SendSmsCodeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendSmsCodeResponse& from);
  void MergeFrom(const SendSmsCodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SendSmsCodeResponse_Result Result;
  static const Result SUCC = SendSmsCodeResponse_Result_SUCC;
  static const Result FAIL_MOBILE_NO_INVALID = SendSmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID;
  static const Result FAIL_USER_NOT_EXSIT = SendSmsCodeResponse_Result_FAIL_USER_NOT_EXSIT;
  static const Result FAIL_SEND_FAIL = SendSmsCodeResponse_Result_FAIL_SEND_FAIL;
  static const Result FAIL_SEND_LIMIT_EXCEEDED = SendSmsCodeResponse_Result_FAIL_SEND_LIMIT_EXCEEDED;
  static const Result FAIL_UNKNOWN = SendSmsCodeResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return SendSmsCodeResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    SendSmsCodeResponse_Result_Result_MIN;
  static const Result Result_MAX =
    SendSmsCodeResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    SendSmsCodeResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.login.SendSmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::login::SendSmsCodeResponse_Result result() const;
  inline void set_result(::weizhu::login::SendSmsCodeResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional int64 company_id = 3;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 3;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.SendSmsCodeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_company_id();
  inline void clear_has_company_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::google::protobuf::int64 company_id_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static SendSmsCodeResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginBySmsCodeRequest : public ::google::protobuf::MessageLite {
 public:
  LoginBySmsCodeRequest();
  virtual ~LoginBySmsCodeRequest();

  LoginBySmsCodeRequest(const LoginBySmsCodeRequest& from);

  inline LoginBySmsCodeRequest& operator=(const LoginBySmsCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginBySmsCodeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginBySmsCodeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginBySmsCodeRequest* other);

  // implements Message ----------------------------------------------

  LoginBySmsCodeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginBySmsCodeRequest& from);
  void MergeFrom(const LoginBySmsCodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string company_key = 1;
  inline bool has_company_key() const;
  inline void clear_company_key();
  static const int kCompanyKeyFieldNumber = 1;
  inline const ::std::string& company_key() const;
  inline void set_company_key(const ::std::string& value);
  inline void set_company_key(const char* value);
  inline void set_company_key(const char* value, size_t size);
  inline ::std::string* mutable_company_key();
  inline ::std::string* release_company_key();
  inline void set_allocated_company_key(::std::string* company_key);

  // required string mobile_no = 2;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 2;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // required int32 sms_code = 3;
  inline bool has_sms_code() const;
  inline void clear_sms_code();
  static const int kSmsCodeFieldNumber = 3;
  inline ::google::protobuf::int32 sms_code() const;
  inline void set_sms_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.LoginBySmsCodeRequest)
 private:
  inline void set_has_company_key();
  inline void clear_has_company_key();
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();
  inline void set_has_sms_code();
  inline void clear_has_sms_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* company_key_;
  ::std::string* mobile_no_;
  ::google::protobuf::int32 sms_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginBySmsCodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginBySmsCodeResponse : public ::google::protobuf::MessageLite {
 public:
  LoginBySmsCodeResponse();
  virtual ~LoginBySmsCodeResponse();

  LoginBySmsCodeResponse(const LoginBySmsCodeResponse& from);

  inline LoginBySmsCodeResponse& operator=(const LoginBySmsCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginBySmsCodeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginBySmsCodeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginBySmsCodeResponse* other);

  // implements Message ----------------------------------------------

  LoginBySmsCodeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginBySmsCodeResponse& from);
  void MergeFrom(const LoginBySmsCodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoginBySmsCodeResponse_Result Result;
  static const Result SUCC = LoginBySmsCodeResponse_Result_SUCC;
  static const Result FAIL_MOBILE_NO_INVALID = LoginBySmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID;
  static const Result FAIL_SMS_CODE_INVALID = LoginBySmsCodeResponse_Result_FAIL_SMS_CODE_INVALID;
  static const Result FAIL_SMS_CODE_EXPIRED = LoginBySmsCodeResponse_Result_FAIL_SMS_CODE_EXPIRED;
  static const Result FAIL_UNKNOWN = LoginBySmsCodeResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return LoginBySmsCodeResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    LoginBySmsCodeResponse_Result_Result_MIN;
  static const Result Result_MAX =
    LoginBySmsCodeResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    LoginBySmsCodeResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.login.LoginBySmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::login::LoginBySmsCodeResponse_Result result() const;
  inline void set_result(::weizhu::login::LoginBySmsCodeResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional bytes session_key = 3;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const void* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional .weizhu.user.User user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::weizhu::user::User& user() const;
  inline ::weizhu::user::User* mutable_user();
  inline ::weizhu::user::User* release_user();
  inline void set_allocated_user(::weizhu::user::User* user);

  // repeated .weizhu.user.Team ref_team = 5;
  inline int ref_team_size() const;
  inline void clear_ref_team();
  static const int kRefTeamFieldNumber = 5;
  inline const ::weizhu::user::Team& ref_team(int index) const;
  inline ::weizhu::user::Team* mutable_ref_team(int index);
  inline ::weizhu::user::Team* add_ref_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
      ref_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
      mutable_ref_team();

  // repeated .weizhu.user.Position ref_position = 6;
  inline int ref_position_size() const;
  inline void clear_ref_position();
  static const int kRefPositionFieldNumber = 6;
  inline const ::weizhu::user::Position& ref_position(int index) const;
  inline ::weizhu::user::Position* mutable_ref_position(int index);
  inline ::weizhu::user::Position* add_ref_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      ref_position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_ref_position();

  // repeated .weizhu.user.Level ref_level = 7;
  inline int ref_level_size() const;
  inline void clear_ref_level();
  static const int kRefLevelFieldNumber = 7;
  inline const ::weizhu::user::Level& ref_level(int index) const;
  inline ::weizhu::user::Level* mutable_ref_level(int index);
  inline ::weizhu::user::Level* add_ref_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      ref_level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_ref_level();

  // optional int64 company_id = 8;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 8;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.LoginBySmsCodeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_company_id();
  inline void clear_has_company_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::std::string* session_key_;
  ::weizhu::user::User* user_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team > ref_team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > ref_position_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > ref_level_;
  ::google::protobuf::int64 company_id_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginBySmsCodeResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginAutoRequest : public ::google::protobuf::MessageLite {
 public:
  LoginAutoRequest();
  virtual ~LoginAutoRequest();

  LoginAutoRequest(const LoginAutoRequest& from);

  inline LoginAutoRequest& operator=(const LoginAutoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginAutoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginAutoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginAutoRequest* other);

  // implements Message ----------------------------------------------

  LoginAutoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginAutoRequest& from);
  void MergeFrom(const LoginAutoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string company_key = 1;
  inline bool has_company_key() const;
  inline void clear_company_key();
  static const int kCompanyKeyFieldNumber = 1;
  inline const ::std::string& company_key() const;
  inline void set_company_key(const ::std::string& value);
  inline void set_company_key(const char* value);
  inline void set_company_key(const char* value, size_t size);
  inline ::std::string* mutable_company_key();
  inline ::std::string* release_company_key();
  inline void set_allocated_company_key(::std::string* company_key);

  // required string mobile_no = 2;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 2;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // optional int64 company_id = 3;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 3;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // optional int64 user_id = 4;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.LoginAutoRequest)
 private:
  inline void set_has_company_key();
  inline void clear_has_company_key();
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* company_key_;
  ::std::string* mobile_no_;
  ::google::protobuf::int64 company_id_;
  ::google::protobuf::int64 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginAutoRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginAutoResponse : public ::google::protobuf::MessageLite {
 public:
  LoginAutoResponse();
  virtual ~LoginAutoResponse();

  LoginAutoResponse(const LoginAutoResponse& from);

  inline LoginAutoResponse& operator=(const LoginAutoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LoginAutoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginAutoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginAutoResponse* other);

  // implements Message ----------------------------------------------

  LoginAutoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginAutoResponse& from);
  void MergeFrom(const LoginAutoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoginAutoResponse_Result Result;
  static const Result SUCC = LoginAutoResponse_Result_SUCC;
  static const Result FAIL_AUTO_LOGIN_DISABLE = LoginAutoResponse_Result_FAIL_AUTO_LOGIN_DISABLE;
  static const Result FAIL_MOBILE_NO_INVALID = LoginAutoResponse_Result_FAIL_MOBILE_NO_INVALID;
  static const Result FAIL_USER_NOT_FOUND = LoginAutoResponse_Result_FAIL_USER_NOT_FOUND;
  static const Result FAIL_USER_DISABLE = LoginAutoResponse_Result_FAIL_USER_DISABLE;
  static const Result FAIL_UNKNOWN = LoginAutoResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return LoginAutoResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    LoginAutoResponse_Result_Result_MIN;
  static const Result Result_MAX =
    LoginAutoResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    LoginAutoResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.login.LoginAutoResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::login::LoginAutoResponse_Result result() const;
  inline void set_result(::weizhu::login::LoginAutoResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional bytes session_key = 3;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const void* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional .weizhu.user.User user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::weizhu::user::User& user() const;
  inline ::weizhu::user::User* mutable_user();
  inline ::weizhu::user::User* release_user();
  inline void set_allocated_user(::weizhu::user::User* user);

  // repeated .weizhu.user.Team ref_team = 5;
  inline int ref_team_size() const;
  inline void clear_ref_team();
  static const int kRefTeamFieldNumber = 5;
  inline const ::weizhu::user::Team& ref_team(int index) const;
  inline ::weizhu::user::Team* mutable_ref_team(int index);
  inline ::weizhu::user::Team* add_ref_team();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
      ref_team() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
      mutable_ref_team();

  // repeated .weizhu.user.Position ref_position = 6;
  inline int ref_position_size() const;
  inline void clear_ref_position();
  static const int kRefPositionFieldNumber = 6;
  inline const ::weizhu::user::Position& ref_position(int index) const;
  inline ::weizhu::user::Position* mutable_ref_position(int index);
  inline ::weizhu::user::Position* add_ref_position();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
      ref_position() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
      mutable_ref_position();

  // repeated .weizhu.user.Level ref_level = 7;
  inline int ref_level_size() const;
  inline void clear_ref_level();
  static const int kRefLevelFieldNumber = 7;
  inline const ::weizhu::user::Level& ref_level(int index) const;
  inline ::weizhu::user::Level* mutable_ref_level(int index);
  inline ::weizhu::user::Level* add_ref_level();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
      ref_level() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
      mutable_ref_level();

  // optional int64 company_id = 8;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 8;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.LoginAutoResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_company_id();
  inline void clear_has_company_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::std::string* session_key_;
  ::weizhu::user::User* user_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team > ref_team_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position > ref_position_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level > ref_level_;
  ::google::protobuf::int64 company_id_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginAutoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetLoginSmsCodeRequest : public ::google::protobuf::MessageLite {
 public:
  GetLoginSmsCodeRequest();
  virtual ~GetLoginSmsCodeRequest();

  GetLoginSmsCodeRequest(const GetLoginSmsCodeRequest& from);

  inline GetLoginSmsCodeRequest& operator=(const GetLoginSmsCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetLoginSmsCodeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetLoginSmsCodeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetLoginSmsCodeRequest* other);

  // implements Message ----------------------------------------------

  GetLoginSmsCodeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetLoginSmsCodeRequest& from);
  void MergeFrom(const GetLoginSmsCodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.GetLoginSmsCodeRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static GetLoginSmsCodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetLoginSmsCodeResponse : public ::google::protobuf::MessageLite {
 public:
  GetLoginSmsCodeResponse();
  virtual ~GetLoginSmsCodeResponse();

  GetLoginSmsCodeResponse(const GetLoginSmsCodeResponse& from);

  inline GetLoginSmsCodeResponse& operator=(const GetLoginSmsCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetLoginSmsCodeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetLoginSmsCodeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetLoginSmsCodeResponse* other);

  // implements Message ----------------------------------------------

  GetLoginSmsCodeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetLoginSmsCodeResponse& from);
  void MergeFrom(const GetLoginSmsCodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.login.SmsCode sms_code = 1;
  inline int sms_code_size() const;
  inline void clear_sms_code();
  static const int kSmsCodeFieldNumber = 1;
  inline const ::weizhu::login::SmsCode& sms_code(int index) const;
  inline ::weizhu::login::SmsCode* mutable_sms_code(int index);
  inline ::weizhu::login::SmsCode* add_sms_code();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::login::SmsCode >&
      sms_code() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::login::SmsCode >*
      mutable_sms_code();

  // @@protoc_insertion_point(class_scope:weizhu.login.GetLoginSmsCodeResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::login::SmsCode > sms_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static GetLoginSmsCodeResponse* default_instance_;
};
// -------------------------------------------------------------------

class SendRegisterSmsCodeRequest : public ::google::protobuf::MessageLite {
 public:
  SendRegisterSmsCodeRequest();
  virtual ~SendRegisterSmsCodeRequest();

  SendRegisterSmsCodeRequest(const SendRegisterSmsCodeRequest& from);

  inline SendRegisterSmsCodeRequest& operator=(const SendRegisterSmsCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendRegisterSmsCodeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendRegisterSmsCodeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendRegisterSmsCodeRequest* other);

  // implements Message ----------------------------------------------

  SendRegisterSmsCodeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendRegisterSmsCodeRequest& from);
  void MergeFrom(const SendRegisterSmsCodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string company_key = 1;
  inline bool has_company_key() const;
  inline void clear_company_key();
  static const int kCompanyKeyFieldNumber = 1;
  inline const ::std::string& company_key() const;
  inline void set_company_key(const ::std::string& value);
  inline void set_company_key(const char* value);
  inline void set_company_key(const char* value, size_t size);
  inline ::std::string* mutable_company_key();
  inline ::std::string* release_company_key();
  inline void set_allocated_company_key(::std::string* company_key);

  // required string mobile_no = 2;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 2;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // @@protoc_insertion_point(class_scope:weizhu.login.SendRegisterSmsCodeRequest)
 private:
  inline void set_has_company_key();
  inline void clear_has_company_key();
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* company_key_;
  ::std::string* mobile_no_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static SendRegisterSmsCodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendRegisterSmsCodeResponse : public ::google::protobuf::MessageLite {
 public:
  SendRegisterSmsCodeResponse();
  virtual ~SendRegisterSmsCodeResponse();

  SendRegisterSmsCodeResponse(const SendRegisterSmsCodeResponse& from);

  inline SendRegisterSmsCodeResponse& operator=(const SendRegisterSmsCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SendRegisterSmsCodeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendRegisterSmsCodeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendRegisterSmsCodeResponse* other);

  // implements Message ----------------------------------------------

  SendRegisterSmsCodeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendRegisterSmsCodeResponse& from);
  void MergeFrom(const SendRegisterSmsCodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SendRegisterSmsCodeResponse_Result Result;
  static const Result SUCC = SendRegisterSmsCodeResponse_Result_SUCC;
  static const Result FAIL_MOBILE_NO_INVALID = SendRegisterSmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID;
  static const Result FAIL_SEND_FAIL = SendRegisterSmsCodeResponse_Result_FAIL_SEND_FAIL;
  static const Result FAIL_SEND_LIMIT_EXCEEDED = SendRegisterSmsCodeResponse_Result_FAIL_SEND_LIMIT_EXCEEDED;
  static const Result FAIL_UNKNOWN = SendRegisterSmsCodeResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return SendRegisterSmsCodeResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    SendRegisterSmsCodeResponse_Result_Result_MIN;
  static const Result Result_MAX =
    SendRegisterSmsCodeResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    SendRegisterSmsCodeResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.login.SendRegisterSmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::login::SendRegisterSmsCodeResponse_Result result() const;
  inline void set_result(::weizhu::login::SendRegisterSmsCodeResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional int64 company_id = 3;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 3;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.SendRegisterSmsCodeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_company_id();
  inline void clear_has_company_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::google::protobuf::int64 company_id_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static SendRegisterSmsCodeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterBySmsCodeRequest : public ::google::protobuf::MessageLite {
 public:
  RegisterBySmsCodeRequest();
  virtual ~RegisterBySmsCodeRequest();

  RegisterBySmsCodeRequest(const RegisterBySmsCodeRequest& from);

  inline RegisterBySmsCodeRequest& operator=(const RegisterBySmsCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegisterBySmsCodeRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterBySmsCodeRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterBySmsCodeRequest* other);

  // implements Message ----------------------------------------------

  RegisterBySmsCodeRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterBySmsCodeRequest& from);
  void MergeFrom(const RegisterBySmsCodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string company_key = 1;
  inline bool has_company_key() const;
  inline void clear_company_key();
  static const int kCompanyKeyFieldNumber = 1;
  inline const ::std::string& company_key() const;
  inline void set_company_key(const ::std::string& value);
  inline void set_company_key(const char* value);
  inline void set_company_key(const char* value, size_t size);
  inline ::std::string* mutable_company_key();
  inline ::std::string* release_company_key();
  inline void set_allocated_company_key(::std::string* company_key);

  // required string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional .weizhu.user.UserBase.Gender gender = 3;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 3;
  inline ::weizhu::user::UserBase_Gender gender() const;
  inline void set_gender(::weizhu::user::UserBase_Gender value);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // repeated string team = 5;
  inline int team_size() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 5;
  inline const ::std::string& team(int index) const;
  inline ::std::string* mutable_team(int index);
  inline void set_team(int index, const ::std::string& value);
  inline void set_team(int index, const char* value);
  inline void set_team(int index, const char* value, size_t size);
  inline ::std::string* add_team();
  inline void add_team(const ::std::string& value);
  inline void add_team(const char* value);
  inline void add_team(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& team() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_team();

  // optional string position = 6;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 6;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // required string mobile_no = 7;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 7;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // required int32 sms_code = 8;
  inline bool has_sms_code() const;
  inline void clear_sms_code();
  static const int kSmsCodeFieldNumber = 8;
  inline ::google::protobuf::int32 sms_code() const;
  inline void set_sms_code(::google::protobuf::int32 value);

  // repeated string exts_name = 9;
  inline int exts_name_size() const;
  inline void clear_exts_name();
  static const int kExtsNameFieldNumber = 9;
  inline const ::std::string& exts_name(int index) const;
  inline ::std::string* mutable_exts_name(int index);
  inline void set_exts_name(int index, const ::std::string& value);
  inline void set_exts_name(int index, const char* value);
  inline void set_exts_name(int index, const char* value, size_t size);
  inline ::std::string* add_exts_name();
  inline void add_exts_name(const ::std::string& value);
  inline void add_exts_name(const char* value);
  inline void add_exts_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exts_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exts_name();

  // repeated string exts_value = 10;
  inline int exts_value_size() const;
  inline void clear_exts_value();
  static const int kExtsValueFieldNumber = 10;
  inline const ::std::string& exts_value(int index) const;
  inline ::std::string* mutable_exts_value(int index);
  inline void set_exts_value(int index, const ::std::string& value);
  inline void set_exts_value(int index, const char* value);
  inline void set_exts_value(int index, const char* value, size_t size);
  inline ::std::string* add_exts_value();
  inline void add_exts_value(const ::std::string& value);
  inline void add_exts_value(const char* value);
  inline void add_exts_value(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exts_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exts_value();

  // optional string level = 11;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 11;
  inline const ::std::string& level() const;
  inline void set_level(const ::std::string& value);
  inline void set_level(const char* value);
  inline void set_level(const char* value, size_t size);
  inline ::std::string* mutable_level();
  inline ::std::string* release_level();
  inline void set_allocated_level(::std::string* level);

  // optional string phone_no = 12;
  inline bool has_phone_no() const;
  inline void clear_phone_no();
  static const int kPhoneNoFieldNumber = 12;
  inline const ::std::string& phone_no() const;
  inline void set_phone_no(const ::std::string& value);
  inline void set_phone_no(const char* value);
  inline void set_phone_no(const char* value, size_t size);
  inline ::std::string* mutable_phone_no();
  inline ::std::string* release_phone_no();
  inline void set_allocated_phone_no(::std::string* phone_no);

  // @@protoc_insertion_point(class_scope:weizhu.login.RegisterBySmsCodeRequest)
 private:
  inline void set_has_company_key();
  inline void clear_has_company_key();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();
  inline void set_has_sms_code();
  inline void clear_has_sms_code();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_phone_no();
  inline void clear_has_phone_no();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* company_key_;
  ::std::string* user_name_;
  ::std::string* email_;
  ::google::protobuf::RepeatedPtrField< ::std::string> team_;
  int gender_;
  ::google::protobuf::int32 sms_code_;
  ::std::string* position_;
  ::std::string* mobile_no_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exts_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exts_value_;
  ::std::string* level_;
  ::std::string* phone_no_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static RegisterBySmsCodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterBySmsCodeResponse : public ::google::protobuf::MessageLite {
 public:
  RegisterBySmsCodeResponse();
  virtual ~RegisterBySmsCodeResponse();

  RegisterBySmsCodeResponse(const RegisterBySmsCodeResponse& from);

  inline RegisterBySmsCodeResponse& operator=(const RegisterBySmsCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegisterBySmsCodeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterBySmsCodeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterBySmsCodeResponse* other);

  // implements Message ----------------------------------------------

  RegisterBySmsCodeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterBySmsCodeResponse& from);
  void MergeFrom(const RegisterBySmsCodeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RegisterBySmsCodeResponse_Result Result;
  static const Result SUCC = RegisterBySmsCodeResponse_Result_SUCC;
  static const Result FAIL_NAME_INVALID = RegisterBySmsCodeResponse_Result_FAIL_NAME_INVALID;
  static const Result FAIL_EMAIL_INVALID = RegisterBySmsCodeResponse_Result_FAIL_EMAIL_INVALID;
  static const Result FAIL_TEAM_INVALID = RegisterBySmsCodeResponse_Result_FAIL_TEAM_INVALID;
  static const Result FAIL_POSITION_INVALID = RegisterBySmsCodeResponse_Result_FAIL_POSITION_INVALID;
  static const Result FAIL_MOBILE_NO_INVALID = RegisterBySmsCodeResponse_Result_FAIL_MOBILE_NO_INVALID;
  static const Result FAIL_SMS_CODE_INVALID = RegisterBySmsCodeResponse_Result_FAIL_SMS_CODE_INVALID;
  static const Result FAIL_SMS_CODE_EXPIRED = RegisterBySmsCodeResponse_Result_FAIL_SMS_CODE_EXPIRED;
  static const Result FAIL_LEVEL_INVALID = RegisterBySmsCodeResponse_Result_FAIL_LEVEL_INVALID;
  static const Result FAIL_UNKNOWN = RegisterBySmsCodeResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return RegisterBySmsCodeResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    RegisterBySmsCodeResponse_Result_Result_MIN;
  static const Result Result_MAX =
    RegisterBySmsCodeResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    RegisterBySmsCodeResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.login.RegisterBySmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::login::RegisterBySmsCodeResponse_Result result() const;
  inline void set_result(::weizhu::login::RegisterBySmsCodeResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional int64 company_id = 3;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 3;
  inline ::google::protobuf::int64 company_id() const;
  inline void set_company_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:weizhu.login.RegisterBySmsCodeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_company_id();
  inline void clear_has_company_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  ::google::protobuf::int64 company_id_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_login_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_login_2eproto();
  #endif
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static RegisterBySmsCodeResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// SmsCode

// required string mobile_no = 1;
inline bool SmsCode::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmsCode::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmsCode::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmsCode::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& SmsCode::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SmsCode.mobile_no)
  return *mobile_no_;
}
inline void SmsCode::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.SmsCode.mobile_no)
}
inline void SmsCode::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.SmsCode.mobile_no)
}
inline void SmsCode::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.SmsCode.mobile_no)
}
inline ::std::string* SmsCode::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.SmsCode.mobile_no)
  return mobile_no_;
}
inline ::std::string* SmsCode::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SmsCode::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.SmsCode.mobile_no)
}

// required int32 sms_code = 2;
inline bool SmsCode::has_sms_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmsCode::set_has_sms_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmsCode::clear_has_sms_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmsCode::clear_sms_code() {
  sms_code_ = 0;
  clear_has_sms_code();
}
inline ::google::protobuf::int32 SmsCode::sms_code() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SmsCode.sms_code)
  return sms_code_;
}
inline void SmsCode::set_sms_code(::google::protobuf::int32 value) {
  set_has_sms_code();
  sms_code_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.SmsCode.sms_code)
}

// required int32 create_time = 3;
inline bool SmsCode::has_create_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmsCode::set_has_create_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmsCode::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmsCode::clear_create_time() {
  create_time_ = 0;
  clear_has_create_time();
}
inline ::google::protobuf::int32 SmsCode::create_time() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SmsCode.create_time)
  return create_time_;
}
inline void SmsCode::set_create_time(::google::protobuf::int32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.SmsCode.create_time)
}

// -------------------------------------------------------------------

// SendSmsCodeRequest

// required string company_key = 1;
inline bool SendSmsCodeRequest::has_company_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendSmsCodeRequest::set_has_company_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendSmsCodeRequest::clear_has_company_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendSmsCodeRequest::clear_company_key() {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_->clear();
  }
  clear_has_company_key();
}
inline const ::std::string& SendSmsCodeRequest::company_key() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendSmsCodeRequest.company_key)
  return *company_key_;
}
inline void SendSmsCodeRequest::set_company_key(const ::std::string& value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.SendSmsCodeRequest.company_key)
}
inline void SendSmsCodeRequest::set_company_key(const char* value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.SendSmsCodeRequest.company_key)
}
inline void SendSmsCodeRequest::set_company_key(const char* value, size_t size) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.SendSmsCodeRequest.company_key)
}
inline ::std::string* SendSmsCodeRequest::mutable_company_key() {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.SendSmsCodeRequest.company_key)
  return company_key_;
}
inline ::std::string* SendSmsCodeRequest::release_company_key() {
  clear_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = company_key_;
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendSmsCodeRequest::set_allocated_company_key(::std::string* company_key) {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_key_;
  }
  if (company_key) {
    set_has_company_key();
    company_key_ = company_key;
  } else {
    clear_has_company_key();
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.SendSmsCodeRequest.company_key)
}

// required string mobile_no = 2;
inline bool SendSmsCodeRequest::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendSmsCodeRequest::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendSmsCodeRequest::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendSmsCodeRequest::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& SendSmsCodeRequest::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendSmsCodeRequest.mobile_no)
  return *mobile_no_;
}
inline void SendSmsCodeRequest::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.SendSmsCodeRequest.mobile_no)
}
inline void SendSmsCodeRequest::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.SendSmsCodeRequest.mobile_no)
}
inline void SendSmsCodeRequest::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.SendSmsCodeRequest.mobile_no)
}
inline ::std::string* SendSmsCodeRequest::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.SendSmsCodeRequest.mobile_no)
  return mobile_no_;
}
inline ::std::string* SendSmsCodeRequest::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendSmsCodeRequest::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.SendSmsCodeRequest.mobile_no)
}

// -------------------------------------------------------------------

// SendSmsCodeResponse

// optional .weizhu.login.SendSmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool SendSmsCodeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendSmsCodeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendSmsCodeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendSmsCodeResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::login::SendSmsCodeResponse_Result SendSmsCodeResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendSmsCodeResponse.result)
  return static_cast< ::weizhu::login::SendSmsCodeResponse_Result >(result_);
}
inline void SendSmsCodeResponse::set_result(::weizhu::login::SendSmsCodeResponse_Result value) {
  assert(::weizhu::login::SendSmsCodeResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.SendSmsCodeResponse.result)
}

// optional string fail_text = 2;
inline bool SendSmsCodeResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendSmsCodeResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendSmsCodeResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendSmsCodeResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& SendSmsCodeResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendSmsCodeResponse.fail_text)
  return *fail_text_;
}
inline void SendSmsCodeResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.SendSmsCodeResponse.fail_text)
}
inline void SendSmsCodeResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.SendSmsCodeResponse.fail_text)
}
inline void SendSmsCodeResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.SendSmsCodeResponse.fail_text)
}
inline ::std::string* SendSmsCodeResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.SendSmsCodeResponse.fail_text)
  return fail_text_;
}
inline ::std::string* SendSmsCodeResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendSmsCodeResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.SendSmsCodeResponse.fail_text)
}

// optional int64 company_id = 3;
inline bool SendSmsCodeResponse::has_company_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendSmsCodeResponse::set_has_company_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendSmsCodeResponse::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendSmsCodeResponse::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 SendSmsCodeResponse::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendSmsCodeResponse.company_id)
  return company_id_;
}
inline void SendSmsCodeResponse::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.SendSmsCodeResponse.company_id)
}

// -------------------------------------------------------------------

// LoginBySmsCodeRequest

// required string company_key = 1;
inline bool LoginBySmsCodeRequest::has_company_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginBySmsCodeRequest::set_has_company_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginBySmsCodeRequest::clear_has_company_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginBySmsCodeRequest::clear_company_key() {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_->clear();
  }
  clear_has_company_key();
}
inline const ::std::string& LoginBySmsCodeRequest::company_key() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeRequest.company_key)
  return *company_key_;
}
inline void LoginBySmsCodeRequest::set_company_key(const ::std::string& value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginBySmsCodeRequest.company_key)
}
inline void LoginBySmsCodeRequest::set_company_key(const char* value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginBySmsCodeRequest.company_key)
}
inline void LoginBySmsCodeRequest::set_company_key(const char* value, size_t size) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginBySmsCodeRequest.company_key)
}
inline ::std::string* LoginBySmsCodeRequest::mutable_company_key() {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeRequest.company_key)
  return company_key_;
}
inline ::std::string* LoginBySmsCodeRequest::release_company_key() {
  clear_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = company_key_;
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginBySmsCodeRequest::set_allocated_company_key(::std::string* company_key) {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_key_;
  }
  if (company_key) {
    set_has_company_key();
    company_key_ = company_key;
  } else {
    clear_has_company_key();
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginBySmsCodeRequest.company_key)
}

// required string mobile_no = 2;
inline bool LoginBySmsCodeRequest::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginBySmsCodeRequest::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginBySmsCodeRequest::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginBySmsCodeRequest::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& LoginBySmsCodeRequest::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeRequest.mobile_no)
  return *mobile_no_;
}
inline void LoginBySmsCodeRequest::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginBySmsCodeRequest.mobile_no)
}
inline void LoginBySmsCodeRequest::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginBySmsCodeRequest.mobile_no)
}
inline void LoginBySmsCodeRequest::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginBySmsCodeRequest.mobile_no)
}
inline ::std::string* LoginBySmsCodeRequest::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeRequest.mobile_no)
  return mobile_no_;
}
inline ::std::string* LoginBySmsCodeRequest::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginBySmsCodeRequest::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginBySmsCodeRequest.mobile_no)
}

// required int32 sms_code = 3;
inline bool LoginBySmsCodeRequest::has_sms_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginBySmsCodeRequest::set_has_sms_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginBySmsCodeRequest::clear_has_sms_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginBySmsCodeRequest::clear_sms_code() {
  sms_code_ = 0;
  clear_has_sms_code();
}
inline ::google::protobuf::int32 LoginBySmsCodeRequest::sms_code() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeRequest.sms_code)
  return sms_code_;
}
inline void LoginBySmsCodeRequest::set_sms_code(::google::protobuf::int32 value) {
  set_has_sms_code();
  sms_code_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.LoginBySmsCodeRequest.sms_code)
}

// -------------------------------------------------------------------

// LoginBySmsCodeResponse

// optional .weizhu.login.LoginBySmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool LoginBySmsCodeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginBySmsCodeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginBySmsCodeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginBySmsCodeResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::login::LoginBySmsCodeResponse_Result LoginBySmsCodeResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.result)
  return static_cast< ::weizhu::login::LoginBySmsCodeResponse_Result >(result_);
}
inline void LoginBySmsCodeResponse::set_result(::weizhu::login::LoginBySmsCodeResponse_Result value) {
  assert(::weizhu::login::LoginBySmsCodeResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.LoginBySmsCodeResponse.result)
}

// optional string fail_text = 2;
inline bool LoginBySmsCodeResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginBySmsCodeResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginBySmsCodeResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginBySmsCodeResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& LoginBySmsCodeResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.fail_text)
  return *fail_text_;
}
inline void LoginBySmsCodeResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginBySmsCodeResponse.fail_text)
}
inline void LoginBySmsCodeResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginBySmsCodeResponse.fail_text)
}
inline void LoginBySmsCodeResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginBySmsCodeResponse.fail_text)
}
inline ::std::string* LoginBySmsCodeResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeResponse.fail_text)
  return fail_text_;
}
inline ::std::string* LoginBySmsCodeResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginBySmsCodeResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginBySmsCodeResponse.fail_text)
}

// optional bytes session_key = 3;
inline bool LoginBySmsCodeResponse::has_session_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginBySmsCodeResponse::set_has_session_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginBySmsCodeResponse::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginBySmsCodeResponse::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& LoginBySmsCodeResponse::session_key() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.session_key)
  return *session_key_;
}
inline void LoginBySmsCodeResponse::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginBySmsCodeResponse.session_key)
}
inline void LoginBySmsCodeResponse::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginBySmsCodeResponse.session_key)
}
inline void LoginBySmsCodeResponse::set_session_key(const void* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginBySmsCodeResponse.session_key)
}
inline ::std::string* LoginBySmsCodeResponse::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeResponse.session_key)
  return session_key_;
}
inline ::std::string* LoginBySmsCodeResponse::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginBySmsCodeResponse::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginBySmsCodeResponse.session_key)
}

// optional .weizhu.user.User user = 4;
inline bool LoginBySmsCodeResponse::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginBySmsCodeResponse::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginBySmsCodeResponse::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginBySmsCodeResponse::clear_user() {
  if (user_ != NULL) user_->::weizhu::user::User::Clear();
  clear_has_user();
}
inline const ::weizhu::user::User& LoginBySmsCodeResponse::user() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.user)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::weizhu::user::User* LoginBySmsCodeResponse::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::weizhu::user::User;
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeResponse.user)
  return user_;
}
inline ::weizhu::user::User* LoginBySmsCodeResponse::release_user() {
  clear_has_user();
  ::weizhu::user::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void LoginBySmsCodeResponse::set_allocated_user(::weizhu::user::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginBySmsCodeResponse.user)
}

// repeated .weizhu.user.Team ref_team = 5;
inline int LoginBySmsCodeResponse::ref_team_size() const {
  return ref_team_.size();
}
inline void LoginBySmsCodeResponse::clear_ref_team() {
  ref_team_.Clear();
}
inline const ::weizhu::user::Team& LoginBySmsCodeResponse::ref_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.ref_team)
  return ref_team_.Get(index);
}
inline ::weizhu::user::Team* LoginBySmsCodeResponse::mutable_ref_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeResponse.ref_team)
  return ref_team_.Mutable(index);
}
inline ::weizhu::user::Team* LoginBySmsCodeResponse::add_ref_team() {
  // @@protoc_insertion_point(field_add:weizhu.login.LoginBySmsCodeResponse.ref_team)
  return ref_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
LoginBySmsCodeResponse::ref_team() const {
  // @@protoc_insertion_point(field_list:weizhu.login.LoginBySmsCodeResponse.ref_team)
  return ref_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
LoginBySmsCodeResponse::mutable_ref_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.LoginBySmsCodeResponse.ref_team)
  return &ref_team_;
}

// repeated .weizhu.user.Position ref_position = 6;
inline int LoginBySmsCodeResponse::ref_position_size() const {
  return ref_position_.size();
}
inline void LoginBySmsCodeResponse::clear_ref_position() {
  ref_position_.Clear();
}
inline const ::weizhu::user::Position& LoginBySmsCodeResponse::ref_position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.ref_position)
  return ref_position_.Get(index);
}
inline ::weizhu::user::Position* LoginBySmsCodeResponse::mutable_ref_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeResponse.ref_position)
  return ref_position_.Mutable(index);
}
inline ::weizhu::user::Position* LoginBySmsCodeResponse::add_ref_position() {
  // @@protoc_insertion_point(field_add:weizhu.login.LoginBySmsCodeResponse.ref_position)
  return ref_position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
LoginBySmsCodeResponse::ref_position() const {
  // @@protoc_insertion_point(field_list:weizhu.login.LoginBySmsCodeResponse.ref_position)
  return ref_position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
LoginBySmsCodeResponse::mutable_ref_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.LoginBySmsCodeResponse.ref_position)
  return &ref_position_;
}

// repeated .weizhu.user.Level ref_level = 7;
inline int LoginBySmsCodeResponse::ref_level_size() const {
  return ref_level_.size();
}
inline void LoginBySmsCodeResponse::clear_ref_level() {
  ref_level_.Clear();
}
inline const ::weizhu::user::Level& LoginBySmsCodeResponse::ref_level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.ref_level)
  return ref_level_.Get(index);
}
inline ::weizhu::user::Level* LoginBySmsCodeResponse::mutable_ref_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginBySmsCodeResponse.ref_level)
  return ref_level_.Mutable(index);
}
inline ::weizhu::user::Level* LoginBySmsCodeResponse::add_ref_level() {
  // @@protoc_insertion_point(field_add:weizhu.login.LoginBySmsCodeResponse.ref_level)
  return ref_level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
LoginBySmsCodeResponse::ref_level() const {
  // @@protoc_insertion_point(field_list:weizhu.login.LoginBySmsCodeResponse.ref_level)
  return ref_level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
LoginBySmsCodeResponse::mutable_ref_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.LoginBySmsCodeResponse.ref_level)
  return &ref_level_;
}

// optional int64 company_id = 8;
inline bool LoginBySmsCodeResponse::has_company_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginBySmsCodeResponse::set_has_company_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginBySmsCodeResponse::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginBySmsCodeResponse::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 LoginBySmsCodeResponse::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginBySmsCodeResponse.company_id)
  return company_id_;
}
inline void LoginBySmsCodeResponse::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.LoginBySmsCodeResponse.company_id)
}

// -------------------------------------------------------------------

// LoginAutoRequest

// required string company_key = 1;
inline bool LoginAutoRequest::has_company_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAutoRequest::set_has_company_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAutoRequest::clear_has_company_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAutoRequest::clear_company_key() {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_->clear();
  }
  clear_has_company_key();
}
inline const ::std::string& LoginAutoRequest::company_key() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoRequest.company_key)
  return *company_key_;
}
inline void LoginAutoRequest::set_company_key(const ::std::string& value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoRequest.company_key)
}
inline void LoginAutoRequest::set_company_key(const char* value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginAutoRequest.company_key)
}
inline void LoginAutoRequest::set_company_key(const char* value, size_t size) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginAutoRequest.company_key)
}
inline ::std::string* LoginAutoRequest::mutable_company_key() {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoRequest.company_key)
  return company_key_;
}
inline ::std::string* LoginAutoRequest::release_company_key() {
  clear_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = company_key_;
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginAutoRequest::set_allocated_company_key(::std::string* company_key) {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_key_;
  }
  if (company_key) {
    set_has_company_key();
    company_key_ = company_key;
  } else {
    clear_has_company_key();
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginAutoRequest.company_key)
}

// required string mobile_no = 2;
inline bool LoginAutoRequest::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginAutoRequest::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginAutoRequest::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginAutoRequest::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& LoginAutoRequest::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoRequest.mobile_no)
  return *mobile_no_;
}
inline void LoginAutoRequest::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoRequest.mobile_no)
}
inline void LoginAutoRequest::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginAutoRequest.mobile_no)
}
inline void LoginAutoRequest::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginAutoRequest.mobile_no)
}
inline ::std::string* LoginAutoRequest::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoRequest.mobile_no)
  return mobile_no_;
}
inline ::std::string* LoginAutoRequest::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginAutoRequest::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginAutoRequest.mobile_no)
}

// optional int64 company_id = 3;
inline bool LoginAutoRequest::has_company_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginAutoRequest::set_has_company_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginAutoRequest::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginAutoRequest::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 LoginAutoRequest::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoRequest.company_id)
  return company_id_;
}
inline void LoginAutoRequest::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoRequest.company_id)
}

// optional int64 user_id = 4;
inline bool LoginAutoRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginAutoRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginAutoRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginAutoRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 LoginAutoRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoRequest.user_id)
  return user_id_;
}
inline void LoginAutoRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoRequest.user_id)
}

// -------------------------------------------------------------------

// LoginAutoResponse

// optional .weizhu.login.LoginAutoResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool LoginAutoResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAutoResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAutoResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAutoResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::login::LoginAutoResponse_Result LoginAutoResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.result)
  return static_cast< ::weizhu::login::LoginAutoResponse_Result >(result_);
}
inline void LoginAutoResponse::set_result(::weizhu::login::LoginAutoResponse_Result value) {
  assert(::weizhu::login::LoginAutoResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoResponse.result)
}

// optional string fail_text = 2;
inline bool LoginAutoResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginAutoResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginAutoResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginAutoResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& LoginAutoResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.fail_text)
  return *fail_text_;
}
inline void LoginAutoResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoResponse.fail_text)
}
inline void LoginAutoResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginAutoResponse.fail_text)
}
inline void LoginAutoResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginAutoResponse.fail_text)
}
inline ::std::string* LoginAutoResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoResponse.fail_text)
  return fail_text_;
}
inline ::std::string* LoginAutoResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginAutoResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginAutoResponse.fail_text)
}

// optional bytes session_key = 3;
inline bool LoginAutoResponse::has_session_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginAutoResponse::set_has_session_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginAutoResponse::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginAutoResponse::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& LoginAutoResponse::session_key() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.session_key)
  return *session_key_;
}
inline void LoginAutoResponse::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoResponse.session_key)
}
inline void LoginAutoResponse::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.LoginAutoResponse.session_key)
}
inline void LoginAutoResponse::set_session_key(const void* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.LoginAutoResponse.session_key)
}
inline ::std::string* LoginAutoResponse::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoResponse.session_key)
  return session_key_;
}
inline ::std::string* LoginAutoResponse::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginAutoResponse::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginAutoResponse.session_key)
}

// optional .weizhu.user.User user = 4;
inline bool LoginAutoResponse::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginAutoResponse::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginAutoResponse::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginAutoResponse::clear_user() {
  if (user_ != NULL) user_->::weizhu::user::User::Clear();
  clear_has_user();
}
inline const ::weizhu::user::User& LoginAutoResponse::user() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.user)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::weizhu::user::User* LoginAutoResponse::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::weizhu::user::User;
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoResponse.user)
  return user_;
}
inline ::weizhu::user::User* LoginAutoResponse::release_user() {
  clear_has_user();
  ::weizhu::user::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void LoginAutoResponse::set_allocated_user(::weizhu::user::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.LoginAutoResponse.user)
}

// repeated .weizhu.user.Team ref_team = 5;
inline int LoginAutoResponse::ref_team_size() const {
  return ref_team_.size();
}
inline void LoginAutoResponse::clear_ref_team() {
  ref_team_.Clear();
}
inline const ::weizhu::user::Team& LoginAutoResponse::ref_team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.ref_team)
  return ref_team_.Get(index);
}
inline ::weizhu::user::Team* LoginAutoResponse::mutable_ref_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoResponse.ref_team)
  return ref_team_.Mutable(index);
}
inline ::weizhu::user::Team* LoginAutoResponse::add_ref_team() {
  // @@protoc_insertion_point(field_add:weizhu.login.LoginAutoResponse.ref_team)
  return ref_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >&
LoginAutoResponse::ref_team() const {
  // @@protoc_insertion_point(field_list:weizhu.login.LoginAutoResponse.ref_team)
  return ref_team_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Team >*
LoginAutoResponse::mutable_ref_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.LoginAutoResponse.ref_team)
  return &ref_team_;
}

// repeated .weizhu.user.Position ref_position = 6;
inline int LoginAutoResponse::ref_position_size() const {
  return ref_position_.size();
}
inline void LoginAutoResponse::clear_ref_position() {
  ref_position_.Clear();
}
inline const ::weizhu::user::Position& LoginAutoResponse::ref_position(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.ref_position)
  return ref_position_.Get(index);
}
inline ::weizhu::user::Position* LoginAutoResponse::mutable_ref_position(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoResponse.ref_position)
  return ref_position_.Mutable(index);
}
inline ::weizhu::user::Position* LoginAutoResponse::add_ref_position() {
  // @@protoc_insertion_point(field_add:weizhu.login.LoginAutoResponse.ref_position)
  return ref_position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >&
LoginAutoResponse::ref_position() const {
  // @@protoc_insertion_point(field_list:weizhu.login.LoginAutoResponse.ref_position)
  return ref_position_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Position >*
LoginAutoResponse::mutable_ref_position() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.LoginAutoResponse.ref_position)
  return &ref_position_;
}

// repeated .weizhu.user.Level ref_level = 7;
inline int LoginAutoResponse::ref_level_size() const {
  return ref_level_.size();
}
inline void LoginAutoResponse::clear_ref_level() {
  ref_level_.Clear();
}
inline const ::weizhu::user::Level& LoginAutoResponse::ref_level(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.ref_level)
  return ref_level_.Get(index);
}
inline ::weizhu::user::Level* LoginAutoResponse::mutable_ref_level(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.LoginAutoResponse.ref_level)
  return ref_level_.Mutable(index);
}
inline ::weizhu::user::Level* LoginAutoResponse::add_ref_level() {
  // @@protoc_insertion_point(field_add:weizhu.login.LoginAutoResponse.ref_level)
  return ref_level_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >&
LoginAutoResponse::ref_level() const {
  // @@protoc_insertion_point(field_list:weizhu.login.LoginAutoResponse.ref_level)
  return ref_level_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::user::Level >*
LoginAutoResponse::mutable_ref_level() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.LoginAutoResponse.ref_level)
  return &ref_level_;
}

// optional int64 company_id = 8;
inline bool LoginAutoResponse::has_company_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginAutoResponse::set_has_company_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginAutoResponse::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginAutoResponse::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 LoginAutoResponse::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.LoginAutoResponse.company_id)
  return company_id_;
}
inline void LoginAutoResponse::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.LoginAutoResponse.company_id)
}

// -------------------------------------------------------------------

// GetLoginSmsCodeRequest

// required int64 user_id = 1;
inline bool GetLoginSmsCodeRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLoginSmsCodeRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLoginSmsCodeRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLoginSmsCodeRequest::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 GetLoginSmsCodeRequest::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.GetLoginSmsCodeRequest.user_id)
  return user_id_;
}
inline void GetLoginSmsCodeRequest::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.GetLoginSmsCodeRequest.user_id)
}

// -------------------------------------------------------------------

// GetLoginSmsCodeResponse

// repeated .weizhu.login.SmsCode sms_code = 1;
inline int GetLoginSmsCodeResponse::sms_code_size() const {
  return sms_code_.size();
}
inline void GetLoginSmsCodeResponse::clear_sms_code() {
  sms_code_.Clear();
}
inline const ::weizhu::login::SmsCode& GetLoginSmsCodeResponse::sms_code(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.GetLoginSmsCodeResponse.sms_code)
  return sms_code_.Get(index);
}
inline ::weizhu::login::SmsCode* GetLoginSmsCodeResponse::mutable_sms_code(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.GetLoginSmsCodeResponse.sms_code)
  return sms_code_.Mutable(index);
}
inline ::weizhu::login::SmsCode* GetLoginSmsCodeResponse::add_sms_code() {
  // @@protoc_insertion_point(field_add:weizhu.login.GetLoginSmsCodeResponse.sms_code)
  return sms_code_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::login::SmsCode >&
GetLoginSmsCodeResponse::sms_code() const {
  // @@protoc_insertion_point(field_list:weizhu.login.GetLoginSmsCodeResponse.sms_code)
  return sms_code_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::login::SmsCode >*
GetLoginSmsCodeResponse::mutable_sms_code() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.GetLoginSmsCodeResponse.sms_code)
  return &sms_code_;
}

// -------------------------------------------------------------------

// SendRegisterSmsCodeRequest

// required string company_key = 1;
inline bool SendRegisterSmsCodeRequest::has_company_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendRegisterSmsCodeRequest::set_has_company_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendRegisterSmsCodeRequest::clear_has_company_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendRegisterSmsCodeRequest::clear_company_key() {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_->clear();
  }
  clear_has_company_key();
}
inline const ::std::string& SendRegisterSmsCodeRequest::company_key() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendRegisterSmsCodeRequest.company_key)
  return *company_key_;
}
inline void SendRegisterSmsCodeRequest::set_company_key(const ::std::string& value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.SendRegisterSmsCodeRequest.company_key)
}
inline void SendRegisterSmsCodeRequest::set_company_key(const char* value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.SendRegisterSmsCodeRequest.company_key)
}
inline void SendRegisterSmsCodeRequest::set_company_key(const char* value, size_t size) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.SendRegisterSmsCodeRequest.company_key)
}
inline ::std::string* SendRegisterSmsCodeRequest::mutable_company_key() {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.SendRegisterSmsCodeRequest.company_key)
  return company_key_;
}
inline ::std::string* SendRegisterSmsCodeRequest::release_company_key() {
  clear_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = company_key_;
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRegisterSmsCodeRequest::set_allocated_company_key(::std::string* company_key) {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_key_;
  }
  if (company_key) {
    set_has_company_key();
    company_key_ = company_key;
  } else {
    clear_has_company_key();
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.SendRegisterSmsCodeRequest.company_key)
}

// required string mobile_no = 2;
inline bool SendRegisterSmsCodeRequest::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendRegisterSmsCodeRequest::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendRegisterSmsCodeRequest::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendRegisterSmsCodeRequest::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& SendRegisterSmsCodeRequest::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendRegisterSmsCodeRequest.mobile_no)
  return *mobile_no_;
}
inline void SendRegisterSmsCodeRequest::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.SendRegisterSmsCodeRequest.mobile_no)
}
inline void SendRegisterSmsCodeRequest::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.SendRegisterSmsCodeRequest.mobile_no)
}
inline void SendRegisterSmsCodeRequest::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.SendRegisterSmsCodeRequest.mobile_no)
}
inline ::std::string* SendRegisterSmsCodeRequest::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.SendRegisterSmsCodeRequest.mobile_no)
  return mobile_no_;
}
inline ::std::string* SendRegisterSmsCodeRequest::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRegisterSmsCodeRequest::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.SendRegisterSmsCodeRequest.mobile_no)
}

// -------------------------------------------------------------------

// SendRegisterSmsCodeResponse

// optional .weizhu.login.SendRegisterSmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool SendRegisterSmsCodeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendRegisterSmsCodeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendRegisterSmsCodeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendRegisterSmsCodeResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::login::SendRegisterSmsCodeResponse_Result SendRegisterSmsCodeResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendRegisterSmsCodeResponse.result)
  return static_cast< ::weizhu::login::SendRegisterSmsCodeResponse_Result >(result_);
}
inline void SendRegisterSmsCodeResponse::set_result(::weizhu::login::SendRegisterSmsCodeResponse_Result value) {
  assert(::weizhu::login::SendRegisterSmsCodeResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.SendRegisterSmsCodeResponse.result)
}

// optional string fail_text = 2;
inline bool SendRegisterSmsCodeResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendRegisterSmsCodeResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendRegisterSmsCodeResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendRegisterSmsCodeResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& SendRegisterSmsCodeResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendRegisterSmsCodeResponse.fail_text)
  return *fail_text_;
}
inline void SendRegisterSmsCodeResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.SendRegisterSmsCodeResponse.fail_text)
}
inline void SendRegisterSmsCodeResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.SendRegisterSmsCodeResponse.fail_text)
}
inline void SendRegisterSmsCodeResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.SendRegisterSmsCodeResponse.fail_text)
}
inline ::std::string* SendRegisterSmsCodeResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.SendRegisterSmsCodeResponse.fail_text)
  return fail_text_;
}
inline ::std::string* SendRegisterSmsCodeResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRegisterSmsCodeResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.SendRegisterSmsCodeResponse.fail_text)
}

// optional int64 company_id = 3;
inline bool SendRegisterSmsCodeResponse::has_company_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendRegisterSmsCodeResponse::set_has_company_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendRegisterSmsCodeResponse::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendRegisterSmsCodeResponse::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 SendRegisterSmsCodeResponse::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.SendRegisterSmsCodeResponse.company_id)
  return company_id_;
}
inline void SendRegisterSmsCodeResponse::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.SendRegisterSmsCodeResponse.company_id)
}

// -------------------------------------------------------------------

// RegisterBySmsCodeRequest

// required string company_key = 1;
inline bool RegisterBySmsCodeRequest::has_company_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_company_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterBySmsCodeRequest::clear_has_company_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterBySmsCodeRequest::clear_company_key() {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_->clear();
  }
  clear_has_company_key();
}
inline const ::std::string& RegisterBySmsCodeRequest::company_key() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.company_key)
  return *company_key_;
}
inline void RegisterBySmsCodeRequest::set_company_key(const ::std::string& value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.company_key)
}
inline void RegisterBySmsCodeRequest::set_company_key(const char* value) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.company_key)
}
inline void RegisterBySmsCodeRequest::set_company_key(const char* value, size_t size) {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  company_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.company_key)
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_company_key() {
  set_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.company_key)
  return company_key_;
}
inline ::std::string* RegisterBySmsCodeRequest::release_company_key() {
  clear_has_company_key();
  if (company_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = company_key_;
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeRequest::set_allocated_company_key(::std::string* company_key) {
  if (company_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_key_;
  }
  if (company_key) {
    set_has_company_key();
    company_key_ = company_key;
  } else {
    clear_has_company_key();
    company_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeRequest.company_key)
}

// required string user_name = 2;
inline bool RegisterBySmsCodeRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterBySmsCodeRequest::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterBySmsCodeRequest::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& RegisterBySmsCodeRequest::user_name() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.user_name)
  return *user_name_;
}
inline void RegisterBySmsCodeRequest::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.user_name)
}
inline void RegisterBySmsCodeRequest::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.user_name)
}
inline void RegisterBySmsCodeRequest::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.user_name)
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.user_name)
  return user_name_;
}
inline ::std::string* RegisterBySmsCodeRequest::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeRequest::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeRequest.user_name)
}

// optional .weizhu.user.UserBase.Gender gender = 3;
inline bool RegisterBySmsCodeRequest::has_gender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_gender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterBySmsCodeRequest::clear_has_gender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterBySmsCodeRequest::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::weizhu::user::UserBase_Gender RegisterBySmsCodeRequest::gender() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.gender)
  return static_cast< ::weizhu::user::UserBase_Gender >(gender_);
}
inline void RegisterBySmsCodeRequest::set_gender(::weizhu::user::UserBase_Gender value) {
  assert(::weizhu::user::UserBase_Gender_IsValid(value));
  set_has_gender();
  gender_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.gender)
}

// optional string email = 4;
inline bool RegisterBySmsCodeRequest::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterBySmsCodeRequest::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterBySmsCodeRequest::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& RegisterBySmsCodeRequest::email() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.email)
  return *email_;
}
inline void RegisterBySmsCodeRequest::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.email)
}
inline void RegisterBySmsCodeRequest::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.email)
}
inline void RegisterBySmsCodeRequest::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.email)
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.email)
  return email_;
}
inline ::std::string* RegisterBySmsCodeRequest::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeRequest::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeRequest.email)
}

// repeated string team = 5;
inline int RegisterBySmsCodeRequest::team_size() const {
  return team_.size();
}
inline void RegisterBySmsCodeRequest::clear_team() {
  team_.Clear();
}
inline const ::std::string& RegisterBySmsCodeRequest::team(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.team)
  return team_.Get(index);
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_team(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.team)
  return team_.Mutable(index);
}
inline void RegisterBySmsCodeRequest::set_team(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.team)
  team_.Mutable(index)->assign(value);
}
inline void RegisterBySmsCodeRequest::set_team(int index, const char* value) {
  team_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.team)
}
inline void RegisterBySmsCodeRequest::set_team(int index, const char* value, size_t size) {
  team_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.team)
}
inline ::std::string* RegisterBySmsCodeRequest::add_team() {
  return team_.Add();
}
inline void RegisterBySmsCodeRequest::add_team(const ::std::string& value) {
  team_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.login.RegisterBySmsCodeRequest.team)
}
inline void RegisterBySmsCodeRequest::add_team(const char* value) {
  team_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.login.RegisterBySmsCodeRequest.team)
}
inline void RegisterBySmsCodeRequest::add_team(const char* value, size_t size) {
  team_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.login.RegisterBySmsCodeRequest.team)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterBySmsCodeRequest::team() const {
  // @@protoc_insertion_point(field_list:weizhu.login.RegisterBySmsCodeRequest.team)
  return team_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterBySmsCodeRequest::mutable_team() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.RegisterBySmsCodeRequest.team)
  return &team_;
}

// optional string position = 6;
inline bool RegisterBySmsCodeRequest::has_position() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_position() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterBySmsCodeRequest::clear_has_position() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterBySmsCodeRequest::clear_position() {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& RegisterBySmsCodeRequest::position() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.position)
  return *position_;
}
inline void RegisterBySmsCodeRequest::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.position)
}
inline void RegisterBySmsCodeRequest::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.position)
}
inline void RegisterBySmsCodeRequest::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.position)
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.position)
  return position_;
}
inline ::std::string* RegisterBySmsCodeRequest::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeRequest::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeRequest.position)
}

// required string mobile_no = 7;
inline bool RegisterBySmsCodeRequest::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterBySmsCodeRequest::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterBySmsCodeRequest::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& RegisterBySmsCodeRequest::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.mobile_no)
  return *mobile_no_;
}
inline void RegisterBySmsCodeRequest::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.mobile_no)
}
inline void RegisterBySmsCodeRequest::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.mobile_no)
}
inline void RegisterBySmsCodeRequest::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.mobile_no)
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.mobile_no)
  return mobile_no_;
}
inline ::std::string* RegisterBySmsCodeRequest::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeRequest::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeRequest.mobile_no)
}

// required int32 sms_code = 8;
inline bool RegisterBySmsCodeRequest::has_sms_code() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_sms_code() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterBySmsCodeRequest::clear_has_sms_code() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterBySmsCodeRequest::clear_sms_code() {
  sms_code_ = 0;
  clear_has_sms_code();
}
inline ::google::protobuf::int32 RegisterBySmsCodeRequest::sms_code() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.sms_code)
  return sms_code_;
}
inline void RegisterBySmsCodeRequest::set_sms_code(::google::protobuf::int32 value) {
  set_has_sms_code();
  sms_code_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.sms_code)
}

// repeated string exts_name = 9;
inline int RegisterBySmsCodeRequest::exts_name_size() const {
  return exts_name_.size();
}
inline void RegisterBySmsCodeRequest::clear_exts_name() {
  exts_name_.Clear();
}
inline const ::std::string& RegisterBySmsCodeRequest::exts_name(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.exts_name)
  return exts_name_.Get(index);
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_exts_name(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.exts_name)
  return exts_name_.Mutable(index);
}
inline void RegisterBySmsCodeRequest::set_exts_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.exts_name)
  exts_name_.Mutable(index)->assign(value);
}
inline void RegisterBySmsCodeRequest::set_exts_name(int index, const char* value) {
  exts_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.exts_name)
}
inline void RegisterBySmsCodeRequest::set_exts_name(int index, const char* value, size_t size) {
  exts_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.exts_name)
}
inline ::std::string* RegisterBySmsCodeRequest::add_exts_name() {
  return exts_name_.Add();
}
inline void RegisterBySmsCodeRequest::add_exts_name(const ::std::string& value) {
  exts_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.login.RegisterBySmsCodeRequest.exts_name)
}
inline void RegisterBySmsCodeRequest::add_exts_name(const char* value) {
  exts_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.login.RegisterBySmsCodeRequest.exts_name)
}
inline void RegisterBySmsCodeRequest::add_exts_name(const char* value, size_t size) {
  exts_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.login.RegisterBySmsCodeRequest.exts_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterBySmsCodeRequest::exts_name() const {
  // @@protoc_insertion_point(field_list:weizhu.login.RegisterBySmsCodeRequest.exts_name)
  return exts_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterBySmsCodeRequest::mutable_exts_name() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.RegisterBySmsCodeRequest.exts_name)
  return &exts_name_;
}

// repeated string exts_value = 10;
inline int RegisterBySmsCodeRequest::exts_value_size() const {
  return exts_value_.size();
}
inline void RegisterBySmsCodeRequest::clear_exts_value() {
  exts_value_.Clear();
}
inline const ::std::string& RegisterBySmsCodeRequest::exts_value(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.exts_value)
  return exts_value_.Get(index);
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_exts_value(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.exts_value)
  return exts_value_.Mutable(index);
}
inline void RegisterBySmsCodeRequest::set_exts_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.exts_value)
  exts_value_.Mutable(index)->assign(value);
}
inline void RegisterBySmsCodeRequest::set_exts_value(int index, const char* value) {
  exts_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.exts_value)
}
inline void RegisterBySmsCodeRequest::set_exts_value(int index, const char* value, size_t size) {
  exts_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.exts_value)
}
inline ::std::string* RegisterBySmsCodeRequest::add_exts_value() {
  return exts_value_.Add();
}
inline void RegisterBySmsCodeRequest::add_exts_value(const ::std::string& value) {
  exts_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:weizhu.login.RegisterBySmsCodeRequest.exts_value)
}
inline void RegisterBySmsCodeRequest::add_exts_value(const char* value) {
  exts_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:weizhu.login.RegisterBySmsCodeRequest.exts_value)
}
inline void RegisterBySmsCodeRequest::add_exts_value(const char* value, size_t size) {
  exts_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:weizhu.login.RegisterBySmsCodeRequest.exts_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterBySmsCodeRequest::exts_value() const {
  // @@protoc_insertion_point(field_list:weizhu.login.RegisterBySmsCodeRequest.exts_value)
  return exts_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterBySmsCodeRequest::mutable_exts_value() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.login.RegisterBySmsCodeRequest.exts_value)
  return &exts_value_;
}

// optional string level = 11;
inline bool RegisterBySmsCodeRequest::has_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegisterBySmsCodeRequest::clear_has_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegisterBySmsCodeRequest::clear_level() {
  if (level_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_->clear();
  }
  clear_has_level();
}
inline const ::std::string& RegisterBySmsCodeRequest::level() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.level)
  return *level_;
}
inline void RegisterBySmsCodeRequest::set_level(const ::std::string& value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_ = new ::std::string;
  }
  level_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.level)
}
inline void RegisterBySmsCodeRequest::set_level(const char* value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_ = new ::std::string;
  }
  level_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.level)
}
inline void RegisterBySmsCodeRequest::set_level(const char* value, size_t size) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_ = new ::std::string;
  }
  level_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.level)
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_level() {
  set_has_level();
  if (level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    level_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.level)
  return level_;
}
inline ::std::string* RegisterBySmsCodeRequest::release_level() {
  clear_has_level();
  if (level_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = level_;
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeRequest::set_allocated_level(::std::string* level) {
  if (level_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete level_;
  }
  if (level) {
    set_has_level();
    level_ = level;
  } else {
    clear_has_level();
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeRequest.level)
}

// optional string phone_no = 12;
inline bool RegisterBySmsCodeRequest::has_phone_no() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RegisterBySmsCodeRequest::set_has_phone_no() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RegisterBySmsCodeRequest::clear_has_phone_no() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RegisterBySmsCodeRequest::clear_phone_no() {
  if (phone_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_no_->clear();
  }
  clear_has_phone_no();
}
inline const ::std::string& RegisterBySmsCodeRequest::phone_no() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeRequest.phone_no)
  return *phone_no_;
}
inline void RegisterBySmsCodeRequest::set_phone_no(const ::std::string& value) {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_no_ = new ::std::string;
  }
  phone_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeRequest.phone_no)
}
inline void RegisterBySmsCodeRequest::set_phone_no(const char* value) {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_no_ = new ::std::string;
  }
  phone_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeRequest.phone_no)
}
inline void RegisterBySmsCodeRequest::set_phone_no(const char* value, size_t size) {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_no_ = new ::std::string;
  }
  phone_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeRequest.phone_no)
}
inline ::std::string* RegisterBySmsCodeRequest::mutable_phone_no() {
  set_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeRequest.phone_no)
  return phone_no_;
}
inline ::std::string* RegisterBySmsCodeRequest::release_phone_no() {
  clear_has_phone_no();
  if (phone_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phone_no_;
    phone_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeRequest::set_allocated_phone_no(::std::string* phone_no) {
  if (phone_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phone_no_;
  }
  if (phone_no) {
    set_has_phone_no();
    phone_no_ = phone_no;
  } else {
    clear_has_phone_no();
    phone_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeRequest.phone_no)
}

// -------------------------------------------------------------------

// RegisterBySmsCodeResponse

// optional .weizhu.login.RegisterBySmsCodeResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool RegisterBySmsCodeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterBySmsCodeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterBySmsCodeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterBySmsCodeResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::login::RegisterBySmsCodeResponse_Result RegisterBySmsCodeResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeResponse.result)
  return static_cast< ::weizhu::login::RegisterBySmsCodeResponse_Result >(result_);
}
inline void RegisterBySmsCodeResponse::set_result(::weizhu::login::RegisterBySmsCodeResponse_Result value) {
  assert(::weizhu::login::RegisterBySmsCodeResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeResponse.result)
}

// optional string fail_text = 2;
inline bool RegisterBySmsCodeResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterBySmsCodeResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterBySmsCodeResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterBySmsCodeResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& RegisterBySmsCodeResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeResponse.fail_text)
  return *fail_text_;
}
inline void RegisterBySmsCodeResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeResponse.fail_text)
}
inline void RegisterBySmsCodeResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.login.RegisterBySmsCodeResponse.fail_text)
}
inline void RegisterBySmsCodeResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.login.RegisterBySmsCodeResponse.fail_text)
}
inline ::std::string* RegisterBySmsCodeResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.login.RegisterBySmsCodeResponse.fail_text)
  return fail_text_;
}
inline ::std::string* RegisterBySmsCodeResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegisterBySmsCodeResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.login.RegisterBySmsCodeResponse.fail_text)
}

// optional int64 company_id = 3;
inline bool RegisterBySmsCodeResponse::has_company_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterBySmsCodeResponse::set_has_company_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterBySmsCodeResponse::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterBySmsCodeResponse::clear_company_id() {
  company_id_ = GOOGLE_LONGLONG(0);
  clear_has_company_id();
}
inline ::google::protobuf::int64 RegisterBySmsCodeResponse::company_id() const {
  // @@protoc_insertion_point(field_get:weizhu.login.RegisterBySmsCodeResponse.company_id)
  return company_id_;
}
inline void RegisterBySmsCodeResponse::set_company_id(::google::protobuf::int64 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.login.RegisterBySmsCodeResponse.company_id)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace login
}  // namespace weizhu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_login_2eproto__INCLUDED
