// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contacts.proto

#ifndef PROTOBUF_contacts_2eproto__INCLUDED
#define PROTOBUF_contacts_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace weizhu {
namespace contacts {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_contacts_2eproto();
void protobuf_AssignDesc_contacts_2eproto();
void protobuf_ShutdownFile_contacts_2eproto();

class Customer;
class CreateCustomerRequest;
class CreateCustomerResponse;
class UpdateCustomerRequest;
class UpdateCustomerResponse;
class DeleteCustomerRequest;
class DeleteCustomerResponse;
class GetCustomerListRequest;
class GetCustomerListResponse;

enum CreateCustomerResponse_Result {
  CreateCustomerResponse_Result_SUCC = 0,
  CreateCustomerResponse_Result_FAIL_MOBILE_NO_INVALID = 1
};
bool CreateCustomerResponse_Result_IsValid(int value);
const CreateCustomerResponse_Result CreateCustomerResponse_Result_Result_MIN = CreateCustomerResponse_Result_SUCC;
const CreateCustomerResponse_Result CreateCustomerResponse_Result_Result_MAX = CreateCustomerResponse_Result_FAIL_MOBILE_NO_INVALID;
const int CreateCustomerResponse_Result_Result_ARRAYSIZE = CreateCustomerResponse_Result_Result_MAX + 1;

enum UpdateCustomerResponse_Result {
  UpdateCustomerResponse_Result_SUCC = 0,
  UpdateCustomerResponse_Result_FAIL_MOBILE_NO_INVALID = 1,
  UpdateCustomerResponse_Result_FAIL_CUSTOMER_NOT_EXIST = 2,
  UpdateCustomerResponse_Result_FAIL_UNKNOWN = 99
};
bool UpdateCustomerResponse_Result_IsValid(int value);
const UpdateCustomerResponse_Result UpdateCustomerResponse_Result_Result_MIN = UpdateCustomerResponse_Result_SUCC;
const UpdateCustomerResponse_Result UpdateCustomerResponse_Result_Result_MAX = UpdateCustomerResponse_Result_FAIL_UNKNOWN;
const int UpdateCustomerResponse_Result_Result_ARRAYSIZE = UpdateCustomerResponse_Result_Result_MAX + 1;

// ===================================================================

class Customer : public ::google::protobuf::MessageLite {
 public:
  Customer();
  virtual ~Customer();

  Customer(const Customer& from);

  inline Customer& operator=(const Customer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Customer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Customer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Customer* other);

  // implements Message ----------------------------------------------

  Customer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Customer& from);
  void MergeFrom(const Customer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // required int32 customer_id = 2;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 2;
  inline ::google::protobuf::int32 customer_id() const;
  inline void set_customer_id(::google::protobuf::int32 value);

  // required string customer_name = 3;
  inline bool has_customer_name() const;
  inline void clear_customer_name();
  static const int kCustomerNameFieldNumber = 3;
  inline const ::std::string& customer_name() const;
  inline void set_customer_name(const ::std::string& value);
  inline void set_customer_name(const char* value);
  inline void set_customer_name(const char* value, size_t size);
  inline ::std::string* mutable_customer_name();
  inline ::std::string* release_customer_name();
  inline void set_allocated_customer_name(::std::string* customer_name);

  // required string mobile_no = 4;
  inline bool has_mobile_no() const;
  inline void clear_mobile_no();
  static const int kMobileNoFieldNumber = 4;
  inline const ::std::string& mobile_no() const;
  inline void set_mobile_no(const ::std::string& value);
  inline void set_mobile_no(const char* value);
  inline void set_mobile_no(const char* value, size_t size);
  inline ::std::string* mutable_mobile_no();
  inline ::std::string* release_mobile_no();
  inline void set_allocated_mobile_no(::std::string* mobile_no);

  // required bool is_star = 5;
  inline bool has_is_star() const;
  inline void clear_is_star();
  static const int kIsStarFieldNumber = 5;
  inline bool is_star() const;
  inline void set_is_star(bool value);

  // optional string company = 6;
  inline bool has_company() const;
  inline void clear_company();
  static const int kCompanyFieldNumber = 6;
  inline const ::std::string& company() const;
  inline void set_company(const ::std::string& value);
  inline void set_company(const char* value);
  inline void set_company(const char* value, size_t size);
  inline ::std::string* mutable_company();
  inline ::std::string* release_company();
  inline void set_allocated_company(::std::string* company);

  // optional string position = 7;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 7;
  inline const ::std::string& position() const;
  inline void set_position(const ::std::string& value);
  inline void set_position(const char* value);
  inline void set_position(const char* value, size_t size);
  inline ::std::string* mutable_position();
  inline ::std::string* release_position();
  inline void set_allocated_position(::std::string* position);

  // optional string department = 8;
  inline bool has_department() const;
  inline void clear_department();
  static const int kDepartmentFieldNumber = 8;
  inline const ::std::string& department() const;
  inline void set_department(const ::std::string& value);
  inline void set_department(const char* value);
  inline void set_department(const char* value, size_t size);
  inline ::std::string* mutable_department();
  inline ::std::string* release_department();
  inline void set_allocated_department(::std::string* department);

  // optional string address = 9;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 9;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional string email = 10;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 10;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string wechat = 11;
  inline bool has_wechat() const;
  inline void clear_wechat();
  static const int kWechatFieldNumber = 11;
  inline const ::std::string& wechat() const;
  inline void set_wechat(const ::std::string& value);
  inline void set_wechat(const char* value);
  inline void set_wechat(const char* value, size_t size);
  inline ::std::string* mutable_wechat();
  inline ::std::string* release_wechat();
  inline void set_allocated_wechat(::std::string* wechat);

  // optional int64 qq = 12;
  inline bool has_qq() const;
  inline void clear_qq();
  static const int kQqFieldNumber = 12;
  inline ::google::protobuf::int64 qq() const;
  inline void set_qq(::google::protobuf::int64 value);

  // optional string remark = 13;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 13;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:weizhu.contacts.Customer)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();
  inline void set_has_customer_name();
  inline void clear_has_customer_name();
  inline void set_has_mobile_no();
  inline void clear_has_mobile_no();
  inline void set_has_is_star();
  inline void clear_has_is_star();
  inline void set_has_company();
  inline void clear_has_company();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_department();
  inline void clear_has_department();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_wechat();
  inline void clear_has_wechat();
  inline void set_has_qq();
  inline void clear_has_qq();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 user_id_;
  ::std::string* customer_name_;
  ::google::protobuf::int32 customer_id_;
  bool is_star_;
  ::std::string* mobile_no_;
  ::std::string* company_;
  ::std::string* position_;
  ::std::string* department_;
  ::std::string* address_;
  ::std::string* email_;
  ::std::string* wechat_;
  ::google::protobuf::int64 qq_;
  ::std::string* remark_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static Customer* default_instance_;
};
// -------------------------------------------------------------------

class CreateCustomerRequest : public ::google::protobuf::MessageLite {
 public:
  CreateCustomerRequest();
  virtual ~CreateCustomerRequest();

  CreateCustomerRequest(const CreateCustomerRequest& from);

  inline CreateCustomerRequest& operator=(const CreateCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateCustomerRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateCustomerRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateCustomerRequest* other);

  // implements Message ----------------------------------------------

  CreateCustomerRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateCustomerRequest& from);
  void MergeFrom(const CreateCustomerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.contacts.Customer customer = 1;
  inline bool has_customer() const;
  inline void clear_customer();
  static const int kCustomerFieldNumber = 1;
  inline const ::weizhu::contacts::Customer& customer() const;
  inline ::weizhu::contacts::Customer* mutable_customer();
  inline ::weizhu::contacts::Customer* release_customer();
  inline void set_allocated_customer(::weizhu::contacts::Customer* customer);

  // @@protoc_insertion_point(class_scope:weizhu.contacts.CreateCustomerRequest)
 private:
  inline void set_has_customer();
  inline void clear_has_customer();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::contacts::Customer* customer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static CreateCustomerRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateCustomerResponse : public ::google::protobuf::MessageLite {
 public:
  CreateCustomerResponse();
  virtual ~CreateCustomerResponse();

  CreateCustomerResponse(const CreateCustomerResponse& from);

  inline CreateCustomerResponse& operator=(const CreateCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateCustomerResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateCustomerResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateCustomerResponse* other);

  // implements Message ----------------------------------------------

  CreateCustomerResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateCustomerResponse& from);
  void MergeFrom(const CreateCustomerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CreateCustomerResponse_Result Result;
  static const Result SUCC = CreateCustomerResponse_Result_SUCC;
  static const Result FAIL_MOBILE_NO_INVALID = CreateCustomerResponse_Result_FAIL_MOBILE_NO_INVALID;
  static inline bool Result_IsValid(int value) {
    return CreateCustomerResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CreateCustomerResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CreateCustomerResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CreateCustomerResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .weizhu.contacts.CreateCustomerResponse.Result result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::contacts::CreateCustomerResponse_Result result() const;
  inline void set_result(::weizhu::contacts::CreateCustomerResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // optional int32 customer_id = 3;
  inline bool has_customer_id() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 3;
  inline ::google::protobuf::int32 customer_id() const;
  inline void set_customer_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:weizhu.contacts.CreateCustomerResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();
  inline void set_has_customer_id();
  inline void clear_has_customer_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  ::google::protobuf::int32 customer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static CreateCustomerResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateCustomerRequest : public ::google::protobuf::MessageLite {
 public:
  UpdateCustomerRequest();
  virtual ~UpdateCustomerRequest();

  UpdateCustomerRequest(const UpdateCustomerRequest& from);

  inline UpdateCustomerRequest& operator=(const UpdateCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateCustomerRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateCustomerRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateCustomerRequest* other);

  // implements Message ----------------------------------------------

  UpdateCustomerRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateCustomerRequest& from);
  void MergeFrom(const UpdateCustomerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .weizhu.contacts.Customer customer = 1;
  inline bool has_customer() const;
  inline void clear_customer();
  static const int kCustomerFieldNumber = 1;
  inline const ::weizhu::contacts::Customer& customer() const;
  inline ::weizhu::contacts::Customer* mutable_customer();
  inline ::weizhu::contacts::Customer* release_customer();
  inline void set_allocated_customer(::weizhu::contacts::Customer* customer);

  // @@protoc_insertion_point(class_scope:weizhu.contacts.UpdateCustomerRequest)
 private:
  inline void set_has_customer();
  inline void clear_has_customer();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::weizhu::contacts::Customer* customer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static UpdateCustomerRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateCustomerResponse : public ::google::protobuf::MessageLite {
 public:
  UpdateCustomerResponse();
  virtual ~UpdateCustomerResponse();

  UpdateCustomerResponse(const UpdateCustomerResponse& from);

  inline UpdateCustomerResponse& operator=(const UpdateCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UpdateCustomerResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateCustomerResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateCustomerResponse* other);

  // implements Message ----------------------------------------------

  UpdateCustomerResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateCustomerResponse& from);
  void MergeFrom(const UpdateCustomerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UpdateCustomerResponse_Result Result;
  static const Result SUCC = UpdateCustomerResponse_Result_SUCC;
  static const Result FAIL_MOBILE_NO_INVALID = UpdateCustomerResponse_Result_FAIL_MOBILE_NO_INVALID;
  static const Result FAIL_CUSTOMER_NOT_EXIST = UpdateCustomerResponse_Result_FAIL_CUSTOMER_NOT_EXIST;
  static const Result FAIL_UNKNOWN = UpdateCustomerResponse_Result_FAIL_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return UpdateCustomerResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    UpdateCustomerResponse_Result_Result_MIN;
  static const Result Result_MAX =
    UpdateCustomerResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    UpdateCustomerResponse_Result_Result_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .weizhu.contacts.UpdateCustomerResponse.Result result = 1 [default = FAIL_UNKNOWN];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::weizhu::contacts::UpdateCustomerResponse_Result result() const;
  inline void set_result(::weizhu::contacts::UpdateCustomerResponse_Result value);

  // optional string fail_text = 2;
  inline bool has_fail_text() const;
  inline void clear_fail_text();
  static const int kFailTextFieldNumber = 2;
  inline const ::std::string& fail_text() const;
  inline void set_fail_text(const ::std::string& value);
  inline void set_fail_text(const char* value);
  inline void set_fail_text(const char* value, size_t size);
  inline ::std::string* mutable_fail_text();
  inline ::std::string* release_fail_text();
  inline void set_allocated_fail_text(::std::string* fail_text);

  // @@protoc_insertion_point(class_scope:weizhu.contacts.UpdateCustomerResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_text();
  inline void clear_has_fail_text();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fail_text_;
  int result_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static UpdateCustomerResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteCustomerRequest : public ::google::protobuf::MessageLite {
 public:
  DeleteCustomerRequest();
  virtual ~DeleteCustomerRequest();

  DeleteCustomerRequest(const DeleteCustomerRequest& from);

  inline DeleteCustomerRequest& operator=(const DeleteCustomerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteCustomerRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteCustomerRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteCustomerRequest* other);

  // implements Message ----------------------------------------------

  DeleteCustomerRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteCustomerRequest& from);
  void MergeFrom(const DeleteCustomerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 customer_id = 1;
  inline int customer_id_size() const;
  inline void clear_customer_id();
  static const int kCustomerIdFieldNumber = 1;
  inline ::google::protobuf::int32 customer_id(int index) const;
  inline void set_customer_id(int index, ::google::protobuf::int32 value);
  inline void add_customer_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      customer_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_customer_id();

  // @@protoc_insertion_point(class_scope:weizhu.contacts.DeleteCustomerRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > customer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static DeleteCustomerRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteCustomerResponse : public ::google::protobuf::MessageLite {
 public:
  DeleteCustomerResponse();
  virtual ~DeleteCustomerResponse();

  DeleteCustomerResponse(const DeleteCustomerResponse& from);

  inline DeleteCustomerResponse& operator=(const DeleteCustomerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DeleteCustomerResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeleteCustomerResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeleteCustomerResponse* other);

  // implements Message ----------------------------------------------

  DeleteCustomerResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeleteCustomerResponse& from);
  void MergeFrom(const DeleteCustomerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:weizhu.contacts.DeleteCustomerResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static DeleteCustomerResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetCustomerListRequest : public ::google::protobuf::MessageLite {
 public:
  GetCustomerListRequest();
  virtual ~GetCustomerListRequest();

  GetCustomerListRequest(const GetCustomerListRequest& from);

  inline GetCustomerListRequest& operator=(const GetCustomerListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCustomerListRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCustomerListRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCustomerListRequest* other);

  // implements Message ----------------------------------------------

  GetCustomerListRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCustomerListRequest& from);
  void MergeFrom(const GetCustomerListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:weizhu.contacts.GetCustomerListRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static GetCustomerListRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetCustomerListResponse : public ::google::protobuf::MessageLite {
 public:
  GetCustomerListResponse();
  virtual ~GetCustomerListResponse();

  GetCustomerListResponse(const GetCustomerListResponse& from);

  inline GetCustomerListResponse& operator=(const GetCustomerListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCustomerListResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCustomerListResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCustomerListResponse* other);

  // implements Message ----------------------------------------------

  GetCustomerListResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCustomerListResponse& from);
  void MergeFrom(const GetCustomerListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .weizhu.contacts.Customer customer_list = 1;
  inline int customer_list_size() const;
  inline void clear_customer_list();
  static const int kCustomerListFieldNumber = 1;
  inline const ::weizhu::contacts::Customer& customer_list(int index) const;
  inline ::weizhu::contacts::Customer* mutable_customer_list(int index);
  inline ::weizhu::contacts::Customer* add_customer_list();
  inline const ::google::protobuf::RepeatedPtrField< ::weizhu::contacts::Customer >&
      customer_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::weizhu::contacts::Customer >*
      mutable_customer_list();

  // @@protoc_insertion_point(class_scope:weizhu.contacts.GetCustomerListResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::weizhu::contacts::Customer > customer_list_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_contacts_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_contacts_2eproto();
  #endif
  friend void protobuf_AssignDesc_contacts_2eproto();
  friend void protobuf_ShutdownFile_contacts_2eproto();

  void InitAsDefaultInstance();
  static GetCustomerListResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Customer

// required int64 user_id = 1;
inline bool Customer::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Customer::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Customer::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Customer::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 Customer::user_id() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.user_id)
  return user_id_;
}
inline void Customer::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.user_id)
}

// required int32 customer_id = 2;
inline bool Customer::has_customer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Customer::set_has_customer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Customer::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Customer::clear_customer_id() {
  customer_id_ = 0;
  clear_has_customer_id();
}
inline ::google::protobuf::int32 Customer::customer_id() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.customer_id)
  return customer_id_;
}
inline void Customer::set_customer_id(::google::protobuf::int32 value) {
  set_has_customer_id();
  customer_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.customer_id)
}

// required string customer_name = 3;
inline bool Customer::has_customer_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Customer::set_has_customer_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Customer::clear_has_customer_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Customer::clear_customer_name() {
  if (customer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customer_name_->clear();
  }
  clear_has_customer_name();
}
inline const ::std::string& Customer::customer_name() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.customer_name)
  return *customer_name_;
}
inline void Customer::set_customer_name(const ::std::string& value) {
  set_has_customer_name();
  if (customer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customer_name_ = new ::std::string;
  }
  customer_name_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.customer_name)
}
inline void Customer::set_customer_name(const char* value) {
  set_has_customer_name();
  if (customer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customer_name_ = new ::std::string;
  }
  customer_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.customer_name)
}
inline void Customer::set_customer_name(const char* value, size_t size) {
  set_has_customer_name();
  if (customer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customer_name_ = new ::std::string;
  }
  customer_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.customer_name)
}
inline ::std::string* Customer::mutable_customer_name() {
  set_has_customer_name();
  if (customer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    customer_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.customer_name)
  return customer_name_;
}
inline ::std::string* Customer::release_customer_name() {
  clear_has_customer_name();
  if (customer_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = customer_name_;
    customer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_customer_name(::std::string* customer_name) {
  if (customer_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete customer_name_;
  }
  if (customer_name) {
    set_has_customer_name();
    customer_name_ = customer_name;
  } else {
    clear_has_customer_name();
    customer_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.customer_name)
}

// required string mobile_no = 4;
inline bool Customer::has_mobile_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Customer::set_has_mobile_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Customer::clear_has_mobile_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Customer::clear_mobile_no() {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_->clear();
  }
  clear_has_mobile_no();
}
inline const ::std::string& Customer::mobile_no() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.mobile_no)
  return *mobile_no_;
}
inline void Customer::set_mobile_no(const ::std::string& value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.mobile_no)
}
inline void Customer::set_mobile_no(const char* value) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.mobile_no)
}
inline void Customer::set_mobile_no(const char* value, size_t size) {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  mobile_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.mobile_no)
}
inline ::std::string* Customer::mutable_mobile_no() {
  set_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.mobile_no)
  return mobile_no_;
}
inline ::std::string* Customer::release_mobile_no() {
  clear_has_mobile_no();
  if (mobile_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_no_;
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_mobile_no(::std::string* mobile_no) {
  if (mobile_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_no_;
  }
  if (mobile_no) {
    set_has_mobile_no();
    mobile_no_ = mobile_no;
  } else {
    clear_has_mobile_no();
    mobile_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.mobile_no)
}

// required bool is_star = 5;
inline bool Customer::has_is_star() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Customer::set_has_is_star() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Customer::clear_has_is_star() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Customer::clear_is_star() {
  is_star_ = false;
  clear_has_is_star();
}
inline bool Customer::is_star() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.is_star)
  return is_star_;
}
inline void Customer::set_is_star(bool value) {
  set_has_is_star();
  is_star_ = value;
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.is_star)
}

// optional string company = 6;
inline bool Customer::has_company() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Customer::set_has_company() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Customer::clear_has_company() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Customer::clear_company() {
  if (company_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_->clear();
  }
  clear_has_company();
}
inline const ::std::string& Customer::company() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.company)
  return *company_;
}
inline void Customer::set_company(const ::std::string& value) {
  set_has_company();
  if (company_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_ = new ::std::string;
  }
  company_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.company)
}
inline void Customer::set_company(const char* value) {
  set_has_company();
  if (company_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_ = new ::std::string;
  }
  company_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.company)
}
inline void Customer::set_company(const char* value, size_t size) {
  set_has_company();
  if (company_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_ = new ::std::string;
  }
  company_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.company)
}
inline ::std::string* Customer::mutable_company() {
  set_has_company();
  if (company_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    company_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.company)
  return company_;
}
inline ::std::string* Customer::release_company() {
  clear_has_company();
  if (company_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = company_;
    company_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_company(::std::string* company) {
  if (company_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_;
  }
  if (company) {
    set_has_company();
    company_ = company;
  } else {
    clear_has_company();
    company_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.company)
}

// optional string position = 7;
inline bool Customer::has_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Customer::set_has_position() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Customer::clear_has_position() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Customer::clear_position() {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_->clear();
  }
  clear_has_position();
}
inline const ::std::string& Customer::position() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.position)
  return *position_;
}
inline void Customer::set_position(const ::std::string& value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.position)
}
inline void Customer::set_position(const char* value) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.position)
}
inline void Customer::set_position(const char* value, size_t size) {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  position_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.position)
}
inline ::std::string* Customer::mutable_position() {
  set_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    position_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.position)
  return position_;
}
inline ::std::string* Customer::release_position() {
  clear_has_position();
  if (position_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = position_;
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_position(::std::string* position) {
  if (position_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete position_;
  }
  if (position) {
    set_has_position();
    position_ = position;
  } else {
    clear_has_position();
    position_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.position)
}

// optional string department = 8;
inline bool Customer::has_department() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Customer::set_has_department() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Customer::clear_has_department() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Customer::clear_department() {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_->clear();
  }
  clear_has_department();
}
inline const ::std::string& Customer::department() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.department)
  return *department_;
}
inline void Customer::set_department(const ::std::string& value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.department)
}
inline void Customer::set_department(const char* value) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.department)
}
inline void Customer::set_department(const char* value, size_t size) {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  department_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.department)
}
inline ::std::string* Customer::mutable_department() {
  set_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    department_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.department)
  return department_;
}
inline ::std::string* Customer::release_department() {
  clear_has_department();
  if (department_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = department_;
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_department(::std::string* department) {
  if (department_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete department_;
  }
  if (department) {
    set_has_department();
    department_ = department;
  } else {
    clear_has_department();
    department_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.department)
}

// optional string address = 9;
inline bool Customer::has_address() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Customer::set_has_address() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Customer::clear_has_address() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Customer::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Customer::address() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.address)
  return *address_;
}
inline void Customer::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.address)
}
inline void Customer::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.address)
}
inline void Customer::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.address)
}
inline ::std::string* Customer::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.address)
  return address_;
}
inline ::std::string* Customer::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.address)
}

// optional string email = 10;
inline bool Customer::has_email() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Customer::set_has_email() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Customer::clear_has_email() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Customer::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& Customer::email() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.email)
  return *email_;
}
inline void Customer::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.email)
}
inline void Customer::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.email)
}
inline void Customer::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.email)
}
inline ::std::string* Customer::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.email)
  return email_;
}
inline ::std::string* Customer::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.email)
}

// optional string wechat = 11;
inline bool Customer::has_wechat() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Customer::set_has_wechat() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Customer::clear_has_wechat() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Customer::clear_wechat() {
  if (wechat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wechat_->clear();
  }
  clear_has_wechat();
}
inline const ::std::string& Customer::wechat() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.wechat)
  return *wechat_;
}
inline void Customer::set_wechat(const ::std::string& value) {
  set_has_wechat();
  if (wechat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wechat_ = new ::std::string;
  }
  wechat_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.wechat)
}
inline void Customer::set_wechat(const char* value) {
  set_has_wechat();
  if (wechat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wechat_ = new ::std::string;
  }
  wechat_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.wechat)
}
inline void Customer::set_wechat(const char* value, size_t size) {
  set_has_wechat();
  if (wechat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wechat_ = new ::std::string;
  }
  wechat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.wechat)
}
inline ::std::string* Customer::mutable_wechat() {
  set_has_wechat();
  if (wechat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wechat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.wechat)
  return wechat_;
}
inline ::std::string* Customer::release_wechat() {
  clear_has_wechat();
  if (wechat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = wechat_;
    wechat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_wechat(::std::string* wechat) {
  if (wechat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete wechat_;
  }
  if (wechat) {
    set_has_wechat();
    wechat_ = wechat;
  } else {
    clear_has_wechat();
    wechat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.wechat)
}

// optional int64 qq = 12;
inline bool Customer::has_qq() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Customer::set_has_qq() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Customer::clear_has_qq() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Customer::clear_qq() {
  qq_ = GOOGLE_LONGLONG(0);
  clear_has_qq();
}
inline ::google::protobuf::int64 Customer::qq() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.qq)
  return qq_;
}
inline void Customer::set_qq(::google::protobuf::int64 value) {
  set_has_qq();
  qq_ = value;
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.qq)
}

// optional string remark = 13;
inline bool Customer::has_remark() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Customer::set_has_remark() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Customer::clear_has_remark() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Customer::clear_remark() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& Customer::remark() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.Customer.remark)
  return *remark_;
}
inline void Customer::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.Customer.remark)
}
inline void Customer::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.Customer.remark)
}
inline void Customer::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.Customer.remark)
}
inline ::std::string* Customer::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.Customer.remark)
  return remark_;
}
inline ::std::string* Customer::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Customer::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.Customer.remark)
}

// -------------------------------------------------------------------

// CreateCustomerRequest

// required .weizhu.contacts.Customer customer = 1;
inline bool CreateCustomerRequest::has_customer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateCustomerRequest::set_has_customer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateCustomerRequest::clear_has_customer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateCustomerRequest::clear_customer() {
  if (customer_ != NULL) customer_->::weizhu::contacts::Customer::Clear();
  clear_has_customer();
}
inline const ::weizhu::contacts::Customer& CreateCustomerRequest::customer() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.CreateCustomerRequest.customer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return customer_ != NULL ? *customer_ : *default_instance().customer_;
#else
  return customer_ != NULL ? *customer_ : *default_instance_->customer_;
#endif
}
inline ::weizhu::contacts::Customer* CreateCustomerRequest::mutable_customer() {
  set_has_customer();
  if (customer_ == NULL) customer_ = new ::weizhu::contacts::Customer;
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.CreateCustomerRequest.customer)
  return customer_;
}
inline ::weizhu::contacts::Customer* CreateCustomerRequest::release_customer() {
  clear_has_customer();
  ::weizhu::contacts::Customer* temp = customer_;
  customer_ = NULL;
  return temp;
}
inline void CreateCustomerRequest::set_allocated_customer(::weizhu::contacts::Customer* customer) {
  delete customer_;
  customer_ = customer;
  if (customer) {
    set_has_customer();
  } else {
    clear_has_customer();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.CreateCustomerRequest.customer)
}

// -------------------------------------------------------------------

// CreateCustomerResponse

// required .weizhu.contacts.CreateCustomerResponse.Result result = 1;
inline bool CreateCustomerResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateCustomerResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateCustomerResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateCustomerResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::weizhu::contacts::CreateCustomerResponse_Result CreateCustomerResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.CreateCustomerResponse.result)
  return static_cast< ::weizhu::contacts::CreateCustomerResponse_Result >(result_);
}
inline void CreateCustomerResponse::set_result(::weizhu::contacts::CreateCustomerResponse_Result value) {
  assert(::weizhu::contacts::CreateCustomerResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.contacts.CreateCustomerResponse.result)
}

// optional string fail_text = 2;
inline bool CreateCustomerResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateCustomerResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateCustomerResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateCustomerResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& CreateCustomerResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.CreateCustomerResponse.fail_text)
  return *fail_text_;
}
inline void CreateCustomerResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.CreateCustomerResponse.fail_text)
}
inline void CreateCustomerResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.CreateCustomerResponse.fail_text)
}
inline void CreateCustomerResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.CreateCustomerResponse.fail_text)
}
inline ::std::string* CreateCustomerResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.CreateCustomerResponse.fail_text)
  return fail_text_;
}
inline ::std::string* CreateCustomerResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateCustomerResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.CreateCustomerResponse.fail_text)
}

// optional int32 customer_id = 3;
inline bool CreateCustomerResponse::has_customer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateCustomerResponse::set_has_customer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateCustomerResponse::clear_has_customer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateCustomerResponse::clear_customer_id() {
  customer_id_ = 0;
  clear_has_customer_id();
}
inline ::google::protobuf::int32 CreateCustomerResponse::customer_id() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.CreateCustomerResponse.customer_id)
  return customer_id_;
}
inline void CreateCustomerResponse::set_customer_id(::google::protobuf::int32 value) {
  set_has_customer_id();
  customer_id_ = value;
  // @@protoc_insertion_point(field_set:weizhu.contacts.CreateCustomerResponse.customer_id)
}

// -------------------------------------------------------------------

// UpdateCustomerRequest

// required .weizhu.contacts.Customer customer = 1;
inline bool UpdateCustomerRequest::has_customer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateCustomerRequest::set_has_customer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateCustomerRequest::clear_has_customer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateCustomerRequest::clear_customer() {
  if (customer_ != NULL) customer_->::weizhu::contacts::Customer::Clear();
  clear_has_customer();
}
inline const ::weizhu::contacts::Customer& UpdateCustomerRequest::customer() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.UpdateCustomerRequest.customer)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return customer_ != NULL ? *customer_ : *default_instance().customer_;
#else
  return customer_ != NULL ? *customer_ : *default_instance_->customer_;
#endif
}
inline ::weizhu::contacts::Customer* UpdateCustomerRequest::mutable_customer() {
  set_has_customer();
  if (customer_ == NULL) customer_ = new ::weizhu::contacts::Customer;
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.UpdateCustomerRequest.customer)
  return customer_;
}
inline ::weizhu::contacts::Customer* UpdateCustomerRequest::release_customer() {
  clear_has_customer();
  ::weizhu::contacts::Customer* temp = customer_;
  customer_ = NULL;
  return temp;
}
inline void UpdateCustomerRequest::set_allocated_customer(::weizhu::contacts::Customer* customer) {
  delete customer_;
  customer_ = customer;
  if (customer) {
    set_has_customer();
  } else {
    clear_has_customer();
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.UpdateCustomerRequest.customer)
}

// -------------------------------------------------------------------

// UpdateCustomerResponse

// optional .weizhu.contacts.UpdateCustomerResponse.Result result = 1 [default = FAIL_UNKNOWN];
inline bool UpdateCustomerResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateCustomerResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateCustomerResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateCustomerResponse::clear_result() {
  result_ = 99;
  clear_has_result();
}
inline ::weizhu::contacts::UpdateCustomerResponse_Result UpdateCustomerResponse::result() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.UpdateCustomerResponse.result)
  return static_cast< ::weizhu::contacts::UpdateCustomerResponse_Result >(result_);
}
inline void UpdateCustomerResponse::set_result(::weizhu::contacts::UpdateCustomerResponse_Result value) {
  assert(::weizhu::contacts::UpdateCustomerResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:weizhu.contacts.UpdateCustomerResponse.result)
}

// optional string fail_text = 2;
inline bool UpdateCustomerResponse::has_fail_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateCustomerResponse::set_has_fail_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateCustomerResponse::clear_has_fail_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateCustomerResponse::clear_fail_text() {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_->clear();
  }
  clear_has_fail_text();
}
inline const ::std::string& UpdateCustomerResponse::fail_text() const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.UpdateCustomerResponse.fail_text)
  return *fail_text_;
}
inline void UpdateCustomerResponse::set_fail_text(const ::std::string& value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.UpdateCustomerResponse.fail_text)
}
inline void UpdateCustomerResponse::set_fail_text(const char* value) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:weizhu.contacts.UpdateCustomerResponse.fail_text)
}
inline void UpdateCustomerResponse::set_fail_text(const char* value, size_t size) {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  fail_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:weizhu.contacts.UpdateCustomerResponse.fail_text)
}
inline ::std::string* UpdateCustomerResponse::mutable_fail_text() {
  set_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fail_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.UpdateCustomerResponse.fail_text)
  return fail_text_;
}
inline ::std::string* UpdateCustomerResponse::release_fail_text() {
  clear_has_fail_text();
  if (fail_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fail_text_;
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateCustomerResponse::set_allocated_fail_text(::std::string* fail_text) {
  if (fail_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fail_text_;
  }
  if (fail_text) {
    set_has_fail_text();
    fail_text_ = fail_text;
  } else {
    clear_has_fail_text();
    fail_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:weizhu.contacts.UpdateCustomerResponse.fail_text)
}

// -------------------------------------------------------------------

// DeleteCustomerRequest

// repeated int32 customer_id = 1;
inline int DeleteCustomerRequest::customer_id_size() const {
  return customer_id_.size();
}
inline void DeleteCustomerRequest::clear_customer_id() {
  customer_id_.Clear();
}
inline ::google::protobuf::int32 DeleteCustomerRequest::customer_id(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.DeleteCustomerRequest.customer_id)
  return customer_id_.Get(index);
}
inline void DeleteCustomerRequest::set_customer_id(int index, ::google::protobuf::int32 value) {
  customer_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:weizhu.contacts.DeleteCustomerRequest.customer_id)
}
inline void DeleteCustomerRequest::add_customer_id(::google::protobuf::int32 value) {
  customer_id_.Add(value);
  // @@protoc_insertion_point(field_add:weizhu.contacts.DeleteCustomerRequest.customer_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DeleteCustomerRequest::customer_id() const {
  // @@protoc_insertion_point(field_list:weizhu.contacts.DeleteCustomerRequest.customer_id)
  return customer_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DeleteCustomerRequest::mutable_customer_id() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.contacts.DeleteCustomerRequest.customer_id)
  return &customer_id_;
}

// -------------------------------------------------------------------

// DeleteCustomerResponse

// -------------------------------------------------------------------

// GetCustomerListRequest

// -------------------------------------------------------------------

// GetCustomerListResponse

// repeated .weizhu.contacts.Customer customer_list = 1;
inline int GetCustomerListResponse::customer_list_size() const {
  return customer_list_.size();
}
inline void GetCustomerListResponse::clear_customer_list() {
  customer_list_.Clear();
}
inline const ::weizhu::contacts::Customer& GetCustomerListResponse::customer_list(int index) const {
  // @@protoc_insertion_point(field_get:weizhu.contacts.GetCustomerListResponse.customer_list)
  return customer_list_.Get(index);
}
inline ::weizhu::contacts::Customer* GetCustomerListResponse::mutable_customer_list(int index) {
  // @@protoc_insertion_point(field_mutable:weizhu.contacts.GetCustomerListResponse.customer_list)
  return customer_list_.Mutable(index);
}
inline ::weizhu::contacts::Customer* GetCustomerListResponse::add_customer_list() {
  // @@protoc_insertion_point(field_add:weizhu.contacts.GetCustomerListResponse.customer_list)
  return customer_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::weizhu::contacts::Customer >&
GetCustomerListResponse::customer_list() const {
  // @@protoc_insertion_point(field_list:weizhu.contacts.GetCustomerListResponse.customer_list)
  return customer_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::weizhu::contacts::Customer >*
GetCustomerListResponse::mutable_customer_list() {
  // @@protoc_insertion_point(field_mutable_list:weizhu.contacts.GetCustomerListResponse.customer_list)
  return &customer_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace contacts
}  // namespace weizhu

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_contacts_2eproto__INCLUDED
